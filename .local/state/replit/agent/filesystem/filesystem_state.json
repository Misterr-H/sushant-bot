{"file_contents":{"README.md":{"content":"# Discord-Bot\n## 🤖 Discord bot with over 500+ commands.\n\n![image](https://images-ext-2.discordapp.net/external/g3g819pEvW-xa-WU2rqgFRFkhuPflF4_mxoK63VPZ0A/https/storage.googleapis.com/replit/images/1671693930209_5b7ac25cf82388ebc5dc9793fa0bbc97.png)\n\n\n# [ALL IN ONΞ™](https://tinyurl.com/3jvb65tv)\n## [YouTube](https://tinyurl.com/3jvb65tv )\n### [Support Server](https://discord.gg/uoaio)\n\n# How to setup the bot?\n- Watch YouTube Video: [Click Here](https://youtu.be/CQP6M9AbO_E)\n---\n\n### 💘 Emotes Servers \n\n* 1.0: https://discord.gg/RjHTDAQHkR\n* 2.0: https://discord.gg/CAYR2SN76Z\n* 2.1.0: https://discord.gg/fmhTFzruzP\n* 3.0: https://discord.gg/hpwuhE2vVE\n* 3.1.0: https://discord.gg/M7DWTrYEWZ\n\n### 💕Credit\n- Code By Corwin#0001\n- Modified By Uo#1428\n\n## ✨ Discord Profile\n<div align=\"center\">\n  <a width=\"100%\" href=\"https://dsc.gg/uoaio\"  target=\"_blank\">\n    <img align=\"mid\" height=\"100%\" width=\"100%\" style=\"margin: 0 10px 0 0;\" alt=\" \" src=\"https://discord.c99.nl/widget/theme-3/922120042651451423.png\">\n    <img align=\"mid\" height=\"100%\" width=\"100%\" style=\"margin: 0 10px 0 0;\" alt=\" \" src=\"https://discord.c99.nl/widget/theme-2/755297485328482356.png\">  \n  </a>\n</div>","size_bytes":1194},"src/bot.js":{"content":"const Discord = require('discord.js');\nconst fs = require('fs');\n\nconst { Manager } = require(\"erela.js\");\nconst Spotify = require(\"erela.js-spotify\");\nconst Facebook = require(\"erela.js-facebook\");\nconst Deezer = require(\"erela.js-deezer\");\nconst AppleMusic = require(\"erela.js-apple\");\n\n// Discord client\nconst client = new Discord.Client({\n    allowedMentions: {\n        parse: [\n            'users',\n            'roles'\n        ],\n        repliedUser: true\n    },\n    autoReconnect: true,\n    disabledEvents: [\n        \"TYPING_START\"\n    ],\n    partials: [\n        Discord.Partials.Channel,\n        Discord.Partials.GuildMember,\n        Discord.Partials.Message,\n        Discord.Partials.Reaction,\n        Discord.Partials.User,\n        Discord.Partials.GuildScheduledEvent\n    ],\n    intents: [\n        Discord.GatewayIntentBits.Guilds,\n        Discord.GatewayIntentBits.GuildMembers,\n        Discord.GatewayIntentBits.GuildBans,\n        Discord.GatewayIntentBits.GuildEmojisAndStickers,\n        Discord.GatewayIntentBits.GuildIntegrations,\n        Discord.GatewayIntentBits.GuildWebhooks,\n        Discord.GatewayIntentBits.GuildInvites,\n        Discord.GatewayIntentBits.GuildVoiceStates,\n        Discord.GatewayIntentBits.GuildMessages,\n        Discord.GatewayIntentBits.GuildMessageReactions,\n        Discord.GatewayIntentBits.GuildMessageTyping,\n        Discord.GatewayIntentBits.DirectMessages,\n        Discord.GatewayIntentBits.DirectMessageReactions,\n        Discord.GatewayIntentBits.DirectMessageTyping,\n        Discord.GatewayIntentBits.GuildScheduledEvents,\n        Discord.GatewayIntentBits.MessageContent\n    ],\n    restTimeOffset: 0\n});\nconst http = require(\"http\");\nhttp.createServer((_, res) => res.end(\"UpTime\")).listen(8080)\n\n\nconst clientID = process.env.SPOTIFY_CLIENT_ID;\nconst clientSecret = process.env.SPOTIFY_CLIENT_SECRET;\nif (clientID && clientSecret) {\n    // Lavalink client\n    client.player = new Manager({\n        plugins: [\n            new AppleMusic(),\n            new Deezer(),\n            new Facebook(),\n            new Spotify({\n                clientID,\n                clientSecret,\n            })\n        ],\n        nodes: [\n            {\n                host: process.env.LAVALINK_HOST || \"lava.link\",\n                port: parseInt(process.env.LAVALINK_PORT) || 80,\n                password: process.env.LAVALINK_PASSWORD || \"CorwinDev\"\n            },\n        ],\n        send(id, payload) {\n            const guild = client.guilds.cache.get(id);\n            if (guild) guild.shard.send(payload);\n        },\n    })\n\n} else {\n    // Lavalink client\n    client.player = new Manager({\n        plugins: [\n            new AppleMusic(),\n            new Deezer(),\n            new Facebook(),\n        ],\n        nodes: [\n            {\n                host: process.env.LAVALINK_HOST || \"lava.link\",\n                port: parseInt(process.env.LAVALINK_PORT) || 80,\n                password: process.env.LAVALINK_PASSWORD || \"CorwinDev\"\n            },\n        ],\n        send(id, payload) {\n            const guild = client.guilds.cache.get(id);\n            if (guild) guild.shard.send(payload);\n        }\n    })\n}\nconst events = fs.readdirSync(`./src/events/music`).filter(files => files.endsWith('.js'));\n\nfor (const file of events) {\n    const event = require(`./events/music/${file}`);\n    client.player.on(file.split(\".\")[0], event.bind(null, client)).setMaxListeners(0);\n};\n\n// Connect to database\nrequire(\"./database/connect\")();\n\n// Client settings\nclient.config = require('./config/bot');\nclient.changelogs = require('./config/changelogs');\nclient.emotes = require(\"./config/emojis.json\");\nclient.webhooks = require(\"./config/webhooks.json\");\nconst webHooksArray = ['startLogs', 'shardLogs', 'errorLogs', 'dmLogs', 'voiceLogs', 'serverLogs', 'serverLogs2', 'commandLogs', 'consoleLogs', 'warnLogs', 'voiceErrorLogs', 'creditLogs', 'evalLogs', 'interactionLogs'];\n// Check if .env webhook_id and webhook_token are set\nif (process.env.WEBHOOK_ID && process.env.WEBHOOK_TOKEN) {\n    for (const webhookName of webHooksArray) {\n        client.webhooks[webhookName].id = process.env.WEBHOOK_ID;\n        client.webhooks[webhookName].token = process.env.WEBHOOK_TOKEN;\n    }\n}\n\nclient.commands = new Discord.Collection();\nclient.playerManager = new Map();\nclient.triviaManager = new Map();\nclient.queue = new Map();\n\n// Webhooks\nconst consoleLogs = new Discord.WebhookClient({\n    id: client.webhooks.consoleLogs.id,\n    token: client.webhooks.consoleLogs.token,\n});\n\nconst warnLogs = new Discord.WebhookClient({\n    id: client.webhooks.warnLogs.id,\n    token: client.webhooks.warnLogs.token,\n});\n\n// Load handlers\nfs.readdirSync('./src/handlers').forEach((dir) => {\n    fs.readdirSync(`./src/handlers/${dir}`).forEach((handler) => {\n        require(`./handlers/${dir}/${handler}`)(client);\n    });\n});\n\nclient.login(process.env.DISCORD_TOKEN);\n\nprocess.on('unhandledRejection', error => {\n    console.error('Unhandled promise rejection:', error);\n    if (error) if (error.length > 950) error = error.slice(0, 950) + '... view console for details';\n    if (error.stack) if (error.stack.length > 950) error.stack = error.stack.slice(0, 950) + '... view console for details';\n    if(!error.stack) return\n    const embed = new Discord.EmbedBuilder()\n        .setTitle(`🚨・Unhandled promise rejection`)\n        .addFields([\n            {\n                name: \"Error\",\n                value: error ? Discord.codeBlock(error) : \"No error\",\n            },\n            {\n                name: \"Stack error\",\n                value: error.stack ? Discord.codeBlock(error.stack) : \"No stack error\",\n            }\n        ])\n        .setColor(client.config.colors.normal)\n    consoleLogs.send({\n        username: 'Bot Logs',\n        embeds: [embed],\n    }).catch(() => {\n        console.log('Error sending unhandledRejection to webhook')\n        console.log(error)\n    })\n});\n\nprocess.on('warning', warn => {\n    console.warn(\"Warning:\", warn);\n    const embed = new Discord.EmbedBuilder()\n        .setTitle(`🚨・New warning found`)\n        .addFields([\n            {\n                name: `Warn`,\n                value: `\\`\\`\\`${warn}\\`\\`\\``,\n            },\n        ])\n        .setColor(client.config.colors.normal)\n    warnLogs.send({\n        username: 'Bot Logs',\n        embeds: [embed],\n    }).catch(() => {\n        console.log('Error sending warning to webhook')\n        console.log(warn)\n    })\n});\n\nclient.on(Discord.ShardEvents.Error, error => {\n    console.log(error)\n    if (error) if (error.length > 950) error = error.slice(0, 950) + '... view console for details';\n    if (error.stack) if (error.stack.length > 950) error.stack = error.stack.slice(0, 950) + '... view console for details';\n    if (!error.stack) return\n    const embed = new Discord.EmbedBuilder()\n        .setTitle(`🚨・A websocket connection encountered an error`)\n        .addFields([\n            {\n                name: `Error`,\n                value: `\\`\\`\\`${error}\\`\\`\\``,\n            },\n            {\n                name: `Stack error`,\n                value: `\\`\\`\\`${error.stack}\\`\\`\\``,\n            }\n        ])\n        .setColor(client.config.colors.normal)\n    consoleLogs.send({\n        username: 'Bot Logs',\n        embeds: [embed],\n    });\n});\n\n// auto kill\nconst ms = require(\"ms\");\nsetInterval(() => {\n  if (!client || !client.user) {\n    console.log(\"Client Not Login, Process Kill\")\n    process.kill(1);\n  }\n}, ms(\"1m\"));\n\n// Discord: dsc.gg/uoaio or Uo#0331\n","size_bytes":7497},"src/dev.js":{"content":"/*\n* This file adds a developer badge to a user \n* Only use this if you want to add a badge to a user\n* If someone tells you to use this to add their id, they are lying \n* \n* @string member - The member you want to add the badge to\n*/\nconst chalk = require('chalk');\nif (!process.argv[2]) {\n    console.log(chalk.red(`[ERROR]`), chalk.white(`>>`), chalk.red(`Developer Badge`), chalk.white(`>>`), chalk.red(`Please provide a member id!`))\n    process.exit(1);\n}\nrequire('dotenv').config('./.env');\n// Require database\nconst mongoose = require('mongoose');\n// Require the model\nconst model = require('./database/models/badge.js');\n// Connect to the database\nmongoose.set('strictQuery', false);\n// Await the connection\nmongoose.connect(process.env.MONGO_TOKEN, {\n    useNewUrlParser: true,\n    useUnifiedTopology: true\n}).then(() => {\n    console.log(chalk.green(`[SUCCESS]`), chalk.white(`>>`), chalk.green(`Developer Badge`), chalk.white(`>>`), chalk.green(`Connected to the database!`))\n}).catch((err) => {\n    console.log(chalk.red(`[ERROR]`), chalk.white(`>>`), chalk.red(`Developer Badge`), chalk.white(`>>`), chalk.red(`Failed to connect to the database!`))\n    console.log(err)\n    process.exit(1);\n});\n// Find the user\nmodel.findOne({\n    User: process.argv[2]\n}, async (err, data) => {\n    if (err) console.log(err);\n    if (!data) {\n        // Create a new document\n        const newData = new model({\n            User: process.argv[2],\n            FLAGS: [\n                \"DEVELOPER\"\n            ]\n        });\n        try {\n            await newData.save();\n        } catch (err) {\n            console.log(err)\n        }\n        console.log((chalk.white(`>>`)), chalk.red(`Developer Badge`), chalk.green(`has been added to the user!`))\n        mongoose.connection.close();\n        process.exit(0);\n    }\n    if (data) {\n        // Update the document\n        data.FLAGS.push(\"DEVELOPER\");\n        try {\n            await data.save();\n        } catch (err) {\n            console.log(err)\n        }\n        console.log((chalk.white(`>>`)), chalk.red(`Developer Badge`), chalk.green(`has been added to the user!`))\n        mongoose.connection.close();\n        process.exit(0);\n    }\n});","size_bytes":2194},"src/index.js":{"content":"const Discord = require('discord.js');\nconst chalk = require('chalk');\nrequire('dotenv').config('./.env');\nconst axios = require('axios');\n\n\n\nconst webhook = require(\"./config/webhooks.json\");\nconst config = require(\"./config/bot.js\");\nconst webHooksArray = ['startLogs', 'shardLogs', 'errorLogs', 'dmLogs', 'voiceLogs', 'serverLogs', 'serverLogs2', 'commandLogs', 'consoleLogs', 'warnLogs', 'voiceErrorLogs', 'creditLogs', 'evalLogs', 'interactionLogs'];\n\n// Check if .env webhook_id and webhook_token are set\nif (process.env.WEBHOOK_ID && process.env.WEBHOOK_TOKEN) {\n    for (const webhookName of webHooksArray) {\n        webhook[webhookName].id = process.env.WEBHOOK_ID;\n        webhook[webhookName].token = process.env.WEBHOOK_TOKEN;\n    }\n}\nconst startLogs = new Discord.WebhookClient({\n    id: webhook.startLogs.id,\n    token: webhook.startLogs.token,\n});\n\nconst shardLogs = new Discord.WebhookClient({\n    id: webhook.shardLogs.id,\n    token: webhook.shardLogs.token,\n});\n\nconst manager = new Discord.ShardingManager('./src/bot.js', {\n    totalShards: 'auto',\n    token: process.env.DISCORD_TOKEN,\n    respawn: true\n});\nif (process.env.TOPGG_TOKEN) {\n    const { AutoPoster } = require('topgg-autoposter');\n    AutoPoster(process.env.TOPGG_TOKEN, manager);\n}\nconsole.clear();\nconsole.log(chalk.blue(chalk.bold(`System`)), (chalk.white(`>>`)), (chalk.green(`Starting up`)), (chalk.white(`...`)))\nconsole.log(`\\u001b[0m`)\nconsole.log(chalk.red(`© CorwinDev | 2021 - ${new Date().getFullYear()}`))\nconsole.log(chalk.red(`All rights reserved`))\nconsole.log(`\\u001b[0m`)\nconsole.log(`\\u001b[0m`)\nconsole.log(chalk.blue(chalk.bold(`System`)), (chalk.white(`>>`)), chalk.red(`Version ${require(`${process.cwd()}/package.json`).version}`), (chalk.green(`loaded`)))\nconsole.log(`\\u001b[0m`);\n\nmanager.on('shardCreate', shard => {\n    let embed = new Discord.EmbedBuilder()\n        .setTitle(`🆙・Launching shard`)\n        .setDescription(`A shard has just been launched`)\n        .setFields([\n            {\n                name: \"🆔┆ID\",\n                value: `${shard.id + 1}/${manager.totalShards}`,\n                inline: true\n            },\n            {\n                name: `📃┆State`,\n                value: `Starting up...`,\n                inline: true\n            }\n        ])\n        .setColor(config.colors.normal)\n   if(startLogs) startLogs.send({\n        username: 'Bot Logs',\n        embeds: [embed],\n    });\n\n    console.log(chalk.blue(chalk.bold(`System`)), (chalk.white(`>>`)), (chalk.green(`Starting`)), chalk.red(`Shard #${shard.id + 1}`), (chalk.white(`...`)))\n    console.log(`\\u001b[0m`);\n\n    shard.on(\"death\", (process) => {\n        const embed = new Discord.EmbedBuilder()\n            .setTitle(`🚨・Closing shard ${shard.id + 1}/${manager.totalShards} unexpectedly`)\n            .setFields([\n                {\n                    name: \"🆔┆ID\",\n                    value: `${shard.id + 1}/${manager.totalShards}`,\n                },\n            ])\n            .setColor(config.colors.normal)\n        shardLogs.send({\n            username: 'Bot Logs',\n            embeds: [embed]\n        });\n\n        if (process.exitCode === null) {\n            const embed = new Discord.EmbedBuilder()\n                .setTitle(`🚨・Shard ${shard.id + 1}/${manager.totalShards} exited with NULL error code!`)\n                .setFields([\n                    {\n                        name: \"PID\",\n                        value: `\\`${process.pid}\\``,\n                    },\n                    {\n                        name: \"Exit code\",\n                        value: `\\`${process.exitCode}\\``,\n                    }\n                ])\n                .setColor(config.colors.normal)\n            shardLogs.send({\n                username: 'Bot Logs',\n                embeds: [embed]\n            });\n        }\n    });\n\n    shard.on(\"shardDisconnect\", (event) => {\n        const embed = new Discord.EmbedBuilder()\n            .setTitle(`🚨・Shard ${shard.id + 1}/${manager.totalShards} disconnected`)\n            .setDescription(\"Dumping socket close event...\")\n            .setColor(config.colors.normal)\n        shardLogs.send({\n            username: 'Bot Logs',\n            embeds: [embed],\n        });\n    });\n\n    shard.on(\"shardReconnecting\", () => {\n        const embed = new Discord.EmbedBuilder()\n            .setTitle(`🚨・Reconnecting shard ${shard.id + 1}/${manager.totalShards}`)\n            .setColor(config.colors.normal)\n        shardLogs.send({\n            username: 'Bot Logs',\n            embeds: [embed],\n        });\n    });\n});\n\n\nmanager.spawn();\n\n\n// Webhooks\nconst consoleLogs = new Discord.WebhookClient({\n    id: webhook.consoleLogs.id,\n    token: webhook.consoleLogs.token,\n});\n\nconst warnLogs = new Discord.WebhookClient({\n    id: webhook.warnLogs.id,\n    token: webhook.warnLogs.token,\n});\n\nprocess.on('unhandledRejection', error => {\n    console.error('Unhandled promise rejection:', error);\n    if (error) if (error.length > 950) error = error.slice(0, 950) + '... view console for details';\n    if (error.stack) if (error.stack.length > 950) error.stack = error.stack.slice(0, 950) + '... view console for details';\n    if (!error.stack) return\n    const embed = new Discord.EmbedBuilder()\n        .setTitle(`🚨・Unhandled promise rejection`)\n        .addFields([\n            {\n                name: \"Error\",\n                value: error ? Discord.codeBlock(error) : \"No error\",\n            },\n            {\n                name: \"Stack error\",\n                value: error.stack ? Discord.codeBlock(error.stack) : \"No stack error\",\n            }\n        ])\n    consoleLogs.send({\n        username: 'Bot Logs',\n        embeds: [embed],\n    }).catch(() => {\n        console.log('Error sending unhandled promise rejection to webhook')\n        console.log(error)\n    })\n});\n\nprocess.on('warning', warn => {\n    console.warn(\"Warning:\", warn);\n    const embed = new Discord.EmbedBuilder()\n        .setTitle(`🚨・New warning found`)\n        .addFields([\n            {\n                name: `Warn`,\n                value: `\\`\\`\\`${warn}\\`\\`\\``,\n            },\n        ])\n    warnLogs.send({\n        username: 'Bot Logs',\n        embeds: [embed],\n    }).catch(() => {\n        console.log('Error sending warning to webhook')\n        console.log(warn)\n    })\n});","size_bytes":6330},"src/database/connect.js":{"content":"const mongoose = require('mongoose');\nconst chalk = require('chalk');\n\nasync function connect() {\n    mongoose.set('strictQuery', false);\n    try {\n        console.log(chalk.blue(chalk.bold(`Database`)), (chalk.white(`>>`)), chalk.red(`MongoDB`), chalk.green(`is connecting...`))\n        await mongoose.connect(process.env.MONGO_TOKEN, {\n            useNewUrlParser: true,\n            useUnifiedTopology: true,\n        });\n    } catch (err) {\n        console.log(chalk.red(`[ERROR]`), chalk.white(`>>`), chalk.red(`MongoDB`), chalk.white(`>>`), chalk.red(`Failed to connect to MongoDB!`), chalk.white(`>>`), chalk.red(`Error: ${err}`))\n        console.log(chalk.red(\"Exiting...\"))\n        process.exit(1)\n    }\n\n\n    mongoose.connection.once(\"open\", () => {\n        console.log(chalk.blue(chalk.bold(`Database`)), (chalk.white(`>>`)), chalk.red(`MongoDB`), chalk.green(`is ready!`))\n    });\n\n    mongoose.connection.on(\"error\", (err) => {\n        console.log(chalk.red(`[ERROR]`), chalk.white(`>>`), chalk.red(`Database`), chalk.white(`>>`), chalk.red(`Failed to connect to MongoDB!`), chalk.white(`>>`), chalk.red(`Error: ${err}`))\n        console.log(chalk.red(\"Exiting...\"))\n        process.exit(1)\n    });\n    return;\n}\n\nmodule.exports = connect","size_bytes":1249},"src/assets/utils/TriviaPlayer.js":{"content":"const {\n    AudioPlayerStatus,\n    createAudioPlayer,\n    entersState,\n    VoiceConnectionDisconnectReason,\n    VoiceConnectionStatus,\n    createAudioResource,\n    StreamType\n} = require('@discordjs/voice');\nconst { setTimeout } = require('timers');\nconst { promisify } = require('util');\nconst ytdl = require('ytdl-core');\nconst { MessageEmbed } = require('discord.js');\nconst wait = promisify(setTimeout);\n\nclass TriviaPlayer {\n    constructor() {\n        this.connection = null;\n        this.audioPlayer = createAudioPlayer();\n        this.score = new Map();\n        this.queue = [];\n        this.textChannel;\n        this.wasTriviaEndCalled = false;\n    }\n\n    passConnection(connection) {\n        this.connection = connection;\n        this.connection.on('stateChange', async (_, newState) => {\n            if (newState.status === VoiceConnectionStatus.Disconnected) {\n                if (\n                    newState.reason === VoiceConnectionDisconnectReason.WebSocketClose &&\n                    newState.closeCode === 4014\n                ) {\n                    try {\n                        await entersState(\n                            this.connection,\n                            VoiceConnectionStatus.Connecting,\n                            5000\n                        );\n                    } catch {\n                        this.connection.destroy();\n                    }\n                } else if (this.connection.rejoinAttemps < 5) {\n                    await wait((this.connection.rejoinAttemps + 1) * 5000);\n                    this.connection.rejoin();\n                } else {\n                    this.connection.destroy();\n                }\n            } else if (newState.status === VoiceConnectionStatus.Destroyed) {\n                // when destroying connection (stop-trivia)\n                this.stop();\n            } else if (\n                newState.status === VoiceConnectionStatus.Connecting ||\n                newState.status === VoiceConnectionStatus.Signalling\n            ) {\n                try {\n                    await entersState(\n                        this.connection,\n                        VoiceConnectionStatus.Ready,\n                        20000\n                    );\n                } catch {\n                    if (this.connection.state.status !== VoiceConnectionStatus.Destroyed)\n                        this.connection.destroy();\n                }\n            }\n        });\n\n        this.audioPlayer.on('stateChange', (oldState, newState) => {\n            if (\n                newState.status === AudioPlayerStatus.Idle &&\n                oldState.status !== AudioPlayerStatus.Idle\n            ) {\n                this.queue.shift();\n                // Finished playing audio\n                if (this.queue.length) {\n                    // play next song\n                    this.process(this.queue);\n                } else {\n                    const sortedScoreMap = new Map(\n                        [...this.score.entries()].sort(function (a, b) {\n                            return b[1] - a[1];\n                        })\n                    );\n\n                    if (this.wasTriviaEndCalled) return;\n\n                    this.textChannel.client.embed({\n                        title: `🎶・Music Quiz - Results`,\n                        desc: getLeaderBoard(Array.from(sortedScoreMap.entries())),\n                        edit: true\n                    }, this.textChannel)\n\n                    // leave channel close connection and subscription\n                    if (this.connection._state.status !== 'destroyed') {\n                        this.connection.destroy();\n                        this.textChannel.client.triviaManager.delete(\n                            this.textChannel.guildId\n                        );\n                    }\n                }\n            } else if (newState.status === AudioPlayerStatus.Playing) {\n                // trivia logic\n                let songNameFound = false;\n                let songSingerFound = false;\n\n                let skipCounter = 0;\n                const skippedArray = [];\n\n                const collector = this.textChannel.createMessageCollector({\n                    time: 30000\n                });\n\n                collector.on('collect', msg => {\n                    if (!this.score.has(msg.author.username)) return;\n                    let guess = normalizeValue(msg.content);\n                    let title = normalizeValue(this.queue[0].title);\n                    let singer = normalizeValue(this.queue[0].singer);\n\n                    if (guess === 'skip') {\n                        if (skippedArray.includes(msg.author.username)) {\n                            return;\n                        }\n                        skippedArray.push(msg.author.username);\n                        skipCounter++;\n                        if (skipCounter > this.score.size * 0.6) {\n                            return collector.stop();\n                        }\n                        return;\n                    }\n\n                    // if user guessed both singer and song name\n                    if (guess.includes(singer) && guess.includes(title)) {\n                        if (\n                            (songSingerFound && !songNameFound) ||\n                            (songNameFound && !songSingerFound)\n                        ) {\n                            this.score.set(\n                                msg.author.username,\n                                this.score.get(msg.author.username) + 1\n                            );\n                            msg.react('☑');\n                            return collector.stop();\n                        }\n                        this.score.set(\n                            msg.author.username,\n                            this.score.get(msg.author.username) + 2\n                        );\n                        msg.react('☑');\n                        return collector.stop();\n                    }\n                    // if user guessed only the singer\n                    else if (guess.includes(singer)) {\n                        if (songSingerFound) return; // already been found\n                        songSingerFound = true;\n                        if (songNameFound && songSingerFound) {\n                            this.score.set(\n                                msg.author.username,\n                                this.score.get(msg.author.username) + 1\n                            );\n                            msg.react('☑');\n                            return collector.stop();\n                        }\n\n                        this.score.set(\n                            msg.author.username,\n                            this.score.get(msg.author.username) + 1\n                        );\n                        msg.react('☑');\n                    }\n                    // if user guessed song name\n                    else if (guess.includes(title)) {\n                        if (songNameFound) return; // if song name has already been found\n                        songNameFound = true;\n\n                        if (songNameFound && songSingerFound) {\n                            this.score.set(\n                                msg.author.username,\n                                this.score.get(msg.author.username) + 1\n                            );\n                            msg.react('☑');\n                            return collector.stop();\n                        }\n                        this.score.set(\n                            msg.author.username,\n                            this.score.get(msg.author.username) + 1\n                        );\n                        msg.react('☑');\n                    } else {\n                        // wrong answer\n                        return msg.react('❌');\n                    }\n                });\n\n                collector.on('end', () => {\n                    /*\n                      The reason for this if statement is that we don't want to get an\n                      empty embed returned via chat by the bot if end-trivia command was called\n                      */\n                    if (this.wasTriviaEndCalled) {\n                        this.wasTriviaEndCalled = false;\n                        return;\n                    }\n\n                    this.audioPlayer.stop();\n\n                    const sortedScoreMap = new Map(\n                        [...this.score.entries()].sort(function (a, b) {\n                            return b[1] - a[1];\n                        })\n                    );\n\n                    const song = `${capitalize_Words(\n                        this.queue[0].singer\n                    )}: ${capitalize_Words(this.queue[0].title)}`;\n\n                    this.textChannel.client.embed({\n                        title: `🎶・Music Quiz`,\n                        desc: `The song was:  ${song} \\n\\n${getLeaderBoard(Array.from(sortedScoreMap.entries()))}`,\n                        edit: true\n                    }, this.textChannel)\n                    return;\n                });\n            }\n        });\n\n        this.audioPlayer.on('error', error => {\n            console.error(error);\n        });\n\n        this.connection.subscribe(this.audioPlayer);\n    }\n\n    stop() {\n        this.queue.length = 0;\n        this.audioPlayer.stop(true);\n    }\n\n    async process(queue) {\n        const song = this.queue[0];\n        try {\n            const stream = ytdl(song.url, {\n                filter: 'audio',\n                quality: 'highestaudio',\n                highWaterMark: 1 << 25\n            });\n            const resource = createAudioResource(stream, {\n                inputType: StreamType.Arbitrary\n            });\n            this.audioPlayer.play(resource);\n        } catch (err) {\n            console.log(err.message)\n            if (err.message === 'FFmpeg/avconv not found!') {\n                this.textChannel.client.embed({\n                    title: `🎶・Music Quiz`,\n                    desc: `FFmpg/avconv not found!`,\n                    edit: true\n                }, this.textChannel)\n                return this.stop();\n            } else {\n                return this.process(queue);\n            }\n        }\n    }\n}\n\nvar getLeaderBoard = arr => {\n    if (!arr) return;\n    if (!arr[0]) return;\n    let leaderBoard = '';\n\n    leaderBoard = `👑   **${arr[0][0]}:** ${arr[0][1]}  points`;\n\n    if (arr.length > 1) {\n        for (let i = 1; i < arr.length; i++) {\n            leaderBoard =\n                leaderBoard + `\\n\\n   ${i + 1}: ${arr[i][0]}: ${arr[i][1]}  points`;\n        }\n    }\n    return leaderBoard;\n};\n\nvar capitalize_Words = str => {\n    return str.replace(/\\w\\S*/g, function (txt) {\n        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();\n    });\n};\n\nvar normalizeValue = value =>\n    value\n        .normalize('NFD')\n        .replace(/[\\u0300-\\u036f]/g, '') // remove diacritics\n        .replace(/[^0-9a-zA-Z\\s]/g, '') // remove non-alphanumeric characters\n        .trim()\n        .replace(/\\s+/g, ' ')\n        .toLowerCase(); // remove duplicate spaces\n\nmodule.exports = TriviaPlayer;\n","size_bytes":11155},"src/assets/utils/forhumans.js":{"content":"function forHumans(o) {\n  for (\n    var r = [\n      [Math.floor(o / 31536e3), \"years\"],\n      [Math.floor((o % 31536e3) / 86400), \"days\"],\n      [Math.floor(((o % 31536e3) % 86400) / 3600), \"hours\"],\n      [Math.floor((((o % 31536e3) % 86400) % 3600) / 60), \"minutes\"],\n      [(((o % 31536e3) % 86400) % 3600) % 60, \"seconds\"],\n    ],\n    e = \"\",\n    t = 0,\n    s = r.length;\n    t < s;\n    t++\n  )\n    0 !== r[t][0] &&\n      (e +=\n        \" \" +\n        r[t][0] +\n        \" \" +\n        (1 === r[t][0] ? r[t][1].substr(0, r[t][1].length - 1) : r[t][1]));\n  return e.trim();\n}\n\nmodule.exports = forHumans;\n\n","size_bytes":605},"src/assets/utils/static.js":{"content":"module.exports.defaultPFP = 'https://cdn.discordapp.com/embed/avatars/0.png';\n\nmodule.exports.DummyUser = {\n    bot: false,\n    id: '00000000000',\n    tag: \"Unknown User#0000\",\n    name: \"Unknown User\",\n    username: \"Unknown User\",\n    hexAccentColor: \"#FFFFFF\",\n    avatarURL: () => 'https://cdn.discordapp.com/embed/avatars/0.png'\n}","size_bytes":335},"src/commands/afk/list.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require('../../database/models/afk');\n\nmodule.exports = async (client, interaction, args) => {\n    const rawboard = await Schema.find({ Guild: interaction.guild.id })\n\n    if (rawboard.length < 1) return client.errNormal({ \n        error: \"No data found!\",\n        type: 'editreply'\n    }, interaction);\n\n    const lb = rawboard.map(e => `<@!${e.User}> - **Reason** ${e.Message}`);\n\n    await client.createLeaderboard(`🚫・AFK users - ${interaction.guild.name}`, lb, interaction);\n}\n\n ","size_bytes":543},"src/commands/afk/set.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require('../../database/models/afk');\n\nmodule.exports = async (client, interaction, args) => {\n    const reason = interaction.options.getString('reason') || `Not specified`;\n\n    Schema.findOne({ Guild: interaction.guild.id, User: interaction.user.id }, async (err, data) => {\n        if (data) {\n            return client.errNormal({ \n                error: `You're already afk!`,\n                type: 'editreply' \n            }, interaction);\n        }\n        else {\n            new Schema({\n                Guild: interaction.guild.id,\n                User: interaction.user.id,\n                Message: reason\n            }).save();\n\n            if (!interaction.member.displayName.includes(`[AFK] `)) {\n                interaction.member.setNickname(`[AFK] ` + interaction.member.displayName).catch(e => { });\n            }\n\n            client.succNormal({ \n                text: `Your AFK has been set up successfully`,\n                type: 'ephemeraledit'\n            }, interaction);\n\n            client.embed({ \n                desc: `${interaction.user} is now afk! **Reason:** ${reason}` \n            }, interaction.channel)\n        }\n    })\n}\n\n ","size_bytes":1215},"src/commands/announcement/create.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    const message = interaction.options.getString('message');\n    const channel = interaction.options.getChannel('channel');\n\n    client.embed({ \n        title: `📢・Announcement!`, \n        desc: message \n    }, channel);\n\n    client.succNormal({\n        text: `Announcement has been sent successfully!`,\n        fields: [\n            {\n                name: `📘┆Channel`,\n                value: `${channel} (${channel.name})`\n            }\n        ],\n        type: 'editreply'\n    }, interaction);\n}\n\n ","size_bytes":607},"src/commands/announcement/edit.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    const message = interaction.options.getString('message');\n    const messageId = interaction.options.getString('id');\n\n    const editMessage = await interaction.channel.messages.fetch(messageId);\n\n    client.embed({ \n        title: `📢・Announcement!`, \n        desc: message,\n        type: 'edit'\n    }, editMessage);\n\n    client.succNormal({\n        text: `Announcement has been edit successfully!`,\n        type: 'ephemeraledit'\n    }, interaction);\n}\n\n ","size_bytes":559},"src/commands/automod/add.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/blacklist\");\n\nmodule.exports = async (client, interaction, args) => {\n    const word = interaction.options.getString('word');\n\n    Schema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n        if (data) {\n            if (data.Words.includes(word)) {\n                return client.errNormal({ \n                    error: `That word is already exists in the database!`,\n                    type: 'editreply' \n                }, interaction);\n            }\n            if(!data.Words) data.Words = [];\n            data.Words.push(word);\n            data.save();\n        }\n        else {\n            new Schema({\n                Guild: interaction.guild.id,\n                Words: word\n            }).save();\n        }\n    })\n\n    client.succNormal({\n        text: `Word is now blacklisted!`,\n        fields: [\n            {\n                name: `💬┆Word`,\n                value: `${word}`\n            }\n        ],\n        type: 'editreply'\n    }, interaction);\n}\n\n ","size_bytes":1070},"src/commands/automod/antiinvite.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require('../../database/models/functions');\n\nmodule.exports = async (client, interaction, args) => {\n    const boolean = interaction.options.getBoolean('active');\n\n    const data = await Schema.findOne({ Guild: interaction.guild.id });\n    if (data) {\n        data.AntiInvite = boolean;\n        data.save();\n    }\n    else {\n        new Schema({\n            Guild: interaction.guild.id,\n            AntiInvite: boolean,\n        }).save();\n    }\n\n    client.succNormal({\n        text: `Anti invite is now **${boolean ? 'enabled' : 'disabled'}** in this guild`,\n        type: 'editreply'\n    }, interaction);\n}\n\n ","size_bytes":666},"src/commands/automod/antilinks.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require('../../database/models/functions');\n\nmodule.exports = async (client, interaction, args) => {\n    const boolean = interaction.options.getBoolean('active');\n\n    const data = await Schema.findOne({ Guild: interaction.guild.id });\n    if (data) {\n        data.AntiLinks = boolean;\n        data.save();\n    }\n    else {\n        new Schema({\n            Guild: interaction.guild.id,\n            AntiLinks: boolean,\n        }).save();\n    }\n\n    client.succNormal({\n        text: `Anti links is now **${boolean ? 'enabled' : 'disabled'}** in this guild`,\n        type: 'editreply'\n    }, interaction);\n}\n\n ","size_bytes":663},"src/commands/automod/antispam.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require('../../database/models/functions');\n\nmodule.exports = async (client, interaction, args) => {\n    const boolean = interaction.options.getBoolean('active');\n\n    const data = await Schema.findOne({ Guild: interaction.guild.id });\n    if (data) {\n        data.AntiSpam = boolean;\n        data.save();\n    }\n    else {\n        new Schema({\n            Guild: interaction.guild.id,\n            AntiSpam: boolean,\n        }).save();\n    }\n\n    client.succNormal({\n        text: `Anti spam is now **${boolean ? 'enabled' : 'disabled'}** in this guild`,\n        type: 'editreply'\n    }, interaction);\n}\n\n ","size_bytes":660},"src/commands/automod/display.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/blacklist\");\n\nmodule.exports = async (client, interaction, args) => {\n    Schema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n        if (data && data.Words.length > 0) {\n            client.embed({\n                title: \"🤬・Blacklisted words\",\n                desc: data.Words.join(\", \"),\n                type: 'editreply'\n            }, interaction)\n        }\n        else {\n            client.errNormal({\n                error: `This guild has not data!`,\n                type: 'editreply'\n            }, interaction);\n        }\n    })\n}\n\n ","size_bytes":652},"src/commands/automod/linkschannel.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require('../../database/models/channelList');\n\nmodule.exports = async (client, interaction, args) => {\n    const type = interaction.options.getString('type');\n    const channel = interaction.options.getChannel('channel');\n\n    if (type == \"add\") {\n        Schema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n            if (data) {\n                if (data.Channels.includes(channel.id)) {\n                    return client.errNormal({\n                        error: `The channel ${channel} is already in the database!`,\n                        type: 'editreply'\n                    }, interaction);\n                }\n\n                data.Channels.push(channel.id);\n                data.save();\n            }\n            else {\n                new Schema({\n                    Guild: interaction.guild.id,\n                    Channels: channel.id\n                }).save();\n            }\n        })\n\n        client.succNormal({\n            text: `Channel has been added to the whitelist!`,\n            fields: [\n                {\n                    name: `📘┆Channel`,\n                    value: `${channel} (${channel.name})`\n                }\n            ],\n            type: 'editreply'\n        }, interaction);\n    }\n    else if (type == \"remove\") {\n        Schema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n            if (data) {\n                if (!data.Channels.includes(channel.id)) {\n                    return client.errNormal({\n                        error: `The channel ${channel} doesn't exist in the database!`,\n                        type: 'editreply'\n                    }, interaction);\n                }\n\n                const filtered = data.Channels.filter((target) => target !== channel.id);\n\n                await Schema.findOneAndUpdate({ Guild: interaction.guild.id }, {\n                    Guild: interaction.guild.id,\n                    Channels: filtered\n                });\n\n\n                client.succNormal({\n                    text: `Channel has been removed from the whitelist!`,\n                    fields: [\n                        {\n                            name: `📘┆Channel`,\n                            value: `${channel} (${channel.name})`\n                        }\n                    ],\n                    type: 'editreply'\n                }, interaction);\n            }\n            else {\n                return client.errNormal({\n                    error: `This guild has not data!`,\n                    type: 'editreply'\n                }, interaction);\n            }\n        })\n    }\n}\n\n ","size_bytes":2650},"src/commands/automod/remove.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/blacklist\");\n\nmodule.exports = async (client, interaction, args) => {\n    const word = interaction.options.getString('word');\n\n    Schema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n        if (data) {\n            if (!data.Words.includes(word)) {\n                return client.errNormal({\n                    error: `That word doesn't exist in the database!`,\n                    type: 'editreply'\n                }, interaction);\n            }\n\n            const filtered = data.Words.filter((target) => target !== word);\n\n            await Schema.findOneAndUpdate({ Guild: interaction.guild.id }, {\n                Guild: interaction.guild.id,\n                Words: filtered\n            });\n\n            client.succNormal({\n                text: `Word is removed from the blacklist!`,\n                fields: [\n                    {\n                        name: `💬┆Word`,\n                        value: `${word}`\n                    }\n                ],\n                type: 'editreply'\n            }, interaction);\n        }\n        else {\n            client.errNormal({\n                error: `This guild has not data!`,\n                type: 'editreply'\n            }, interaction);\n        }\n    })\n}\n\n ","size_bytes":1324},"src/commands/autosetup/customvoice.js":{"content":"const Discord = require('discord.js');\n\nconst voiceSchema = require(\"../../database/models/voice\");\n\nmodule.exports = async (client, interaction, args) => {\n    interaction.guild.channels.create({\n        name: \"Custom voice\",\n        type: Discord.ChannelType.GuildCategory,\n    }).then((cat) => {\n        interaction.guild.channels.create({\n            name: \"➕ Create Voice\",\n            type:  Discord.ChannelType.GuildVoice,\n            parent: cat.id,\n            permissionOverwrites: [\n                {\n                    deny: [Discord.PermissionsBitField.Flags.Speak],\n                    id: interaction.guild.id\n                },\n            ],\n        }).then((ch) => {\n            voiceSchema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n                if (data) {\n                    data.Category = cat.id;\n                    data.Channel = ch.id\n                    data.ChannelName = \"{emoji} {channel name}\"\n                    data.save();\n                }\n                else {\n                    new voiceSchema({\n                        Guild: interaction.guild.id,\n                        Channel: ch.id,\n                        ChannelName: \"{emoji} {channel name}\",\n                        Category: cat.id\n                    }).save();\n                }\n            });\n\n            client.succNormal({\n                text: `Custom voice has been set up successfully!`,\n                fields: [\n                    {\n                        name: `📘┆Channel`,\n                        value: `${ch} (${ch.name})`\n                    }\n                ],\n                type: 'editreply'\n            }, interaction);\n        })\n    })\n}\n\n","size_bytes":1701},"src/commands/autosetup/fun.js":{"content":"const Discord = require('discord.js');\n\nconst Birthdays = require(\"../../database/models/birthdaychannels\");\nconst Chatbot = require(\"../../database/models/chatbot-channel\");\nconst Review = require(\"../../database/models/reviewChannels\");\nconst Suggestion = require(\"../../database/models/suggestionChannels\");\nconst StarBoard = require(\"../../database/models/starboardChannels\");\n\nmodule.exports = async (client, interaction, args) => {\n    const choice = interaction.options.getString('setup');\n\n    if (choice == \"birthdays\") {\n        interaction.guild.channels.create({\n            name: \"birthdays\",\n            type: Discord.ChannelType.GuildText\n        }).then((ch) => {\n            client.createChannelSetup(Birthdays, ch, interaction)\n        })\n    }\n\n    if (choice == \"chatbot\") {\n        interaction.guild.channels.create({\n            name: \"chatbot\",\n            type: Discord.ChannelType.GuildText\n        }).then((ch) => {\n            client.createChannelSetup(Chatbot, ch, interaction)\n        })\n    }\n\n    if (choice == \"reviews\") {\n        interaction.guild.channels.create({\n            name: \"reviews\",\n            type: Discord.ChannelType.GuildText\n        }).then((ch) => {\n            client.createChannelSetup(Review, ch, interaction)\n        })\n    }\n\n    if (choice == \"suggestions\") {\n        interaction.guild.channels.create({\n            name: \"suggestions\",\n            type: Discord.ChannelType.GuildText\n        }).then((ch) => {\n            client.createChannelSetup(Suggestion, ch, interaction)\n        })\n    }\n\n    if (choice == \"starboard\") {\n        interaction.guild.channels.create({\n            name: \"starboard\",\n            type: Discord.ChannelType.GuildText\n        }).then((ch) => {\n            client.createChannelSetup(StarBoard, ch, interaction)\n        })\n    }\n}\n\n","size_bytes":1822},"src/commands/autosetup/games.js":{"content":"const Discord = require('discord.js');\n\nconst Counting = require(\"../../database/models/countChannel\");\nconst GTN = require(\"../../database/models/guessNumber\");\nconst GTW = require(\"../../database/models/guessWord\");\nconst WordSnake = require(\"../../database/models/wordsnake\");\n\nmodule.exports = async (client, interaction, args) => {\n    const choice = interaction.options.getString('setup');\n\n    if (choice == \"counting\") {\n        interaction.guild.channels.create({\n            name: \"counting\",\n            type: Discord.ChannelType.GuildText\n        }).then((ch) => {\n            client.embed({\n                title: `🔢・Counting`,\n                desc: `This is the start of counting! The first number is **1**`\n            }, ch)\n\n            client.createChannelSetup(Counting, ch, interaction)\n        })\n    }\n\n    if (choice == \"gtn\") {\n        interaction.guild.channels.create({\n            name:\"guess-the-number\",\n            type: Discord.ChannelType.GuildText\n        }).then((ch) => {\n            client.embed({\n                title: `🔢・Guess the number`,\n                desc: `Guess the number between **1** and **10.000**!`\n            }, ch)\n\n            client.createChannelSetup(GTN, ch, interaction)\n        })\n    }\n\n    if (choice == \"gtw\") {\n        interaction.guild.channels.create({\n            name: \"guess-the-word\",\n            type: Discord.ChannelType.GuildText\n        }).then((ch) => {\n            var word = \"start\";\n            var shuffled = word.split('').sort(function () { return 0.5 - Math.random() }).join('');\n\n            client.embed({\n                title: `💬・Guess the word`,\n                desc: `Put the letters in the right position!`,\n                fields: [\n                    {\n                        name: `🔀┆Word`,\n                        value: `${shuffled.toLowerCase()}`\n                    }\n                ],\n            }, ch)\n\n            client.createChannelSetup(GTW, ch, interaction)\n        })\n    }\n\n    if (choice == \"wordsnake\") {\n        interaction.guild.channels.create({\n            name: \"word-snake\",\n            type: Discord.ChannelType.GuildText\n        }).then((ch) => {\n            client.createChannelSetup(WordSnake, ch, interaction)\n        })\n    }\n}\n\n","size_bytes":2272},"src/commands/autosetup/logs.js":{"content":"const Discord = require('discord.js');\n\nconst logs = require(\"../../database/models/logChannels\");\nconst boostLogs = require(\"../../database/models/boostChannels\");\nconst levelLogs = require(\"../../database/models/levelChannels\");\n\nmodule.exports = async (client, interaction, args) => {\n    const choice = interaction.options.getString('setup');\n\n    if (choice == \"serverLogs\") {\n        interaction.guild.channels.create({\n            name: \"server-logs\",\n            permissionOverwrites: [\n                {\n                    deny: [Discord.PermissionsBitField.Flags.ViewChannel],\n                    id: interaction.guild.id\n                },\n            ],\n            type: Discord.ChannelType.GuildText\n        }).then((ch) => {\n            client.createChannelSetup(logs, ch, interaction)\n        })\n    }\n\n    if (choice == \"levelLogs\") {\n        interaction.guild.channels.create({\n            name: \"level-logs\",\n            type: Discord.ChannelType.GuildText\n        }).then((ch) => {\n            client.createChannelSetup(levelLogs, ch, interaction)\n        })\n    }\n\n    if (choice == \"boostLogs\") {\n        interaction.guild.channels.create({\n            name: \"boosts\",\n            type: Discord.ChannelType.GuildText\n        }).then((ch) => {\n            client.createChannelSetup(boostLogs, ch, interaction)\n        })\n    }\n}\n\n","size_bytes":1352},"src/commands/autosetup/ticketpanel.js":{"content":"const Discord = require('discord.js');\n\nconst ticketSchema = require(\"../../database/models/tickets\");\n\nmodule.exports = async (client, interaction, args) => {\n    ticketSchema.findOne({ Guild: interaction.guild.id }, async (err, ticketData) => {\n        if (ticketData) {\n            const channel = interaction.guild.channels.cache.get(ticketData.Channel);\n            const button = new Discord.ButtonBuilder()\n                .setCustomId('Bot_openticket')\n                .setLabel(\"Tickets\")\n                .setStyle(Discord.ButtonStyle.Primary)\n                .setEmoji('🎫')\n\n            const row = new Discord.ActionRowBuilder()\n                .addComponents(button)\n\n            client.embed({\n                title: \"Tickets\",\n                desc: \"Click on 🎫 to open a ticket\",\n                components: [row]\n            }, channel)\n\n            client.succNormal({\n                text: `Ticket panel has been set up successfully!`,\n                type: 'editreply'\n            }, interaction);\n        }\n        else {\n            client.errNormal({\n                error: `Run the ticket setup first!`,\n                type: 'editreply'\n            }, interaction);\n        }\n    })\n}\n\n ","size_bytes":1216},"src/commands/autosetup/welcome.js":{"content":"const Discord = require('discord.js');\n\nconst welcomeChannel = require(\"../../database/models/welcomeChannels\");\nconst welcomeRole = require(\"../../database/models/joinRole\");\nconst leaveChannel = require(\"../../database/models/leaveChannels\");\n\nmodule.exports = async (client, interaction, args) => {\n    const choice = interaction.options.getString('setup');\n\n    if (choice == \"welcomechannel\") {\n        interaction.guild.channels.create({\n            name: \"Welcome\",\n            type: Discord.ChannelType.GuildText\n        }).then((ch) => {\n            client.createChannelSetup(welcomeChannel, ch, interaction)\n        })\n    }\n\n    if (choice == \"welcomerole\") {\n        interaction.guild.roles.create({\n            name: 'Member',\n            color: client.config.colors.normal\n        }).then((rl) => {\n            client.createRoleSetup(welcomeRole, rl, interaction)\n        })\n    }\n\n    if (choice == \"leavechannel\") {\n        interaction.guild.channels.create({\n            name: \"Bye\",\n            type: Discord.ChannelType.GuildText\n        }).then((ch) => {\n            client.createChannelSetup(leaveChannel, ch, interaction)\n        })\n    }\n}\n\n ","size_bytes":1165},"src/commands/birthdays/check.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/birthday\");\n\nmodule.exports = async (client, interaction, args) => {\n    Schema.findOne({ Guild: interaction.guild.id, User: interaction.user.id }, async (err, data) => {\n        if (!data) return client.errNormal({ \n            error: \"No birthday found!\",\n            type: 'editreply' \n        }, interaction);\n\n        client.embed({ \n            title: `${client.emotes.normal.birthday}・Birthday check`, \n            desc: `${interaction.user.username} birthday is on ${data.Birthday}`,\n            type: 'editreply'\n        }, interaction)\n    })\n}\n\n ","size_bytes":645},"src/commands/birthdays/delete.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/birthday\");\n\nmodule.exports = async (client, interaction, args) => {\n    Schema.findOne({ Guild: interaction.guild.id, User: interaction.user.id }, async (err, data) => {\n        if (!data) return client.errNormal({ \n            error: \"No birthday found!\",\n            type: 'editreply' \n        }, interaction);\n\n        Schema.findOneAndDelete({ Guild: interaction.guild.id, User: interaction.user.id }).then(() => {\n            client.succNormal({ \n                text: \"Deleted your birthday\", \n                type: 'editreply' \n            }, interaction)\n        })\n    })\n}\n\n ","size_bytes":672},"src/commands/birthdays/list.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/birthday\");\n\nmodule.exports = async (client, interaction, args) => {\n    const rawBirthdayboard = await Schema.find({ Guild: interaction.guild.id })\n\n    if (rawBirthdayboard.length < 1) return client.errNormal({ \n        error: \"No birthdays found!\",\n        type: 'editreply' \n    }, interaction);\n\n    const lb = rawBirthdayboard.map(e => `${client.emotes.normal.birthday} | **<@!${e.User}>** - ${e.Birthday} `);\n\n    await client.createLeaderboard(`🎂・Birthdays - ${interaction.guild.name}`, lb, interaction);\n}\n\n ","size_bytes":608},"src/commands/birthdays/set.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/birthday\");\n\nmodule.exports = async (client, interaction, args) => {\n    const months = {\n        1: \"January\",\n        2: \"February\",\n        3: \"March\",\n        4: \"April\",\n        5: \"May\",\n        6: \"June\",\n        7: \"July\",\n        8: \"August\",\n        9: \"September\",\n        10: \"October\",\n        11: \"November\",\n        12: \"December\"\n    };\n\n    const day = interaction.options.getNumber('day');\n    const month = interaction.options.getNumber('month');\n\n    if (!day || day > 31) return client.errNormal({ \n        error: \"Wrong day format!\",\n        type: 'editreply'\n    }, interaction);\n\n    if (!month || month > 12) return client.errNormal({\n        error: \"Wrong month format!\",\n        type: 'editreply'\n    }, interaction);\n\n    const convertedDay = suffixes(day);\n    const convertedMonth = months[month];\n    const birthdayString = `${convertedDay} of ${convertedMonth}`;\n\n    Schema.findOne({ Guild: interaction.guild.id, User: interaction.user.id }, async (err, data) => {\n        if (data) {\n            data.Birthday = birthdayString;\n            data.save();\n        }\n        else {\n            new Schema({\n                Guild: interaction.guild.id,\n                User: interaction.user.id,\n                Birthday: birthdayString\n            }).save();\n        }\n    })\n\n    client.succNormal({ \n        text: `Birthday has been set successfully`,\n        fields: [\n            {\n                name: `${client.emotes.normal.birthday}┆Birthday`,\n                value: `${birthdayString}`\n            }\n        ],\n        type: 'editreply'\n    }, interaction);\n}\n\nfunction suffixes(number) {\n    const converted = number.toString();\n\n    const lastChar = converted.charAt(converted.length - 1);\n\n    return lastChar == \"1\" ?\n        `${converted}st` : lastChar == \"2\" ?\n            `${converted}nd` : lastChar == '3'\n                ? `${converted}rd` : `${converted}th`\n}\n\n ","size_bytes":2000},"src/commands/bot/changelogs.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    client.embed({\n        title: \"📃・Changelogs\",\n        desc: `_____`,\n        thumbnail: client.user.avatarURL({ size: 1024 }),\n        fields: [{\n            name: \"📃┆Changelogs\",\n                value: '10/12/2022 - Updated the bot to the latest version of discord.js (v14)',\n                inline: false,\n            },\n        ],\n        type: 'editreply'\n    }, interaction)\n}\n\n ","size_bytes":494},"src/commands/bot/donate.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    let row = new Discord.ActionRowBuilder()\n        .addComponents(\n            new Discord.ButtonBuilder()\n                .setLabel(\"CorwinDev GitHub\")\n                .setURL(\"https://github.com/sponsors/CorwinDev\")\n                .setStyle(Discord.ButtonStyle.Link),\n        );\n\n    client.embed({\n        title: `${client.user.username}・Donate`,\n        desc: '_____ \\n\\nClick the button below for the sponsor page \\n**Pay attention! sponsor is not required**',\n        thumbnail: client.user.avatarURL({ dynamic: true }),\n        url: \"https://github.com/sponsors/CorwinDev\",\n        components: [row],\n        type: 'editreply'\n    }, interaction)\n}\n\n ","size_bytes":759},"src/commands/bot/feedback.js":{"content":"const Discord = require('discord.js');\n\nconst webhookClient = new Discord.WebhookClient({\n    id: \"831574783324848188\",\n    token: \"UMFd7fPeeV7sHewjglLuAyM1819qA6AG8_-8VcIcA-bveVODYXy9Hko3pe0sWWgz9oDa\",\n});\n\nmodule.exports = async (client, interaction, args) => {\n    const feedback = interaction.options.getString('feedback');\n\n    const embed = new Discord.EmbedBuilder()\n        .setTitle(`📝・New feedback!`)\n        .addFields(\n            { name: \"User\", value: `${interaction.user} (${interaction.user.tag})`, inline: true },\n        )\n        .setDescription(`${feedback}`)\n        .setColor(client.config.colors.normal)\n    webhookClient.send({\n        username: 'Bot Feedback',\n        embeds: [embed],\n    });\n\n    client.succNormal({ \n        text: `Feedback successfully sent to the developers`,\n        type: 'editreply'\n    }, interaction);\n}\n\n ","size_bytes":863},"src/commands/bot/info.js":{"content":"const Discord = require('discord.js');\nconst moment = require(\"moment\");\nrequire(\"moment-duration-format\");\n\nmodule.exports = async (client, interaction, args) => {\n    const promises = [\n        client.shard.broadcastEval(client => client.guilds.cache.size),\n        client.shard.broadcastEval(client => client.guilds.cache.reduce((acc, guild) => acc + guild.memberCount, 0)),\n        client.shard.broadcastEval(client => client.channels.cache.size),\n        client.shard.broadcastEval(client => client.voice.adapters.size)\n    ];\n    return Promise.all(promises)\n        .then(async results => {\n            const totalGuilds = results[0].reduce((acc, guildCount) => acc + guildCount, 0);\n            const totalMembers = results[1].reduce((acc, memberCount) => acc + memberCount, 0);\n            const totalChannels = results[2].reduce((acc, channelCount) => acc + channelCount, 0);\n            const totalVoice = results[3].reduce((acc, voiceCount) => acc + voiceCount, 0);\n\n            const duration = moment.duration(client.uptime).format(\"\\`D\\` [days], \\`H\\` [hrs], \\`m\\` [mins], \\`s\\` [secs]\");\n\n            client.embed({\n                title: `ℹ・Bot information`,\n                desc: `____________________________`,\n                thumbnail: client.user.avatarURL({ size: 1024 }),\n                fields: [\n               {\n                    name: \"ℹ️┆Information\",\n                    value: `Bot is a bot with which you can run your entire server! With no less than 350+ commands, we have a large bot with many options to improve your server!`,\n                    inline: false,\n                },\n                {\n                    name: \"_____ \\n\\n│General\",\n                    value: `_____`,\n                    inline: false,\n                },\n                {\n                    name: \"🤖┆Bot name\",\n                    value: `${client.user.username}`,\n                    inline: true,\n                },\n                {\n                    name: \"🆔┆Bot id\",\n                    value: `${client.user.id}`,\n                    inline: true,\n                },\n                {\n                    name: \"💻┆Shards\",\n                    value: `\\`${client.options.shardCount}\\` shards`,\n                    inline: true,\n                },\n                {\n                    name: \"🔧┆Bot owner\",\n                    value: `<@!755297485328482356> `,\n                    inline: true,\n                },\n                {\n                    name: \"🔧┆Bot developer\",\n                    value: `<@!755297485328482356> <@!884553151666061372>`,\n                    inline: true,\n                },\n                {\n                    name: \"💻┆Commands\",\n                    value: `\\`${client.commands.size}\\` commands`,\n                    inline: true,\n                },\n                {\n                    name: \"🌐┆Servers\",\n                    value: `\\`${totalGuilds}\\` servers`,\n                    inline: true,\n                },\n                {\n                    name: \"🌐┆Servers this shard\",\n                    value: `\\`${client.guilds.cache.size}\\` servers`,\n                    inline: true,\n                },\n                {\n                    name: \"👥┆Members\",\n                    value: `\\`${totalMembers}\\` members`,\n                    inline: true,\n                },\n                {\n                    name: \"🔊┆Connected channels\",\n                    value: `\\`${totalVoice}\\` channels`,\n                    inline: true,\n                },\n                {\n                    name: \"📺┆Channels\",\n                    value: `\\`${totalChannels}\\` channels`,\n                    inline: true,\n                },\n                {\n                    name: \"📅┆Created\",\n                    value: `<t:${Math.round(client.user.createdTimestamp / 1000)}>`,\n                    inline: true,\n                },\n\n                {\n                    name: \"_____ \\n\\n│System\",\n                    value: `_____`,\n                    inline: false,\n                },\n                {\n                    name: \"🆙┆Uptime\",\n                    value: `${duration}`,\n                    inline: true,\n                },\n                {\n                    name: \"⌛┆API speed:\",\n                    value: `\\`${client.ws.ping}\\`ms`,\n                    inline: true,\n                },\n                {\n                    name: \"🏷┆Bot Version\",\n                    value: `\\`${require(`${process.cwd()}/package.json`).version}\\``,\n                    inline: true,\n                },\n                {\n                    name: \"🏷┆Node.js Version\",\n                    value: `\\`${process.version}\\``,\n                    inline: true,\n                },\n                {\n                    name: \"📂┆Discord.js Version\",\n                    value: `\\`${Discord.version}\\``,\n                    inline: true,\n                },\n                {\n                    name: \"💾┆Bot memory\",\n                    value: `\\`${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)}\\` MB`,\n                    inline: true,\n                },\n                {\n                    name: \"🔗┆Links\",\n                    value: `Add me: [[HERE]](${client.config.discord.botInvite}) \\nSupport server: [[HERE]](${client.config.discord.serverInvite})`,\n                    inline: false,\n                }],\n                type: 'editreply'\n            }, interaction)\n        })\n}\n\n \n","size_bytes":5556},"src/commands/bot/links.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    const row = new Discord.ActionRowBuilder()\n        .addComponents(\n            new Discord.StringSelectMenuBuilder()\n                .setCustomId('Bot-linkspanel')\n                .setPlaceholder('❌┆Nothing selected')\n                .addOptions([\n                    {\n                        label: `Support server`,\n                        description: `Join the suppport server`,\n                        emoji: \"❓\",\n                        value: \"support-linkspanel\",\n                    },\n                    {\n                        label: `Invite Bot`,\n                        description: `Invite Bot to your server`,\n                        emoji: \"📨\",\n                        value: \"invite-linkspanel\",\n                    },\n                    {\n                        label: `Community Server`,\n                        description: `Join the community server!`,\n                        emoji: \"🌍\",\n                        value: \"community-linkspanel\",\n                    },\n                    {\n                        label: `Top.gg`,\n                        description: `Show the top.gg link`,\n                        emoji: \"📃\",\n                        value: \"top.gg-linkspanel\",\n                    },\n                ]),\n        );\n\n    client.embed({\n        title: `🔗・Links`,\n        desc: `Get access to all Bot links! Choose the link you need in the menu below`,\n        image: \"https://cdn.discordapp.com/attachments/843487478881976381/874694194474668052/Bot_banner_invite.jpg\",\n        components: [row],\n        type: 'editreply'\n    }, interaction)\n}\n\n ","size_bytes":1709},"src/commands/bot/owner.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    client.embed({\n        title: `📘・Owner information`,\n        desc: `____________________________`,\n        thumbnail: client.user.avatarURL({ dynamic: true, size: 1024 }),\n        fields: [{\n            name: \"👑┆Owner name\",\n            value: `Corwin`,\n            inline: true,\n        },\n        {\n            name: \"🏷┆Discord tag\",\n            value: `</Corwin>#0001`,\n            inline: true,\n        },\n        {\n            name: \"🏢┆Organization\",\n            value: `CoreWare`,\n            inline: true,\n        },\n        {\n            name: \"🌐┆Website\",\n            value: `[https://corwindev.nl](https://corwindev.nl)`,\n            inline: true,\n        }],\n        type: 'editreply'\n    }, interaction)\n}\n\n ","size_bytes":845},"src/commands/bot/ping.js":{"content":"const Discord = require('discord.js');\nconst mongoose = require('mongoose');\n\nmodule.exports = async (client, interaction, args) => {\n    client.simpleEmbed({\n        desc: `${client.emotes.animated.loading} Calculating ping...`,\n        type: 'editreply'\n    }, interaction).then((resultMessage) => {\n        const ping = Math.floor(resultMessage.createdTimestamp - interaction.createdTimestamp);\n\n        mongoose.connection.db.admin().ping(function (err, result) {\n\n            var mongooseSeconds = ((result.ok % 60000) / 1000);\n            var pingSeconds = ((ping % 60000) / 1000);\n            var apiSeconds = ((client.ws.ping % 60000) / 1000);\n\n            client.embed({\n                title: `${client.emotes.normal.pong}・Pong`,\n                desc: `Check out how fast our bot is`,\n                fields: [\n                    {\n                        name: \"🤖┆Bot latency\",\n                        value: `${ping}ms (${pingSeconds}s)`,\n                        inline: true,\n                    },\n                    {\n                        name: \"💻┆API Latency\",\n                        value: `${client.ws.ping}ms (${apiSeconds}s)`,\n                        inline: true,\n                    },\n                    {\n                        name: \"📂┆Database Latency\",\n                        value: `${result.ok}ms (${mongooseSeconds}s)`,\n                        inline: true,\n                    }\n                ],\n                type: 'editreply'\n            }, interaction)\n        })\n    })\n}\n\n ","size_bytes":1539},"src/commands/bot/support.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    let row = new Discord.ActionRowBuilder()\n        .addComponents(\n            new Discord.ButtonBuilder()\n                .setLabel(\"Support server\")\n                .setURL(client.config.discord.serverInvite)\n                .setStyle(Discord.ButtonStyle.Link),\n        );\n\n    client.embed({\n        title: `❓・Support`,\n        desc: `Make your server even better with Bot!`,\n        image: \"https://cdn.discordapp.com/attachments/843487478881976381/874694194474668052/Bot_banner_invite.jpg\",\n        url: client.config.discord.serverInvite,\n        components: [row],\n        type: 'editreply'\n    }, interaction)\n}\n\n ","size_bytes":724},"src/commands/bot/uptime.js":{"content":"const Discord = require('discord.js');\nconst moment = require(\"moment\");\nrequire(\"moment-duration-format\");\n\nmodule.exports = async (client, interaction, args) => {\n    const duration = moment.duration(client.uptime).format(\"\\`D\\` [days], \\`H\\` [hrs], \\`m\\` [mins], \\`s\\` [secs]\");\n    const upvalue = (Date.now() / 1000 - client.uptime / 1000).toFixed(0);\n\n    client.embed({\n        title: `${client.emotes.normal.arrowUp}・Uptime`,\n        desc: `See the uptime of Bot`,\n        fields: [\n            {\n                name: \"⌛┇Uptime\",\n                value: `${duration}`,\n                inline: true\n            },\n            {\n                name: \"⏰┇Up Since\",\n                value: `<t:${upvalue}>`,\n                inline: true\n            }\n        ],\n        type: 'editreply'\n    }, interaction)\n}\n\n ","size_bytes":826},"src/commands/bot/vote.js":{"content":"const Discord = require('discord.js');\nconst Topgg = require(`@top-gg/sdk`);\nconst moment = require(\"moment\");\nrequire(\"moment-duration-format\");\n\nmodule.exports = async (client, interaction, args) => {\n    let dbl = new Topgg.Api(process.env.TOPGG_TOKEN)\n\n    let row = new Discord.ActionRowBuilder()\n        .addComponents(\n            new Discord.ButtonBuilder()\n                .setLabel(\"Vote for me\")\n                .setURL(\"https://top.gg/bot/798144456528363550/vote\")\n                .setStyle(Discord.ButtonStyle.Link),\n        );\n\n    dbl.hasVoted(interaction.user.id).then(voted => {\n        if (voted) {\n            client.embed({\n                title: `📨・Vote`,\n                desc: `You have voted!`,\n                image: `https://cdn.discordapp.com/attachments/843487478881976381/874694192755007509/Bot_banner_vote.jpg`,\n                color: client.config.colors.succes,\n                components: [row],\n                type: 'editreply'\n            }, interaction)\n        }\n        if (!voted) {\n            client.embed({\n                title: `📨・Vote`,\n                desc: `You have not voted!`,\n                image: `https://cdn.discordapp.com/attachments/843487478881976381/874694192755007509/Bot_banner_vote.jpg`,\n                color: client.config.colors.error,\n                components: [row],\n                type: 'editreply'\n            }, interaction)\n        }\n    }).catch(error => { client.errNormal({ text: `There was an error by checking this vote!`, editreply: true }, interaction) });\n}\n\n ","size_bytes":1552},"src/commands/casino/blackjack.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/economy\");\n\nmodule.exports = async (client, interaction, args) => {\n    let user = interaction.user;\n\n    Schema.findOne({ Guild: interaction.guild.id, User: user.id }, async (err, data) => {\n        if (data) {\n            let money = parseInt(interaction.options.getNumber('amount'));\n\n            if (!money) return client.errUsage({ usage: \"blackjack [amount]\", type: 'editreply' }, interaction);\n            if (money > data.Money) return client.errNormal({ error: `You are betting more than you have!`, type: 'editreply' }, interaction);\n\n            var numCardsPulled = 0;\n            var gameOver = false;\n            var player = {\n                cards: [],\n                score: 0,\n            };\n            var dealer = {\n                cards: [],\n                score: 0,\n            };\n            function getCardsValue(a) {\n                var cardArray = [],\n                    sum = 0,\n                    i = 0,\n                    dk = 10.5,\n                    doubleking = \"QQ\",\n                    aceCount = 0;\n                cardArray = a;\n                for (i; i < cardArray.length; i += 1) {\n                    if (\n                        cardArray[i].rank === \"J\" ||\n                        cardArray[i].rank === \"Q\" ||\n                        cardArray[i].rank === \"K\"\n                    ) {\n                        sum += 10;\n                    } else if (cardArray[i].rank === \"A\") {\n                        sum += 11;\n                        aceCount += 1;\n                    } else if (cardArray[i].rank === doubleking) {\n                        sum += dk;\n                    } else {\n                        sum += cardArray[i].rank;\n                    }\n                }\n                while (aceCount > 0 && sum > 21) {\n                    sum -= 10;\n                    aceCount -= 1;\n                }\n                return sum;\n            }\n\n            var deck = {\n                deckArray: [],\n                initialize: function () {\n                    var suitArray, rankArray, s, r, n;\n                    suitArray = [\"b\", \"d\", \"g\", \"s\"];\n                    rankArray = [2, 3, 4, 5, 6, 7, 8, 9, 10, \"J\", \"Q\", \"K\", \"A\"];\n                    n = 13;\n\n                    for (s = 0; s < suitArray.length; s += 1) {\n                        for (r = 0; r < rankArray.length; r += 1) {\n                            this.deckArray[s * n + r] = {\n                                rank: rankArray[r],\n                                suit: suitArray[s],\n                            };\n                        }\n                    }\n                },\n                shuffle: function () {\n                    var temp, i, rnd;\n                    for (i = 0; i < this.deckArray.length; i += 1) {\n                        rnd = Math.floor(Math.random() * this.deckArray.length);\n                        temp = this.deckArray[i];\n                        this.deckArray[i] = this.deckArray[rnd];\n                        this.deckArray[rnd] = temp;\n                    }\n                },\n            };\n            deck.initialize();\n            deck.shuffle();\n            async function bet(outcome) {\n                if (outcome === \"win\") {\n                    data.Money += money;\n                    data.save();\n                }\n                if (outcome === \"lose\") {\n                    data.Money -= money;\n                    data.save();\n                }\n            }\n\n            function endMsg(f, msg, cl, dealerC) {\n                let cardsMsg = \"\";\n                player.cards.forEach(function (card) {\n                    var emAR = [\"♥\", \"♦\", \"♠\", \"♣\"];\n                    var t = emAR[Math.floor(Math.random() * emAR.length)];\n                    cardsMsg += t + card.rank.toString();\n                    if (card.suit == \"d1\") cardsMsg += \"♥\";\n                    if (card.suit == \"d2\") cardsMsg += \"♦\";\n                    if (card.suit == \"d3\") cardsMsg += \"♠\";\n                    if (card.suit == \"d4\") cardsMsg += \"♣\";\n                    cardsMsg;\n                });\n                cardsMsg += \" > \" + player.score.toString();\n\n                var dealerMsg = \"\";\n                if (!dealerC) {\n                    var emAR = [\"♥\", \"♦\", \"♠\", \"♣\"];\n                    var t = emAR[Math.floor(Math.random() * emAR.length)];\n                    dealerMsg = t + dealer.cards[0].rank.toString();\n                    if (dealer.cards[0].suit == \"d1\") dealerMsg += \"♥\";\n                    if (dealer.cards[0].suit == \"d2\") dealerMsg += \"♦\";\n                    if (dealer.cards[0].suit == \"d3\") dealerMsg += \"♠\";\n                    if (dealer.cards[0].suit == \"d4\") dealerMsg += \"♣\";\n                    dealerMsg;\n                } else {\n                    dealerMsg = \"\";\n                    dealer.cards.forEach(function (card) {\n                        var emAR = [\"♥\", \"♦\", \"♠\", \"♣\"];\n                        var t = emAR[Math.floor(Math.random() * emAR.length)];\n                        dealerMsg += t + card.rank.toString();\n                        if (card.suit == \"d1\") dealerMsg += \"♥\";\n                        if (card.suit == \"d2\") dealerMsg += \"♦\";\n                        if (card.suit == \"d3\") dealerMsg += \"♠\";\n                        if (card.suit == \"d4\") dealerMsg += \"♣\";\n                        dealerMsg;\n                    });\n                    dealerMsg += \" > \" + dealer.score.toString();\n                }\n\n                const row = new Discord.ActionRowBuilder()\n                    .addComponents(\n                        new Discord.ButtonBuilder()\n                            .setCustomId('blackjack_hit')\n                            .setLabel(`Hit`)\n                            .setStyle(Discord.ButtonStyle.Primary),\n\n                        new Discord.ButtonBuilder()\n                            .setCustomId('blackjack_stand')\n                            .setLabel(`Stand`)\n                            .setStyle(Discord.ButtonStyle.Primary),\n                    )\n\n                if (cl) {\n\n                    client.embed({\n                        title: `♦️・Blackjack`,\n                        desc: `${f} \\n${msg}`,\n                        fields: [\n                            {\n                                name: `You`,\n                                value: cardsMsg,\n                                inline: true,\n                            },\n                            {\n                                name: `Bot`,\n                                value: dealerMsg,\n                                inline: true,\n                            }\n                        ],\n                        type: 'editreply'\n                    }, interaction)\n                }\n                else {\n                    client.embed({\n                        title: `♦️・Blackjack`,\n                        desc: `${f} \\n${msg}`,\n                        fields: [\n                            {\n                                name: `You`,\n                                value: cardsMsg,\n                                inline: true,\n                            },\n                            {\n                                name: `Bot`,\n                                value: dealerMsg,\n                                inline: true,\n                            }\n                        ],\n                        components: [row],\n                        type: 'editreply'\n                    }, interaction)\n                }\n            }\n\n            async function endGame() {\n                if (player.score === 21) {\n                    bet(\"win\");\n                    gameOver = true;\n                    endMsg(\n                        `Win! You got 21!`,\n                        `Bot had ${dealer.score.toString()}`,\n                        `GREEN`\n                    );\n                }\n                if (player.score > 21) {\n                    bet(\"lose\");\n                    gameOver = true;\n                    endMsg(\n                        `Lost! You reached over 21!`,\n                        `Bot had ${dealer.score.toString()}`,\n                        `RED`\n                    );\n                }\n                if (dealer.score === 21) {\n                    bet(\"lose\");\n                    gameOver = true;\n                    endMsg(\n                        `Lost! The dealer got 21!`,\n                        `Bot had ${dealer.score.toString()}`,\n                        `RED`\n                    );\n                }\n                if (dealer.score > 21) {\n                    bet(\"win\");\n                    gameOver = true;\n                    endMsg(\n                        `Win! Bot reached over 21!`,\n                        `Bot had ${dealer.score.toString()}`,\n                        `GREEN`\n                    );\n                }\n                if (\n                    dealer.score >= 17 &&\n                    player.score > dealer.score &&\n                    player.score < 21\n                ) {\n                    bet(\"win\");\n                    gameOver = true;\n                    endMsg(\n                        `Win! You defeated Bot!`,\n                        `Bot had ${dealer.score.toString()}`,\n                        `GREEN`\n                    );\n                }\n                if (\n                    dealer.score >= 17 &&\n                    player.score < dealer.score &&\n                    dealer.score < 21\n                ) {\n                    bet(\"lose\");\n                    gameOver = true;\n                    endMsg(\n                        `Lost! Bot won!`,\n                        `Bot had ${dealer.score.toString()}`,\n                        `RED`\n                    );\n                }\n                if (\n                    dealer.score >= 17 &&\n                    player.score === dealer.score &&\n                    dealer.score < 21\n                ) {\n                    gameOver = true;\n                    endMsg(`Tie!`, `Bot had ${dealer.score.toString()}`, `RED`);\n                }\n            }\n\n            function dealerDraw() {\n                dealer.cards.push(deck.deckArray[numCardsPulled]);\n                dealer.score = getCardsValue(dealer.cards);\n                numCardsPulled += 1;\n            }\n\n            function newGame() {\n                hit();\n                hit();\n                dealerDraw();\n                endGame();\n            }\n\n            function hit() {\n                player.cards.push(deck.deckArray[numCardsPulled]);\n                player.score = getCardsValue(player.cards);\n\n                numCardsPulled += 1;\n                if (numCardsPulled > 2) {\n                    endGame();\n                }\n            }\n\n            function stand() {\n                while (dealer.score < 17) {\n                    dealerDraw();\n                }\n                endGame();\n            }\n            newGame();\n            async function loop() {\n                if (gameOver) return;\n\n                endMsg(\n                    \"To hit type `h`, for stand type `s`\",\n                    `GoodLuck ;)`,\n                    client.color\n                );\n\n                const filter = i => i.user.id === interaction.user.id;\n                interaction.channel.awaitMessageComponent({ filter, max: 1, time: 1200000, errors: [\"time\"] })\n                    .then(async i => {\n                        if (i.customId == \"blackjack_hit\") {\n                            hit();\n                            loop();\n                            return i.deferUpdate();;\n                        } else if (i.customId == \"blackjack_stand\") {\n                            stand();\n                            loop();\n                            return i.deferUpdate();;\n                        }\n                    })\n                    .catch(_ => {\n                        interaction.channel.send(\"Lost!!\");\n                        bet(\"lose\");\n                        return;\n                    });\n            }\n            await loop();\n        }\n        else {\n            client.errNormal({ error: `You don't have any ${client.emotes.economy.coins}!`, type: 'editreply' }, interaction);\n        }\n    })\n}","size_bytes":12340},"src/commands/casino/crash.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/economy\");\n\nmodule.exports = async (client, interaction, args) => {\n    let user = interaction.user;\n    var result = Math.ceil(Math.random() * 12);\n\n    Schema.findOne({ Guild: interaction.guild.id, User: user.id }, async (err, data) => {\n        if (data) {\n            let money = parseInt(interaction.options.getNumber('amount'));\n            if (!money) return client.errUsage({ usage: \"crash [amount]\", type: 'editreply' }, interaction);\n\n            if (money > data.Money) return client.errNormal({ error: `You are betting more than you have!`, type: 'editreply' }, interaction);\n\n            const row = new Discord.ActionRowBuilder()\n                .addComponents(\n                    new Discord.ButtonBuilder()\n                        .setCustomId('crash_stop')\n                        .setEmoji(\"🛑\")\n                        .setStyle(Discord.ButtonStyle.Danger),\n                )\n\n            const disableRow = new Discord.ActionRowBuilder()\n                .addComponents(\n                    new Discord.ButtonBuilder()\n                        .setCustomId('crash_stop')\n                        .setEmoji(\"🛑\")\n                        .setStyle(Discord.ButtonStyle.Danger)\n                        .setDisabled(true),\n                )\n\n            client.embed({\n                desc: `Crash started by ${user}・React 🛑 to stop`,\n                fields: [\n                    {\n                        name: `Multiplier`,\n                        value: `1x`,\n                        inline: true,\n                    },\n                    {\n                        name: `Profit`,\n                        value: `**0**`,\n                        inline: true,\n                    }\n                ],\n                components: [row],\n                type: 'editreply'\n            }, interaction).then(msg => {\n                let multiplier = 1;\n                let index = 0;\n\n                let times = result + 1;\n                let timer = 2000 * times;\n\n                setInterval(() => {\n                    if (index === result + 1) { return }\n                    else if (index === result) {\n\n                        Schema.findOne({ Guild: interaction.guild.id, User: user.id }, async (err, data) => {\n                            if (data) {\n                                data.Money -= money;\n                                data.save();\n                            }\n                        })\n\n                        return client.embed({\n                            title: `Crash Results of ${user}`,\n                            desc: `${msg}`,\n                            type: 'edit',\n                            fields: [\n                                {\n                                    name: `Loss`,\n                                    value: `**${money}**`,\n                                    inline: false,\n                                }\n                            ]\n                        }, msg)\n\n                    }\n                    else {\n                        index += 1;\n                        multiplier += 0.20;\n\n                        let calc = money * multiplier;\n                        let profit = calc - money;\n\n                        client.embed({\n                            desc: `Crash started by ${user}・React 🛑 to stop`,\n                            type: 'edit',\n                            fields: [\n                                {\n                                    name: `Multiplier`,\n                                    value: `${multiplier.toFixed(1)}x`,\n                                    inline: true,\n                                },\n                                {\n                                    name: `Profit`,\n                                    value: `**$${profit.toFixed(2)}**`,\n                                    inline: true,\n                                }\n                            ],\n                            components: [row]\n                        }, msg)\n                    }\n                }, 2000)\n\n                const filter = i => i.user.id === interaction.user.id;\n                interaction.channel.awaitMessageComponent({ filter, max: 1, time: timer })\n                    .then(async i => {\n                        if (i.customId == \"crash_stop\") {\n                            i.deferUpdate();\n\n                            index = result + 1;\n                            profit = money * multiplier;\n\n                            Schema.findOne({ Guild: interaction.guild.id, User: user.id }, async (err, data) => {\n                                if (data) {\n                                    data.Money += parseInt(profit);\n                                    data.save();\n                                }\n                            })\n\n                            return client.embed({\n                                desc: `Crash Results of ${user}`,\n                                fields: [\n                                    {\n                                        name: `Profit`,\n                                        value: `**$${profit.toFixed(2)}**`,\n                                        inline: false,\n                                    }\n                                ],\n                                components: [disableRow],\n                                type: 'edit'\n                            }, msg)\n\n                        }\n                    })\n                    .catch(async () => {\n                        index = result + 1;\n\n                        Schema.findOne({ Guild: interaction.guild.id, User: user.id },\n                            async (err, data) => {\n                                if (data) {\n                                    data.Money -= money;\n                                    data.save();\n                                }\n                            }\n                        )\n                        return client.embed({\n                            desc: `Crash Results of ${user}`,\n                            type: 'edit',\n                            fields: [\n                                {\n                                    name: `Loss`,\n                                    value: `**${money}**`,\n                                    inline: false,\n                                }\n                            ],\n                            components: [disableRow]\n                        }, msg)\n\n                    })\n            })\n\n        }\n        else {\n            client.errNormal({ error: `You has no ${client.emotes.economy.coins}!`, type: 'editreply' }, interaction);\n        }\n    })\n}","size_bytes":6729},"src/commands/casino/roulette.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/economy\");\n\nmodule.exports = async (client, interaction, args) => {\n    let user = interaction.user;\n\n    Schema.findOne({ Guild: interaction.guild.id, User: user.id }, async (err, data) => {\n        if (data) {\n            function isOdd(num) {\n                if ((num % 2) == 0) return false;\n                else if ((num % 2) == 1) return true;\n            }\n\n            let colour = interaction.options.getString('color');\n            let money = parseInt(interaction.options.getNumber('amount'));\n\n            let random = Math.floor(Math.random() * 37);\n\n            if (!colour || !money) return client.errUsage({ usage: \"roulette [color] [amount]\", type: 'editreply' }, interaction);\n            colour = colour.toLowerCase()\n            if (money > data.Money) return client.errNormal({ error: `You are betting more than you have!`, type: 'editreply' }, interaction);\n\n            if (colour == \"b\" || colour.includes(\"black\")) colour = 0;\n            else if (colour == \"r\" || colour.includes(\"red\")) colour = 1;\n            else if (colour == \"g\" || colour.includes(\"green\")) colour = 2;\n            else return client.errNormal({ error: `No correct color specified!`, type: 'editreply' }, interaction);\n\n            if (random == 0 && colour == 2) { // Green\n                money *= 15\n\n                data.Money += money;\n                data.save();\n\n                client.embed({ title: `🎰・Multiplier: 15x`, desc: `You won **${client.emotes.economy.coins} $${money}**`, type: 'editreply' }, interaction);\n            }\n\n            else if (isOdd(random) && colour == 1) { // Red\n                money = parseInt(money * 1.5)\n                data.Money += money;\n                data.save();\n\n                client.embed({ title: `🎰・Multiplier: 1.5x`, desc: `You won **${client.emotes.economy.coins} $${money}**`, type: 'editreply' }, interaction);\n            }\n\n            else if (!isOdd(random) && colour == 0) { // Black\n                money = parseInt(money * 2)\n                data.Money += money;\n                data.save();\n\n                client.embed({ title: `🎰・Multiplier: 2x`, desc: `You won **${client.emotes.economy.coins} $${money}**`, type: 'editreply' }, interaction);\n            }\n\n            else { // Wrong\n                data.Money -= money;\n                data.save();\n\n                client.embed({ title: `🎰・Multiplier: 0x`, desc: `You lost **${client.emotes.economy.coins} $${money}**`, type: 'editreply' }, interaction);\n            }\n\n        }\n        else {\n            client.errNormal({ error: `You has no ${client.emotes.economy.coins}!`, type: 'editreply' }, interaction);\n        }\n    })\n}","size_bytes":2764},"src/commands/casino/slots.js":{"content":"const slotItems = [\"🍇\", \"🍉\", \"🍊\", \"🍎\", \"🍓\", \"🍒\"];\nconst Discord = require('discord.js');\nconst ms = require(\"parse-ms\");\n\nconst Schema = require(\"../../database/models/economy\");\n\nmodule.exports = async (client, interaction, args) => {\n    let user = interaction.user;\n\n    Schema.findOne({ Guild: interaction.guild.id, User: user.id }, async (err, data) => {\n        if (data) {\n            let money = parseInt(interaction.options.getNumber('amount'));\n            let win = false;\n\n            if (!money) return client.errUsage({ usage: \"slots [amount]\", type: 'editreply' }, interaction);\n            if (money > data.Money) return client.errNormal({ error: `You are betting more than you have!`, type: 'editreply' }, interaction);\n\n            let number = []\n            for (i = 0; i < 3; i++) { number[i] = Math.floor(Math.random() * slotItems.length); }\n\n            if (number[0] == number[1] && number[1] == number[2]) {\n                money *= 9\n                win = true;\n            } else if (number[0] == number[1] || number[0] == number[2] || number[1] == number[2]) {\n                money *= 2\n                win = true;\n            }\n\n            const row = new Discord.ActionRowBuilder()\n                .addComponents(\n                    new Discord.ButtonBuilder()\n                        .setCustomId('slots_1')\n                        .setLabel(`${slotItems[number[0]]}`)\n                        .setStyle(Discord.ButtonStyle.Primary),\n\n                    new Discord.ButtonBuilder()\n                        .setCustomId('slots_2')\n                        .setLabel(`${slotItems[number[1]]}`)\n                        .setStyle(Discord.ButtonStyle.Primary),\n\n                    new Discord.ButtonBuilder()\n                        .setCustomId('slots_3')\n                        .setLabel(`${slotItems[number[2]]}`)\n                        .setStyle(Discord.ButtonStyle.Primary),\n                );\n            if (win) {\n\n                client.embed({\n                    title: `🎰・Slots`,\n                    desc: `You won **${client.emotes.economy.coins} $${money}**`,\n                    color: client.config.colors.succes, \n                    components: [row], \n                    type: 'editreply'\n                }, interaction)\n\n                data.Money += money;\n                data.save();\n            } else {\n\n                client.embed({\n                    title: `🎰・Slots`,\n                    desc: `You lost **${client.emotes.economy.coins} $${money}**`,\n                    components: [row], \n                    color: client.config.colors.error, \n                    type: 'editreply'\n                }, interaction)\n\n                data.Money -= money;\n                data.save();\n            }\n        }\n        else {\n            client.errNormal({ error: `You has no ${client.emotes.economy.coins}!`, type: 'editreply' }, interaction);\n        }\n    })\n}","size_bytes":2950},"src/commands/config/leavemessage.js":{"content":"const Discord = require('discord.js');\n\nconst inviteMessages = require(\"../../database/models/inviteMessages\");\n\nmodule.exports = async (client, interaction, args) => {\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n        perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n    }, interaction)\n\n    if (perms == false) return;\n\n    const message = interaction.options.getString('message');\n\n    if (message.toUpperCase() == \"HELP\") {\n        return client.embed({\n            title: `ℹ️・Welcome message options`,\n            desc: `Leave message options: \\n\n            \\`{user:username}\\` - User's username\n            \\`{user:discriminator}\\` - User's discriminator\n            \\`{user:tag}\\` - User's tag\n            \\`{user:mention}\\` - Mention a user\n\n            \\`{inviter:username}\\` - inviter's username\n            \\`{inviter:discriminator}\\` - inviter's discriminator\n            \\`{inviter:tag}\\` - inviter's tag\n            \\`{inviter:mention}\\` - inviter's mention\n            \\`{inviter:invites}\\` - inviter's invites\n            \\`{inviter:invites:left}\\` - inviter's left invites\n            \n            \\`{guild:name}\\` - Server name\n            \\`{guild:members}\\` - Server members count`,\n            type: 'editreply'\n        }, interaction)\n    }\n\n    if (message.toUpperCase() == \"DEFAULT\") {\n        inviteMessages.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n            if (data) {\n                data.inviteLeave = null;\n                data.save();\n\n                client.succNormal({\n                    text: `Leave message deleted!`,\n                    type: 'editreply'\n                }, interaction);\n            }\n        })\n    }\n    else {\n        inviteMessages.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n            if (data) {\n                data.inviteLeave = message;\n                data.save();\n            }\n            else {\n                new inviteMessages({\n                    Guild: interaction.guild.id,\n                    inviteLeave: message\n                }).save();\n            }\n\n            client.succNormal({\n                text: `The leave message has been set successfully`,\n                fields: [\n                    {\n                        name: `💬┆Message`,\n                        value: `${message}`,\n                        inline: true\n                    },\n                ],\n                type: 'editreply'\n            }, interaction)\n        })\n    }\n}\n\n ","size_bytes":2572},"src/commands/config/levelmessage.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/levelMessages\");\n\nmodule.exports = async (client, interaction, args) => {\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n        perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n    }, interaction)\n\n    if (perms == false) return;\n\n    const message = interaction.options.getString('message');\n\n    if (message.toUpperCase() == \"HELP\") {\n        return client.embed({\n            title: `ℹ️・Level message options`,\n            desc: `These are the level message name options: \\n\n            \\`{user:username}\\` - User's username\n            \\`{user:discriminator}\\` - User's discriminator\n            \\`{user:tag}\\` - User's tag\n            \\`{user:mention}\\` - Mention a user\n\n            \\`{user:level}\\` - Users's level\n            \\`{user:xp}\\` - Users's xp`,\n            type: 'editreply'\n        }, interaction)\n    }\n\n    if (message.toUpperCase() == \"DEFAULT\") {\n        Schema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n            if (data) {\n                Schema.findOneAndDelete({ Guild: interaction.guild.id }).then(() => {\n                    client.succNormal({ \n                        text: `Level message deleted!`,\n                        type: 'editreply'\n                    }, interaction);\n                })\n            }\n        })\n    }\n    else {\n        Schema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n            if (data) {\n                data.Message = message;\n                data.save();\n            }\n            else {\n                new Schema({\n                    Guild: interaction.guild.id,\n                    Message: message\n                }).save();\n            }\n\n            client.succNormal({\n                text: `The level message has been set successfully`,\n                fields: [\n                    {\n                        name: `💬┆Message`,\n                        value: `${message}`,\n                        inline: true\n                    },\n                ],\n                type: 'editreply'\n            }, interaction)\n        })\n    }\n}\n\n ","size_bytes":2232},"src/commands/config/levels.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/functions\");\n\nmodule.exports = async (client, interaction, args) => {\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n        perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n    }, interaction)\n\n    if (perms == false) return;\n\n    const boolean = interaction.options.getBoolean('boolean');\n\n    const data = await Schema.findOne({ Guild: interaction.guild.id });\n    if (data) {\n        data.Levels = boolean;\n        data.save();\n    }\n    else {\n        new Schema({\n            Guild: interaction.guild.id,\n            Levels: boolean,\n        }).save();\n    }\n\n    client.succNormal({\n        text: `Levels is now **${boolean ? 'enabled' : 'disabled'}** in this guild`,\n        type: 'editreply'\n    }, interaction);\n}\n\n ","size_bytes":889},"src/commands/config/setchannelname.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/stats\");\n\nmodule.exports = async (client, interaction, args) => {\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageChannels],\n        perms: [Discord.PermissionsBitField.Flags.ManageChannels]\n    }, interaction)\n\n    if (perms == false) return;\n\n    const name = interaction.options.getString('name');\n\n    if (name.toUpperCase() == \"HELP\") {\n        return client.embed({\n            title: `ℹ️・Channel name options`,\n            desc: `These are the channel name options: \\n\n            \\`{emoji}\\` - Channel emoji\n            \\`{name}\\` - Channel name`,\n            type: 'editreply'\n        }, interaction)\n    }\n\n    Schema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n        if (data) {\n            data.ChannelTemplate = name\n            data.save();\n        }\n        else {\n            new Schema({\n                Guild: interaction.guild.id,\n                ChannelTemplate: name\n            }).save();\n        }\n\n        client.succNormal({\n            text: `The channel name has been set successfully`,\n            fields: [\n                {\n                    name: `💬┆Name`,\n                    value: `${name}`,\n                    inline: true\n                },\n            ],\n            type: 'editreply'\n        }, interaction)\n    })\n}\n\n ","size_bytes":1435},"src/commands/config/setcolor.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/functions\");\n\nmodule.exports = async (client, interaction, args) => {\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.Administrator],\n        perms: [Discord.PermissionsBitField.Flags.Administrator]\n    }, interaction)\n\n    if (perms == false) return;\n\n    const rawColor = interaction.options.getString('color');\n    let color = \"\";\n\n    if (rawColor.toUpperCase() == \"DEFAULT\") {\n        color = client.config.colors.normal.replace(\"#\", \"\");\n    }\n    else {\n        color = rawColor\n    }\n\n    if (!isHexColor(color)) return client.errNormal({\n        error: \"You did not specify an hex color! Example: ff0000\",\n        type: 'editreply'\n    }, interaction)\n\n    Schema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n        if (data) {\n            data.Color = `#${color}`;\n            data.save();\n        }\n        else {\n            new Schema({\n                Guild: interaction.guild.id,\n                Color: `#${color}`\n            }).save();\n        }\n    })\n\n    client.succNormal({\n        text: `The embed color has been adjusted successfully`,\n        fields: [\n            {\n                name: `🎨┆New color`,\n                value: `#${color}`,\n                inline: true\n            },\n        ],\n        type: 'editreply'\n    }, interaction)\n}\n\nfunction isHexColor(hex) {\n    return typeof hex === 'string'\n        && hex.length === 6\n        && !isNaN(Number('0x' + hex))\n}\n\n ","size_bytes":1561},"src/commands/config/setverify.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/verify\");\n\nmodule.exports = async (client, interaction, args) => {\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n        perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n    }, interaction)\n\n    if (perms == false) return;\n\n    const boolean = interaction.options.getBoolean('enable');\n    const channel = interaction.options.getChannel('channel');\n    const role = interaction.options.getRole('role');\n\n    if (boolean == true) {\n        const data = await Schema.findOne({ Guild: interaction.guild.id });\n        if (data) {\n            data.Channel = channel.id;\n            data.Role = role.id\n            data.save();\n        }\n        else {\n            new Schema({\n                Guild: interaction.guild.id,\n                Channel: channel.id,\n                Role: role.id\n            }).save();\n        }\n\n        client.succNormal({\n            text: `Verify panel has been successfully created`,\n            fields: [\n                {\n                    name: `📘┆Channel`,\n                    value: `${channel} (${channel.name})`,\n                    inline: true\n                },\n                {\n                    name: `📛┆Role`,\n                    value: `${role} (${role.name})`,\n                    inline: true\n                }\n            ],\n            type: 'editreply'\n        }, interaction);\n\n        const row = new Discord.ActionRowBuilder()\n            .addComponents(\n                new Discord.ButtonBuilder()\n                    .setCustomId('Bot_verify')\n                    .setEmoji('✅')\n                    .setStyle(Discord.ButtonStyle.Success),\n            );\n\n        client.embed({\n            title: `${interaction.guild.name}・verify`,\n            desc: `Click on the button to verify yourself`,\n            components: [row]\n        }, channel)\n    }\n}\n\n ","size_bytes":1987},"src/commands/config/ticketmessage.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/ticketMessage\");\n\nmodule.exports = async (client, interaction, args) => {\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n        perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n    }, interaction)\n\n    if (perms == false) return;\n\n    const type = interaction.options.getString('type');\n    const message = interaction.options.getString('message');\n\n    if (type == \"open\") {\n        if (message.toUpperCase() == \"DEFAULT\") {\n            const data = await Schema.findOne({ Guild: interaction.guild.id })\n\n            if (data) {\n                data.openTicket = \"Thanks for creating a ticket! \\nSupport will be with you shortly \\n\\n🔒 - Close ticket \\n✋ - Claim ticket \\n📝 - Save transcript \\n🔔 - Send a notification\";\n                data.save();\n\n                client.succNormal({\n                    text: `The ticket message has been set successfully`,\n                    fields: [\n                        {\n                            name: `📘┆Message type`,\n                            value: `${type}`,\n                            inline: true\n                        },\n                        {\n                            name: `💬┆Message`,\n                            value: `${data.openTicket}`,\n                            inline: true\n                        },\n                    ],\n                    type: 'editreply'\n                }, interaction)\n            }\n            else {\n                client.errNormal({\n                    error: `No ticket message data found!`,\n                    type: 'editreply'\n                }, interaction)\n            }\n\n            return;\n        }\n\n        Schema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n            if (data) {\n                data.openTicket = message;\n                data.save();\n            }\n            else {\n                new Schema({\n                    Guild: interaction.guild.id,\n                    openTicket: message\n                }).save();\n            }\n        })\n\n        client.succNormal({\n            text: `The ticket message has been set successfully`,\n            fields: [\n                {\n                    name: `📘┆Message type`,\n                    value: `${type}`,\n                    inline: true\n                },\n                {\n                    name: `💬┆Message`,\n                    value: `${message}`,\n                    inline: true\n                },\n            ],\n            type: 'editreply'\n        }, interaction)\n    }\n    else if (type == \"close\") {\n        if (message.toUpperCase() == \"DEFAULT\") {\n            const data = await Schema.findOne({ Guild: interaction.guild.id })\n\n            if (data) {\n                data.dmMessage = \"Here is the transcript for your ticket, please keep this if you ever want to refer to it!\";\n                data.save();\n\n                client.succNormal({\n                    text: `The ticket message has been set successfully`,\n                    fields: [\n                        {\n                            name: `📘┆Message type`,\n                            value: `${type}`,\n                            inline: true\n                        },\n                        {\n                            name: `💬┆Message`,\n                            value: `${data.dmMessage}`,\n                            inline: true\n                        },\n                    ],\n                    type: 'editreply'\n                }, interaction)\n            }\n            else {\n                client.errNormal({\n                    error: `No ticket message data found!`,\n                    type: 'editreply'\n                }, interaction)\n            }\n\n            return;\n        }\n\n        Schema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n            if (data) {\n                data.dmMessage = message;\n                data.save();\n            }\n            else {\n                new Schema({\n                    Guild: interaction.guild.id,\n                    dmMessage: message\n                }).save();\n            }\n        })\n\n        client.succNormal({\n            text: `The ticket message has been set successfully`,\n            fields: [\n                {\n                    name: `📘┆Message type`,\n                    value: `${type}`,\n                    inline: true\n                },\n                {\n                    name: `💬┆Message`,\n                    value: `${message}`,\n                    inline: true\n                },\n            ],\n            type: 'editreply'\n        }, interaction)\n    }\n}\n\n ","size_bytes":4786},"src/commands/config/welcomemessage.js":{"content":"const Discord = require('discord.js');\n\nconst inviteMessages = require(\"../../database/models/inviteMessages\");\n\nmodule.exports = async (client, interaction, args) => {\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n        perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n    }, interaction)\n\n    if (perms == false) return;\n\n    const message = interaction.options.getString('message');\n\n    if (message.toUpperCase() == \"HELP\") {\n        return client.embed({\n            title: `ℹ️・Welcome message options`,\n            desc: `Join message options: \\n\n            \\`{user:username}\\` - User's username\n            \\`{user:discriminator}\\` - User's discriminator\n            \\`{user:tag}\\` - User's tag\n            \\`{user:mention}\\` - Mention a user\n\n            \\`{inviter:username}\\` - inviter's username\n            \\`{inviter:discriminator}\\` - inviter's discriminator\n            \\`{inviter:tag}\\` - inviter's tag\n            \\`{inviter:mention}\\` - inviter's mention\n            \\`{inviter:invites}\\` - inviter's invites\n            \\`{inviter:invites:left}\\` - inviter's left invites\n                    \n            \\`{guild:name}\\` - Server name\n            \\`{guild:members}\\` - Server members count`,\n            type: 'editreply'\n        }, interaction)\n    }\n\n    if (message.toUpperCase() == \"DEFAULT\") {\n        inviteMessages.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n            if (data) {\n                data.inviteJoin = null;\n                data.save();\n\n                client.succNormal({\n                    text: `Welcome message deleted!`,\n                    type: 'editreply'\n                }, interaction);\n            }\n        })\n    }\n    else {\n        inviteMessages.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n            if (data) {\n                data.inviteJoin = message;\n                data.save();\n            }\n            else {\n                new inviteMessages({\n                    Guild: interaction.guild.id,\n                    inviteJoin: message\n                }).save();\n            }\n\n            client.succNormal({\n                text: `The welcome message has been set successfully`,\n                fields: [\n                    {\n                        name: `💬┆Message`,\n                        value: `${message}`,\n                        inline: true\n                    },\n                ],\n                type: 'editreply'\n            }, interaction)\n        })\n    }\n}\n\n ","size_bytes":2580},"src/commands/custom-commands/add.js":{"content":"const Discord = require('discord.js');\nconst Schema = require(\"../../database/models/customCommandAdvanced\");\n\nmodule.exports = async (client, interaction, args) => {\n    const cmdname = interaction.options.getString('command');\n    const cmdresponce = interaction.options.getString('text');\n\n    Schema.findOne({ Guild: interaction.guild.id, Name: cmdname.toLowerCase() }, async (err, data) => {\n        if (data) {\n            client.errNormal({ error: \"This command name is already added in guild custom commands!\", type: 'editreply' }, interaction);\n        }\n        else {\n            const row = new Discord.ActionRowBuilder()\n                .addComponents(\n                    new Discord.StringSelectMenuBuilder()\n                        .setCustomId('customSelect')\n                        .setPlaceholder('❌┆Nothing selected')\n                        .addOptions(\n                            [\n                                {\n                                    label: `Embed`,\n                                    description: `Send a message in an embed`,\n                                    value: \"command-embed\",\n                                },\n                                {\n                                    label: `Normal`,\n                                    description: `Send a message as normal`,\n                                    value: \"command-normal\",\n                                },\n                                {\n                                    label: `Private`,\n                                    description: `Send the message in DM`,\n                                    value: \"command-dm\",\n                                },\n                            ]\n                        )\n                );\n\n            client.embed({ desc: `What action should be attached to this command?`, components: [row], type: 'editreply' }, interaction)\n\n            const filter = i => i.user.id === interaction.user.id;\n\n            interaction.channel.awaitMessageComponent({ filter, max: 1 }).then(async i => {\n                if (i.customId == 'customSelect') {\n                    await i.deferUpdate();\n                    if (i.values[0] === \"command-embed\") {\n                        new Schema({\n                            Guild: interaction.guild.id,\n                            Name: cmdname.toLowerCase(),\n                            Responce: cmdresponce,\n                            Action: \"Embed\"\n                        }).save();\n\n                        client.succNormal({\n                            text: `The command has been added successfully`,\n                            fields: [{\n                                name: \"🔧┆Command\",\n                                value: `\\`\\`\\`${cmdname.toLowerCase()}\\`\\`\\``,\n                                inline: true,\n                            }],\n                            components: [],\n                            type: 'editreply'\n                        }, i);\n                    }\n\n                    if (i.values[0] === \"command-normal\") {\n                        new Schema({\n                            Guild: interaction.guild.id,\n                            Name: cmdname.toLowerCase(),\n                            Responce: cmdresponce,\n                            Action: \"Normal\"\n                        }).save();\n\n                        client.succNormal({\n                            text: `The command has been added successfully`,\n                            fields: [{\n                                name: \"🔧┆Command\",\n                                value: `\\`\\`\\`${cmdname.toLowerCase()}\\`\\`\\``,\n                                inline: true,\n                            }],\n                            components: [],\n                            type: 'editreply'\n                        }, i);\n                    }\n\n                    if (i.values[0] === \"command-dm\") {\n                        new Schema({\n                            Guild: interaction.guild.id,\n                            Name: cmdname.toLowerCase(),\n                            Responce: cmdresponce,\n                            Action: \"DM\"\n                        }).save();\n\n                        client.succNormal({\n                            text: `The command has been added successfully`,\n                            fields: [{\n                                name: \"🔧┆Command\",\n                                value: `\\`\\`\\`${cmdname.toLowerCase()}\\`\\`\\``,\n                                inline: true,\n                            }],\n                            components: [],\n                            type: 'editreply'\n                        }, i);\n                    }\n\n                    await interaction.guild.commands.create({\n                        name: cmdname,\n                        description: 'Custom server command'\n                    });\n                }\n            })\n        }\n    })\n\n}\n\n ","size_bytes":4965},"src/commands/custom-commands/delete.js":{"content":"const Discord = require('discord.js');\nconst Schema = require(\"../../database/models/customCommandAdvanced\");\n\nmodule.exports = async (client, interaction, args) => {\n    const cmdname = interaction.options.getString('command');\n    Schema.findOne({ Guild: interaction.guild.id, Name: cmdname.toLowerCase() }, async (err, data) => {\n        console.log(data)\n        if (data) {\n            Schema.findOneAndDelete({ Guild: interaction.guild.id, Name: cmdname.toLowerCase() }).then(async () => {\n                var commands = await interaction.guild.commands.fetch()\n                var command = await commands.find((cmd => cmd.name == cmdname.toLowerCase()))\n                if(!command) return client.errNormal({ error: \"Unable to find this command!\", type: 'editreply' }, interaction );\n                await interaction.guild.commands.delete(command.id);\n\n                client.succNormal({\n                    text: `The command has been deleted successfully`,\n                    fields: [{\n                        name: \"🔧┆Command\",\n                        value: `\\`\\`\\`${cmdname}\\`\\`\\``,\n                        inline: true,\n                    }],\n                    type: 'editreply'\n                }, interaction);\n            })\n        }\n        else {\n            client.errNormal({ error: \"Unable to find this command!\", type: 'editreply' }, interaction);\n        }\n    })\n\n}\n\n ","size_bytes":1405},"src/commands/developers/args.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    const message = interaction.options.getString('message');\n\n    client.succNormal({\n        text: `Message has been sent successfully!`,\n        type: 'ephemeraledit'\n    }, interaction);\n\n    if (message == \"information\") {\n        client.simpleEmbed({\n            image: `https://cdn.discordapp.com/attachments/843487478881976381/874742689017520128/Bot_banner_information.jpg`\n        }, interaction.channel).then(() => {\n            client.embed({\n                title: `ℹ️・Information`,\n                thumbnail: client.user.avatarURL({ size: 1024 }),\n                desc: `_____`,\n                fields: [\n                    {\n                        name: `👋┆Welcome to ${interaction.guild.name}!`,\n                        value: `Welcome to our hangout place! Meet new people here, play some games and participate in seasonal events! We are a server where we bring everyone together and we try to make it comfortable for everyone! Please be welcome and have some fun!`,\n                    },\n                    {\n                        name: `❓┆What can I do here?`,\n                        value: `- Meet new people! \\n- Play many fun games! \\n- Discover the seasons! \\n- Participate in events! \\nAnd…. Last but not least, choose your own roles at <#847867992044994561>!`,\n                    },\n                    {\n                        name: `🎫┆How do I get help when needed?`,\n                        value: `You can make a ticket in <#820308164322656327>! We are happy to help you with your questions here and offer support in your server!`,\n                    },\n                    {\n                        name: `⚙️┆I want to help Bot Hangout to improve!`,\n                        value: `- Go to applications and see what kind of jobs are available! \\n- Or make a ticket and ask if you can help with certain things! \\n\\n**We wish you a very nice and happy time here!**`,\n                    }\n                ]\n            }, interaction.channel)\n        })\n    }\n\n    if (message == \"rules\") {\n        client.simpleEmbed({\n            image: `https://cdn.discordapp.com/attachments/843487478881976381/874742702393131038/Bot_banner_rules.jpg`\n        }, interaction.channel).then(async () => {\n            await client.embed({\n                title: `📃・Rules`,\n                thumbnail: client.user.avatarURL({ size: 1024 }),\n                desc: `_____ \\n\\nThese are our server rules. Please stick to this to keep it fun for everyone. The Admins and Mods will Timeout/Kick/Ban per discretion`,\n            }, interaction.channel)\n\n            await client.embed({\n                title: `1. Be respectful`,\n                desc: `You must respect all users, regardless of your liking towards them. Treat others the way you want to be treated.`,\n            }, interaction.channel)\n\n            await client.embed({\n                title: `2. No Inappropriate Language`,\n                desc: `The use of profanity should be kept to a minimum. However, any derogatory language towards any user is prohibited.`,\n            }, interaction.channel)\n\n            await client.embed({\n                title: `3. No spamming`,\n                desc: `Don't send a lot of small messages right after each other. Do not disrupt chat by spamming.`,\n            }, interaction.channel)\n\n            await client.embed({\n                title: `4. No pornographic/adult/other NSFW material`,\n                desc: `This is a community server and not meant to share this kind of material.`,\n            }, interaction.channel)\n\n            await client.embed({\n                title: `5. No advertisements`,\n                desc: `We do not tolerate any kind of advertisements, whether it be for other communities or streams. You can post your content in the media channel if it is relevant and provides actual value (Video/Art)`,\n            }, interaction.channel)\n\n            await client.embed({\n                title: `6. No offensive names and profile pictures`,\n                desc: `You will be asked to change your name or picture if the staff deems them inappropriate.`,\n            }, interaction.channel)\n\n            await client.embed({\n                title: `7. Server Raiding`,\n                desc: `Raiding or mentions of raiding are not allowed.`,\n            }, interaction.channel)\n\n            await client.embed({\n                title: `8. Direct & Indirect Threats`,\n                desc: `Threats to other users of DDoS, Death, DoX, abuse, and other malicious threats are absolutely prohibited and disallowed.`,\n            }, interaction.channel)\n\n            await client.embed({\n                title: `9. Follow the Discord Community Guidelines`,\n                desc: `You can find them here: https://discordapp.com/guidelines`,\n            }, interaction.channel)\n\n            await client.embed({\n                title: `10. Do not join voice chat channels without permissions of the people already in there`,\n                desc: `If you see that they have a free spot it is alright to join and ask whether they have an open spot, but leave if your presence is not wanted by whoever was there first`,\n            }, interaction.channel)\n        })\n    }\n\n    if (message == \"applications\") {\n        client.simpleEmbed({\n            image: `https://cdn.discordapp.com/attachments/843487478881976381/874742737415581786/Bot_banner_applications.jpg`\n        }, interaction.channel).then(() => {\n            client.embed({\n                title: `💼・Applications`,\n                thumbnail: client.user.avatarURL({ size: 1024 }),\n                desc: `_____ \\n\\nWhat could be more fun than working at the best bot/server? We regularly have spots for new positions that you can apply for \\n\\nBut... what can you expect?`,\n                fields: [\n                    {\n                        name: `👥┆A very nice team`,\n                        value: `In the Bot team there is always a pleasant atmosphere and everyone is treated equally!`,\n                    },\n                    {\n                        name: `🥳┆Access to the beta program`,\n                        value: `Get access to unreleased Bot features with your own server! You are a real Bot tester!`,\n                    },\n                    {\n                        name: `📛┆A nice rank and badge`,\n                        value: `You will get a nice rank in the server and a team badge in our userinfo command. Everyone can see that you contribute to the team`,\n                    },\n                    {\n                        name: `📖┆Learn and grow`,\n                        value: `We understand that you don't always understand everything right away! At Bot, we give you the opportunity to learn new things and get better at the position. You can also grow into the management team in the future!`,\n                    },\n                    {\n                        name: `📘┆What does everything mean?`,\n                        value: `**Moderator** \\nYou keep yourself busy with the server that everything is and remains fun for everyone! Chat with us and keep the overview \\n\\n**Marketing** \\nWe also want to grow and we do that with a great marketing team! You know better than anyone how to make a server grow well \\n\\n**Organization** \\nYou will ensure an even nicer atmosphere in the server! Together with a team you work on new and fun events to make the server even more fun!`,\n                    },\n                    {\n                        name: `📃┆Apply?`,\n                        value: `Create a ticket to receive your application!`,\n                    }\n                ]\n            }, interaction.channel)\n        })\n    }\n\n    if (message == \"boosterperks\") {\n        client.simpleEmbed({\n            image: `https://media.discordapp.net/attachments/843487478881976381/881396544195149874/Bot_banner_boosters.jpg`\n        }, interaction.channel).then(() => {\n            client.embed({\n                title: `💎・Booster Perks`,\n                thumbnail: client.user.avatarURL({ size: 1024 }),\n                desc: `_____ \\n\\nMore options in the server? Become a real Bot Booster and get nice benefits for a nice experience. But what do you actually get?`,\n                fields: [\n                    {\n                        name: `😛┆Use external stickers`,\n                        value: `Use stickers from other servers in our server`,\n                    },\n                    {\n                        name: `🔊┆Send TTS messages`,\n                        value: `Send messages that have a sound attached`,\n                    },\n                    {\n                        name: `🤔┆Access to the hidden lounge`,\n                        value: `Get access to a private lounge and chat with other boosters!`,\n                    },\n                    {\n                        name: `📛┆Change your nickname`,\n                        value: `Change your name in the server. This is how you stand out in the server`,\n                    },\n                    {\n                        name: `💭┆Create public/private threads`,\n                        value: `Create a thread in our text channels`,\n                    },\n                    {\n                        name: `🎉┆Private giveaways`,\n                        value: `Get access to fun exclusive giveaways`,\n                    },\n                    {\n                        name: `📂┆Send files in any channel`,\n                        value: `Send files in all channels where you can talk`,\n                    },\n                    {\n                        name: `📊┆Get access to a special promotional channel`,\n                        value: `Get the opportunity to promote your own server in a special channel`,\n                    },\n                    {\n                        name: `😜┆Custom role of your choice`,\n                        value: `Create your own role that you can set yourself`,\n                    },\n                    {\n                        name: `💎┆Get the booster role + badge`,\n                        value: `Stand out with a nice booster role and a booster badge!`,\n                    },\n                    {\n                        name: `💻┆Access to new bèta updates in Bot`,\n                        value: `We'll give your server access to updates that aren't out yet! How nice is that?`,\n                    }\n                ]\n            }, interaction.channel)\n        })\n    }\n\n    if (message == \"links\") {\n        client.simpleEmbed({\n            image: `https://media.discordapp.net/attachments/843487478881976381/881396544195149874/Bot_banner_boosters.jpg`\n        }, interaction.channel).then(() => {\n            client.embed({\n                title: `🔗・Links`,\n                thumbnail: client.user.avatarURL({ size: 1024 }),\n                desc: `_____ \\n\\nSee all the links from Bot Network!`,\n                fields: [\n                    {\n                        name: `▬▬│Servers│▬▬`,\n                        value: ``,\n                    }\n                ]\n            }, interaction.channel)\n        })\n    }\n\n    if (message == \"rewards\") {\n        client.embed({\n            title: `😜・Role Rewards`,\n            thumbnail: client.user.avatarURL({ size: 1024 }),\n            desc: `_____ \\n\\nDo you want some extras in the server? Or do you want to stand out more in the server? Look below for the rewards`,\n            fields: [\n                {\n                    name: `🏆┆Levels`,\n                    value: `- Level 5   | <@&833307296699908097>\\n- Level 10  | <@&833307450437664838>\\n- Level 15  | <@&833307452279226379>\\n- Level 30 | <@&915290300757458964>\\n- Level 40 | <@&915290324480430080>`,\n                },\n                {\n                    name: `🥳┆Special`,\n                    value: `- 1 server vote | <@&833959913742794772>\\n- 1 boost | <@&744208324022501447>\\n- 1 donate | <@&849554599371210793>`,\n                },\n                {\n                    name: `💰┆Economy`,\n                    value: `- $10.000 | <@&890720270086733854>\\n- $15.000 | <@&833936202725720084>\\n- $20.000 | <@&833936185167839232> \\n- $25.000 | <@&928236333309255711> \\n- $30.000 | <@&928235747100733450>`,\n                }\n            ]\n        }, interaction.channel)\n    }\n\n    if (message == \"ourbots\") {\n        client.simpleEmbed({\n            image: `https://cdn.discordapp.com/attachments/843487478881976381/874742741224022016/Bot_banner_bot_info.jpg`\n        }, interaction.channel).then(() => {\n            client.embed({\n                title: `🤖・Our bots`,\n                thumbnail: client.user.avatarURL({ size: 1024 }),\n                desc: `_____ \\n\\nOutside of a community we also maintain 2 public bots. These bots are all made to make your server better!`,\n                fields: [\n                    {\n                        name: `📘┆What is Bot?`,\n                        value: `Bot is a bot with which you can run your entire server! With no less than 400+ commands, we have a large bot with many options to improve your server! You know what else is beautiful? All of this is **FREE** to use!`,\n                    },\n                    {\n                        name: `🎶┆What is Bot 2?`,\n                        value: `Bot 2 was created for additional music. This way you never get in each other's way when someone is already listening to music. Furthermore, this bot contains a soundboard and a radio system`,\n                    },\n                    {\n                        name: `📨┆How do I invite the bots?`,\n                        value: `You can invite the bots by doing \\`/invite\\` or by clicking on the links below \\n\\n**Bot** - [Invite here](${client.config.discord.botInvite})`,\n                    },\n                    {\n                        name: `🎫┆How do I get help when needed?`,\n                        value: `You can make a ticket in <#820308164322656327>! We are happy to help you with your questions here and offer support in your server!`,\n                    }\n                ]\n            }, interaction.channel)\n        })\n    }\n}\n\n ","size_bytes":14392},"src/commands/developers/badge.js":{"content":"const Discord = require('discord.js');\n\nconst model = require('../../database/models/badge');\n\nconst webhookClientLogs = new Discord.WebhookClient({\n    id: \"\",\n    token: \"\",\n});\n\nmodule.exports = async (client, interaction, args) => {\n    const badgeFlags = {\n        DEVELOPER: client.emotes.badges.developer,\n        EVENT: client.emotes.badges.event,\n        BOOSTER: client.emotes.badges.booster,\n        BUGS: client.emotes.badges.bug,\n        MANAGEMENT: client.emotes.badges.management,\n        PREMIUM: client.emotes.badges.premium,\n        SUPPORTER: client.emotes.badges.supporter,\n        TEAM: client.emotes.badges.team,\n        BOOSTER: client.emotes.badges.booster,\n        PARTNER: client.emotes.badges.partner,\n        VOTER: client.emotes.badges.voter,\n        SUPPORT: client.emotes.badges.support,\n        MODERATOR: client.emotes.badges.moderator,\n        DESIGNER: client.emotes.badges.designer,\n        MARKETING: client.emotes.badges.marketing,\n        ACTIVE: client.emotes.badges.active,\n        VIP: client.emotes.badges.vip\n    }\n\n    const boolean = interaction.options.getBoolean('new');\n    const member = interaction.options.getUser('user');\n    const badge = interaction.options.getString('badge');\n\n    let Badges = await model.findOne({ User: member.id });\n\n    if (!badgeFlags[badge.toUpperCase()]) return client.errNormal({\n        error: `I can't find that badge`,\n        type: `editreply`\n    }, interaction);\n\n    if (boolean == true) {\n        if (Badges) {\n            if (Badges.FLAGS.includes(badge.toUpperCase())) return client.errNormal({\n                error: `This users already has that badge!`,\n                type: `editreply`\n            }, interaction);\n\n            let FLAG = badge.toUpperCase();\n            let array = Badges.FLAGS;\n\n            array.push(FLAG);\n\n            model.findOne({ User: member.id }, async (err, data) => {\n                if (err) console.log(err);\n                data.FLAGS = array\n                data.save();\n            });\n\n            client.succNormal({\n                text: `Added the ${badgeFlags[badge.toUpperCase()]} (${badge.toUpperCase()}) badge!`,\n                type: `editreply`\n            }, interaction);\n        } else {\n            const newSettings = new model({ User: member.id, FLAGS: [badge.toUpperCase()] });\n            await newSettings.save().catch(() => { });\n\n            client.succNormal({\n                text: `Added the ${badgeFlags[badge.toUpperCase()]} (${badge.toUpperCase()}) badge!`,\n                type: `editreply`\n            }, interaction)\n        }\n\n        let embedLogs = new Discord.EmbedBuilder()\n            .setTitle(`📛・Badge added`)\n            .setDescription(`Added a new badge to ${member} (${member.id})`)\n            .addFields(\n                { name: \"👤┆Added By\", value: `${interaction.user} (${interaction.user.tag})`, inline: true },\n                { name: `📛┆Badge`, value: `${badgeFlags[badge.toUpperCase()]} (${badge.toUpperCase()})`, inline: true },\n            )\n            .setColor(client.config.colors.normal)\n            .setFooter({ text: client.config.discord.footer})\n            .setTimestamp();\n        webhookClientLogs.send({\n            username: 'Bot Badges',\n            embeds: [embedLogs],\n        });\n    }\n    else if (boolean == false) {\n        if (!Badges.FLAGS.includes(badge.toUpperCase())) return client.errNormal({\n            error: `The user doesn't have that badge`,\n            type: `editreply`\n        }, interaction);\n\n        let FLAG = badge.toUpperCase();\n        let array = Badges.FLAGS;\n\n        for (var i = 0; i < array.length; i++) {\n\n            if (array[i] === FLAG) {\n                array.splice(i, 1);\n                i--;\n            }\n        }\n\n        if (!array[0]) {\n            let deleted = await model.deleteMany({ User: member.id });\n            client.succNormal({\n                text: `Removed the ${badgeFlags[badge.toUpperCase()]} (${badge.toUpperCase()}) badge, the user have been removed from the badge system, he has no badges left!`,\n                type: 'editreply'\n            }, interaction);\n\n        } else {\n            model.findOne(\n                { User: member.id },\n                async (err, data) => {\n                    if (err) console.log(err);\n                    data.FLAGS = array\n                    data.save();\n                }\n            );\n            client.succNormal({\n                text: `Removed the ${badgeFlags[badge.toUpperCase()]} (${badge.toUpperCase()}) badge!`,\n                type: 'editreply'\n            }, interaction);\n        }\n\n        let embedLogs = new Discord.EmbedBuilder()\n            .setTitle(`📛・Badge removed`)\n            .setDescription(`Removed a badge from ${member} (${member.id})`)\n            .addFields(\n                { name: \"👤┆Removed By\", value: `${interaction.user} (${interaction.user.tag})`, inline: true },\n                { name: `📛┆Badge`, value: `${badgeFlags[badge.toUpperCase()]} (${badge.toUpperCase()})`, inline: true },\n            )\n            .setColor(client.config.colors.normal)\n            .setFooter({ text: client.config.discord.footer })\n            .setTimestamp();\n        webhookClientLogs.send({\n            username: 'Bot Badges',\n            embeds: [embedLogs],\n        });\n    }\n}\n\n ","size_bytes":5348},"src/commands/developers/ban.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require('../../database/models/userBans');\n\nconst webhookClientLogs = new Discord.WebhookClient({\n    id: \"\",\n    token: \"\",\n});\n\nmodule.exports = async (client, interaction, args) => {\n    const boolean = interaction.options.getBoolean('new');\n    const member = interaction.options.getUser('user');\n\n    if (boolean == true) {\n        Schema.findOne({ User: member.id }, async (err, data) => {\n            if (data) {\n                return client.errNormal({\n                    error: `<@!${member.id}> (${member.id}) has already been banned from the bot`,\n                    type: `editreply`\n                }, interaction);\n            }\n            else {\n                new Schema({\n                    User: member.id\n                }).save();\n\n                client.succNormal({\n                    text: `<@!${member.id}> (${member.id}) banned from the bot`,\n                    type: 'editreply'\n                }, interaction)\n\n                let embedLogs = new Discord.EmbedBuilder()\n                    .setTitle(`🔨・Ban added`)\n                    .setDescription(`<@!${member.id}> (${member.id}) banned from the bot`)\n                    .addFields(\n                        { name: \"👤┆Banned By\", value: `${interaction.user} (${interaction.user.tag})`, inline: true },\n                    )\n                    .setColor(client.config.colors.normal)\n                    .setFooter({ text: client.config.discord.footer })\n                    .setTimestamp();\n                webhookClientLogs.send({\n                    username: 'Bot Bans',\n                    embeds: [embedLogs],\n                });\n            }\n        })\n    }\n    else if (boolean == false) {\n        Schema.findOne({ User: member.id }, async (err, data) => {\n            if (data) {\n                Schema.findOneAndDelete({ User: member.id }).then(() => {\n                    client.succNormal({\n                        text: `<@!${member.id}> (${member.id}) unbanned from the bot`,\n                        type: 'editreply'\n                    }, interaction)\n\n                    let embedLogs = new Discord.EmbedBuilder()\n                        .setTitle(`🔨・Ban removed`)\n                        .setDescription(`<@!${member.id}> (${member.id}) unbanned from the bot`)\n                        .addFields(\n                            { name: \"👤┆Unbanned By\", value: `${interaction.user} (${interaction.user.tag})`, inline: true },\n                        )\n                        .setColor(client.config.colors.normal)\n                        .setFooter({ text: client.config.discord.footer })\n                        .setTimestamp();\n                    webhookClientLogs.send({\n                        username: 'Bot Bans',\n                        embeds: [embedLogs],\n                    });\n                })\n            }\n            else {\n                return client.errNormal({\n                    error: `<@!${member.id}> (${member.id}) has not been banned from the bot`,\n                    type: `editreply`\n                }, interaction);\n            }\n        })\n    }\n}\n\n ","size_bytes":3167},"src/commands/developers/credits.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require('../../database/models/votecredits');\n\nconst webhookClientLogs = new Discord.WebhookClient({\n    id: \"\",\n    token: \"\",\n});\n\nmodule.exports = async (client, interaction, args) => {\n    const type = interaction.options.getString('type');\n    const user = interaction.options.getUser('user');\n    const amount = interaction.options.getNumber('amount');\n\n    if (type == \"add\") {\n        Schema.findOne({ User: user.id }, async (err, data) => {\n            if (data) {\n                data.Credits += amount;\n                data.save();\n            }\n            else {\n                new Schema({\n                    User: user.id,\n                    Credits: amount\n                }).save();\n            }\n        })\n\n        client.succNormal({\n            text: `Added **${amount} credits** to ${user}`,\n            type: 'editreply'\n        }, interaction);\n\n        let embedLogs = new Discord.EmbedBuilder()\n            .setTitle(`🪙・Credits added`)\n            .setDescription(`Added credits to ${user} (${user.id})`)\n            .addFields(\n                { name: \"👤┆Added By\", value: `${interaction.user} (${interaction.user.tag})`, inline: true },\n                { name: \"🔢┆Amount\", value: `${amount}`, inline: true },\n            )\n            .setColor(client.config.colors.normal)\n            .setTimestamp();\n        webhookClientLogs.send({\n            username: 'Bot Credits',\n            embeds: [embedLogs],\n        });\n    }\n    else if (type == \"remove\") {\n        Schema.findOne({ User: user.id }, async (err, data) => {\n            if (data) {\n                data.Credits -= amount;\n                data.save();\n            }\n        })\n\n        client.succNormal({\n            text: `Removed **${amount} credits** from ${user}`,\n            type: 'editreply'\n        }, interaction);\n\n        let embedLogs = new Discord.EmbedBuilder()\n            .setTitle(`🪙・Credits removed`)\n            .setDescription(`Removed credits from ${user} (${user.id})`)\n            .addFields(\n                { name: \"👤┆Removed By\", value: `${interaction.user} (${interaction.user.tag})`, inline: true },\n                { name: \"🔢┆Amount\", value: `${amount}`, inline: true },\n            )\n            .setColor(client.config.colors.normal)\n            .setTimestamp();\n        webhookClientLogs.send({\n            username: 'Bot Credits',\n            embeds: [embedLogs],\n        });\n    }\n}\n\n ","size_bytes":2499},"src/commands/developers/eval.js":{"content":"const Discord = require('discord.js');\n\nconst { inspect } = require('util');\n\nmodule.exports = async (client, interaction, args) => {\n    const webhookClientLogs = new Discord.WebhookClient({\n        id: client.webhooks.evalLogs.id,\n        token: client.webhooks.evalLogs.token,\n    });\n\n    let code = interaction.options.getString('code');\n    if (code.includes('token') == true) return client.errNormal({ error: \"I'm not going to send my token!\", type: 'editreply' }, interaction);\n\n    code = code.replace(/[\"\"]/g, '\"').replace(/['']/g, \"'\");\n    let evaled;\n\n    try {\n        const start = process.hrtime();\n        evaled = eval(code);\n\n        if (evaled instanceof Promise) {\n            evaled = await evaled;\n        }\n\n        const stop = process.hrtime(start);\n        const outputResponse = `\\`\\`\\`${inspect(evaled, { depth: 0 })}\\n\\`\\`\\``;\n\n        if (outputResponse.length <= 1024) {\n            await client.embed({\n                title: `💻・Eval`,\n                fields: [\n                    {\n                        name: \"📥┇Input\",\n                        value: `\\`\\`\\`${code}\\`\\`\\``,\n                        inline: false,\n                    },\n                    {\n                        name: \"📥┇Output\",\n                        value: outputResponse.substr(0, 1024),\n                        inline: false,\n                    },\n                ],\n                type: 'editreply'\n            }, interaction)\n\n            const embed2 = new Discord.EmbedBuilder()\n                .setTitle(`${interaction.user.tag} used eval command`)\n                .addFields(\n                    { name: \"📥┇Input\", value: `\\`\\`\\`${code}\\`\\`\\``, inline: false },\n                    { name: \"📤┇Output\", value: outputResponse.substr(0, 1024), inline: false },\n                )\n                .setColor(client.config.colors.normal)\n                .setTimestamp();\n            webhookClientLogs.send({\n                username: 'Bot Logs',\n                embeds: [embed2],\n            });\n        }\n        else {\n            const output = new Discord.AttachmentBuilder(Buffer.from(outputResponse), { name: 'output.txt' });\n            var embed2 = new Discord.EmbedBuilder()\n                .setAuthor(client.user.username, client.user.avatarURL())\n                .addFields(\n                    { name: \"📥┇Input\", value: `\\`\\`\\`${code}\\`\\`\\``, inline: false },\n                )\n                .setColor(client.config.colors.succes)\n                .setFooter(client.config.discord.footer)\n                .setTimestamp();\n            interaction.editreply({ embeds: [embed2] });\n            await interaction.channel.send({ files: [output] });\n        }\n    }\n    catch (err) {\n\n        return client.embed({\n            title: `💻・Eval`,\n            fields: [\n                {\n                    name: \"📥┇Input\",\n                    value: `\\`\\`\\`${code}\\`\\`\\``,\n                    inline: false,\n                },\n                {\n                    name: \"📥┇Error!\",\n                    value: `\\`\\`\\`${clean(err)}\\`\\`\\``,\n                    inline: false,\n                },\n            ],\n            type: 'editreply'\n        }, interaction)\n    }\n}\n\nconst clean = text => {\n    if (typeof (text) === \"string\")\n        return text.replace(/`/g, \"`\" + String.fromCharCode(8203)).replace(/@/g, \"@\" + String.fromCharCode(8203));\n    else\n        return text;\n}\n\n \n","size_bytes":3446},"src/commands/developers/servers.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    var list = \"\";\n    client.guilds.cache.forEach(guild => {\n        list += `${guild.name} (${guild.id}) | ${guild.memberCount} members | Owner: ${guild.ownerId}\\n`\n    })\n\n    const output = new Discord.AttachmentBuilder(Buffer.from(list), { name: 'servers.txt'});\n    interaction.editReply({ files: [output] });\n}\n\n ","size_bytes":416},"src/commands/economy/additem.js":{"content":"const Discord = require('discord.js');\n\nconst store = require(\"../../database/models/economyStore\");\n\nmodule.exports = async (client, interaction, args) => {\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n        perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n    }, interaction)\n\n    if (perms == false) return;\n\n    const role = interaction.options.getRole('role');\n    let amount = interaction.options.getNumber('amount');\n\n    if (!role || !amount) return client.errUsage({ usage: \"additem [role] [amount]\", type: 'editreply' }, interaction);\n\n    if (isNaN(amount)) return client.errNormal({ error: \"Enter a valid number!\", type: 'editreply' }, interaction);\n\n    if(role == interaction.guild.roles.everyone) return client.errNormal({ error: \"You cannot add the everyone role to the store!\", type: 'editreply' }, interaction);\n\n    store.findOne({ Guild: interaction.guild.id, Role: role.id }, async (err, storeData) => {\n        if (storeData) {\n            client.errNormal({ error: `This role is already in the store!`, type: 'editreply' }, interaction);\n        }\n        else {\n\n            new store({\n                Guild: interaction.guild.id,\n                Role: role.id,\n                Amount: amount\n            }).save();\n\n            client.succNormal({\n                text: `The role was added to the store!`,\n                fields: [\n                    {\n                        name: `🛒┆Role`,\n                        value: `<@&${role.id}>`,\n                        inline: true\n                    },\n                    {\n                        name: `${client.emotes.economy.coins}┆Amount`,\n                        value: `$${amount}`,\n                        inline: true\n                    }\n                ],\n                type: 'editreply'\n            }, interaction);\n        }\n    })\n}\n\n ","size_bytes":1917},"src/commands/economy/addmoney.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/economy\");\n\nmodule.exports = async (client, interaction, args) => {\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.Administrator],\n        perms: [Discord.PermissionsBitField.Flags.Administrator]\n    }, interaction)\n\n    if (perms == false) return;\n\n    const user = interaction.options.getUser('user');\n    let amount = interaction.options.getNumber('amount');\n\n    if (!user || !amount) return client.errUsage({ usage: \"addmoney [user] [amount]\", type: 'editreply' }, interaction);\n\n    if (isNaN(amount)) return client.errNormal({ error: \"Enter a valid number!\", type: 'editreply' }, interaction);\n\n    if (user.bot) return client.errNormal({\n        error: \"You cannot add money to a bot!\",\n        type: 'editreply'\n    }, interaction);\n\n    client.addMoney(interaction, user, parseInt(amount));\n\n    setTimeout(() => {\n        Schema.findOne({ Guild: interaction.guild.id, User: user.id }, async (err, data) => {\n            if (data) {\n\n                client.succNormal({\n                    text: `Added money to a user!`,\n                    fields: [\n                        {\n                            name: `👤┆User`,\n                            value: `<@!${user.id}>`,\n                            inline: true\n                        },\n                        {\n                            name: `${client.emotes.economy.coins}┆Amount`,\n                            value: `$${amount}`,\n                            inline: true\n                        }\n                    ],\n                    type: 'editreply'\n                }, interaction);\n            }\n            else {\n                client.errNormal({ error: `This user doesn't have any money!`, type: 'editreply' }, interaction);\n            }\n        }, 500)\n    })\n}\n ","size_bytes":1895},"src/commands/economy/balance.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/economy\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    const user = interaction.options.getUser('user') || interaction.user;\n\n    if (user.bot) return client.errNormal({\n        error: \"You cannot see the balance of a bot!\",\n        type: 'editreply'\n    }, interaction);\n\n    Schema.findOne({ Guild: interaction.guild.id, User: user.id }, async (err, data) => {\n        if (data) {\n\n            let total = data.Money + data.Bank;\n\n            client.embed({\n                title: `${client.emotes.economy.coins}・Balance`,\n                fields: [\n                    {\n                        name: `${client.emotes.economy.pocket}┆Wallet`,\n                        value: `$${data.Money}`,\n                        inline: true\n                    },\n                    {\n                        name: `${client.emotes.economy.bank}┆Bank`,\n                        value: `$${data.Bank}`,\n                        inline: true\n                    },\n                    {\n                        name: `💰┆Total`,\n                        value: `$${total}`,\n                        inline: true\n                    }\n                ],\n                desc: `The current balance of \\`${user.tag}\\``,\n                type: 'editreply'\n            }, interaction);\n        }\n        else {\n            client.errNormal({\n                error: `The user doesn't have any money!`, type: 'editreply'\n            }, interaction);\n        }\n    })\n}\n\n ","size_bytes":1562},"src/commands/economy/beg.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/economyTimeout\");\n\nmodule.exports = async (client, interaction, args) => {\n    let user = interaction.user;\n\n    let timeout = 180000;\n    let amount = 5;\n\n    Schema.findOne({ Guild: interaction.guild.id, User: user.id }, async (err, dataTime) => {\n        if (dataTime && dataTime.Beg !== null && timeout - (Date.now() - dataTime.Beg) > 0) {\n            let time = (dataTime.Beg / 1000 + timeout / 1000).toFixed(0);\n            return client.errWait({\n                time: time,\n                type: 'editreply'\n            }, interaction);\n        }\n        else {\n\n            client.succNormal({\n                text: `You've begged for some money!`,\n                fields: [\n                    {\n                        name: `${client.emotes.economy.coins}┆Amount`,\n                        value: `$${amount}`,\n                        inline: true\n                    }\n                ],\n                type: 'editreply'\n            }, interaction);\n\n            if (dataTime) {\n                dataTime.Beg = Date.now();\n                dataTime.save();\n            }\n            else {\n                new Schema({\n                    Guild: interaction.guild.id,\n                    User: user.id,\n                    Beg: Date.now()\n                }).save();\n            }\n\n            client.addMoney(interaction, user, amount);\n        }\n    })\n}\n\n ","size_bytes":1457},"src/commands/economy/buy.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/economy\");\nconst store = require(\"../../database/models/economyStore\");\nconst items = require(\"../../database/models/economyItems\");\nmodule.exports = async (client, interaction, args) => {\n    const storeData = await store.find({ Guild: interaction.guild.id });\n    if (storeData.length == 0) return client.errNormal({\n        error: `No shop found in this server`,\n        type: 'editreply'\n    }, interaction);\n\n    let labels = [];\n\n    storeData.forEach(d => {\n        const role = interaction.guild.roles.cache.get(d.Role);\n\n        const generated = {\n            label: `${role.name.substr(0, 24)}.`,\n            value: role.id,\n        }\n\n        return labels.push(generated);\n    });\n    labels.push({\n        label: `Fishingrod`,\n        value: `fishingrod`,\n    })\n\n    const select = await client.generateSelect(`economyBuy`, labels);\n\n    client.embed({\n        title: `🛒・${interaction.guild.name}'s Store`,\n        desc: `Choose a item from the menu to buy`,\n        components: [select],\n        type: 'editreply'\n    }, interaction)\n\n    const filter = i => {\n        return i.user.id === interaction.user.id;\n    };\n\n    interaction.channel.awaitMessageComponent({ filter, componentType: Discord.ComponentType.StringSelect, time: 60000 }).then(async i => {\n        const role = i.values[0];\n        const buyPerson = i.guild.members.cache.get(i.user.id);\n\n        const data = await Schema.findOne({ Guild: i.guild.id, User: i.user.id });\n        if(i.values[0] == 'fishingrod') {\n            console.log(data)\n            if (parseInt(100) > parseInt(data.Money)) return client.errNormal({\n                error: `You don't have enough money to buy this!`,\n                type: 'update',\n                components: []\n            }, i);\n\n            client.removeMoney(i, i.user, parseInt(100));\n            items.findOne({ Guild: i.guild.id, User: i.user.id }, async (err, data) => {\n                if (data) {\n                    data.FishingRod = true;\n                    data.save();\n                } else {\n                    new items({\n                        Guild: i.guild.id,\n                        User: i.user.id,\n                        FishingRod: true,\n                    }).save();\n                }\n            })\n            return client.succNormal({\n                text: `The purchase has been successfully completed`,\n                fields: [\n                    {\n                        name: `📘┆Item`,\n                        value: `Fishingrod`\n                    }\n                ],\n                type: 'update',\n                components: []\n            }, i);\n\n        } \n        const checkStore = await store.findOne({ Guild: i.guild.id, Role: role });\n\n        if (parseInt(checkStore.Amount) > parseInt(data.Money)) return client.errNormal({\n            error: `You don't have enough money to buy this!`,\n            type: 'update',\n            components: []\n        }, i);\n\n        client.removeMoney(i, i.user, parseInt(checkStore.Amount));\n        try {\n            await buyPerson.roles.add(role);\n        } catch (e) {\n            return client.errNormal({\n                error: `I can't add <@&${role}> to you!`,\n                type: 'update',\n                components: []\n            }, i);\n        }\n\n        client.succNormal({\n            text: `The purchase has been successfully completed`,\n            fields: [\n                {\n                    name: `📘┆Item`,\n                    value: `<@&${role}>`\n                }\n            ],\n            type: 'update',\n            components: []\n        }, i);\n    })\n}\n\n","size_bytes":3705},"src/commands/economy/clear.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/economy\");\nconst Schema2 = require(\"../../database/models/economyTimeout\");\nconst store = require(\"../../database/models/economyStore\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    client.checkPerms({\n        flags: [Discord.PermissionsBitField.Flags.Administrator],\n        perms: [Discord.PermissionsBitField.Flags.Administrator]\n    }, interaction)\n\n\n    const row = new Discord.ActionRowBuilder() \n        .addComponents(\n            new Discord.ButtonBuilder()\n                .setCustomId('eco_go')\n                .setEmoji('✅')\n                .setStyle(Discord.ButtonStyle.Success),\n\n            new Discord.ButtonBuilder()\n                .setCustomId('eco_stop')\n                .setEmoji('❌')\n                .setStyle(Discord.ButtonStyle.Danger),\n        );\n\n    client.embed({\n        title: `⏰・Reset economy`,\n        desc: `Are you sure you want to reset the economy?`,\n        components: [row],\n        type: 'editreply',\n    }, interaction)\n\n    const filter = i => i.user.id === interaction.user.id;\n\n    interaction.channel.awaitMessageComponent({ filter, componentType: Discord.ComponentType.Button, time: 60000 }).then(async i => {\n        if (i.customId == \"eco_go\") {\n            var remove = await Schema.deleteMany({ Guild: interaction.guild.id });\n            var remove2 = await Schema2.deleteMany({ Guild: interaction.guild.id });\n            var remove3 = await store.deleteMany({ Guild: interaction.guild.id });\n\n            client.succNormal({\n                text: `The economy has been successfully reset in this guild!`,\n                components: [],\n                type: 'editreply'\n            }, interaction);\n        }\n\n        if (i.customId == \"eco_stop\") {\n            client.errNormal({\n                error: `The economy reset has been cancelled!`,\n                components: [],\n                type: 'editreply'\n            }, interaction);\n        }\n    })\n        .catch(() => {\n            client.errNormal({\n                error: \"Time's up! Cancelled the economy reset!\",\n                type: 'editreply'\n            }, interaction);\n        });\n}\n\n ","size_bytes":2221},"src/commands/economy/crime.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/economy\");\nconst Schema2 = require(\"../../database/models/economyTimeout\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    let user = interaction.user;\n    let timeout = 600000;\n\n    Schema2.findOne({ Guild: interaction.guild.id, User: user.id }, async (err, dataTime) => {\n        if (dataTime && dataTime.Crime !== null && timeout - (Date.now() - dataTime.Crime) > 0) {\n            let time = (dataTime.Crime / 1000 + timeout / 1000).toFixed(0);\n            return client.errWait({\n                time: time,\n                type: 'editreply'\n            }, interaction);\n        }\n        else {\n\n            let replies = ['Hacking', 'Burglary', 'Roberry', 'Murder', 'Dealing drugs', 'Child abuse', 'Arms trade', 'Street robbery'];\n\n            let result = Math.floor((Math.random() * replies.length));\n            let result2 = Math.floor((Math.random() * 10));\n            let amount = Math.floor(Math.random() * 80) + 1;\n\n            if (result2 > 7) {\n\n                client.succNormal({\n                    text: `Your crime went successfully!`,\n                    fields: [\n                        {\n                            name: `🦹‍♂️┆Crime`,\n                            value: `${replies[result]}`,\n                            inline: true\n                        },\n                        {\n                            name: `${client.emotes.economy.coins}┆Earned`,\n                            value: `$${amount}`,\n                            inline: true\n                        }\n                    ],\n                    type: 'editreply'\n                }, interaction);\n\n                client.addMoney(interaction, user, amount);\n\n                if (dataTime) {\n                    dataTime.Crime = Date.now();\n                    dataTime.save();\n                }\n\n                else {\n                    new Schema2({\n                        Guild: interaction.guild.id,\n                        User: user.id,\n                        Crime: Date.now()\n                    }).save();\n                }\n            }\n            else {\n                client.errNormal({ error: `You were caught carrying out the crime ${replies[result]}`, type: 'editreply' }, interaction);\n\n                if (dataTime) {\n                    dataTime.Crime = Date.now();\n                    dataTime.save();\n                }\n                else {\n                    new Schema2({\n                        Guild: interaction.guild.id,\n                        User: user.id,\n                        Crime: Date.now()\n                    }).save();\n                }\n            }\n        }\n    })\n}\n\n ","size_bytes":2734},"src/commands/economy/daily.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/economy\");\nconst Schema2 = require(\"../../database/models/economyTimeout\");\n\nmodule.exports = async (client, interaction, args) => {\n  let user = interaction.user;\n  let timeout = 86400000;\n  let amount = 200;\n\n  Schema2.findOne({ Guild: interaction.guild.id, User: user.id }, async (err, dataTime) => {\n    if (dataTime && dataTime.Daily !== null && timeout - (Date.now() - dataTime.Daily) > 0) {\n      let time = (dataTime.Daily / 1000 + timeout / 1000).toFixed(0);\n      return client.errWait({\n        time: time,\n        type: 'editreply'\n      }, interaction);\n    }\n    else {\n\n      client.succNormal({\n        text: `You've collected your daily reward!`,\n        fields: [\n          {\n            name: `${client.emotes.economy.coins}┆Amount`,\n            value: `$${amount}`,\n            inline: true\n          }\n        ],\n        type: 'editreply'\n      }, interaction);\n\n      if (dataTime) {\n        dataTime.Daily = Date.now();\n        dataTime.save();\n      }\n      else {\n        new Schema2({\n          Guild: interaction.guild.id,\n          User: user.id,\n          Daily: Date.now()\n        }).save();\n      }\n\n      client.addMoney(interaction, user, amount);\n    }\n  })\n}\n\n ","size_bytes":1284},"src/commands/economy/deleteitem.js":{"content":"const Discord = require('discord.js');\n\nconst store = require(\"../../database/models/economyStore\");\n\nmodule.exports = async (client, interaction, args) => {\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n        perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n    }, interaction)\n\n    if (perms == false) return;\n\n    const role = interaction.options.getRole('role');\n\n    if (!role) return client.errUsage({ usage: \"deleteitem [role]\", type: 'editreply' }, interaction);\n\n    store.findOne({ Guild: interaction.guild.id, Role: role.id }, async (err, storeData) => {\n        if (storeData) {\n\n            var remove = await store.deleteOne({ Guild: interaction.guild.id, Role: role.id });\n\n            client.succNormal({\n                text: `The role was deleted from the store`,\n                fields: [\n                    {\n                        name: `🛒┆Role`,\n                        value: `${role}`\n                    }\n                ],\n                type: 'editreply'\n            }, interaction);\n        }\n        else {\n\n            client.errNormal({\n                error: `This role is not in the store!`,\n                type: 'editreply'\n            }, interaction);\n        }\n    })\n}\n\n ","size_bytes":1298},"src/commands/economy/deposit.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/economy\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    let amount = interaction.options.getNumber('amount');\n    let user = interaction.user;\n\n    if (!amount) return client.errUsage({ usage: \"deposit [amount]\", type: 'editreply' }, interaction);\n\n    if (isNaN(amount)) return client.errNormal({ error: \"Enter a valid number!\", type: 'editreply' }, interaction);\n\n    if (amount < 0) return client.errNormal({ error: `You can't deposit negative money!`, type: 'editreply' }, interaction);\n\n    Schema.findOne({ Guild: interaction.guild.id, User: user.id }, async (err, data) => {\n        if (data) {\n            if (data.Money < parseInt(amount)) return client.errNormal({ error: `You don't have that much money!`, type: 'editreply' }, interaction);\n\n            let money = parseInt(amount);\n\n            data.Money -= money;\n            data.Bank += money;\n            data.save();\n\n            client.succNormal({\n                text: `You've have deposited some money into your bank!`,\n                fields: [\n                    {\n                        name: `${client.emotes.economy.coins}┆Amount`,\n                        value: `$${amount}`,\n                        inline: true\n                    }\n                ],\n                type: 'editreply'\n            }, interaction);\n        }\n        else {\n            client.errNormal({ text: `You don't have any money to deposit!`, type: 'editreply' }, interaction);\n        }\n    })\n}\n ","size_bytes":1560},"src/commands/economy/fish.js":{"content":"const Discord = require('discord.js');\nconst ms = require(\"ms\");\n\nconst Schema = require(\"../../database/models/economy\");\nconst Schema2 = require(\"../../database/models/economyTimeout\");\nconst itemSchema = require(\"../../database/models/economyItems\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    const rand = (min, max) => {\n        return Math.floor(Math.random() * (max - min)) + min;\n    };\n\n    let user = interaction.user;\n\n    let timeout = 60000;\n    let fish =\n        [\"Yellow Fish :tropical_fish:\",\n            \"Fat Fish :blowfish:\",\n            \"Blue Fish :fish:\",\n            \"Coconut :coconut:\",\n            \"Dolphin :dolphin:\",\n            \"Lobster :lobster:\",\n            \"Shark :shark:\",\n            \"Crab :crab:\",\n            \"Squid :squid:\",\n            \"Whale :whale2:\",\n            \"Shrimp :shrimp:\",\n            \"Octopus :octopus:\",\n            \"Diamond :gem:\"];\n\n    let randn = rand(0, parseInt(fish.length));\n    let randrod = rand(15, 30);\n\n    let fishToWin = fish[randn];\n\n    const userItems = await itemSchema.findOne({ Guild: interaction.guild.id, User: user.id });\n\n    if (!userItems || userItems.FishingRod == false) return client.errNormal({ error: \"You have to buy a fishing rod!\", type: 'editreply' }, interaction);\n\n    if (userItems) {\n        if (userItems.FishingRodUsage >= randrod) {\n            userItems.FishingRod = false;\n            userItems.save();\n\n            return client.errNormal({ error: \"Your fishing rod has broken! Go buy a new one!\", type: 'editreply' }, interaction);\n        }\n    }\n\n    Schema2.findOne({ Guild: interaction.guild.id, User: user.id }, async (err, dataTime) => {\n        if (dataTime && dataTime.Fish !== null && timeout - (Date.now() - dataTime.Fish) > 0) {\n            let time = (dataTime.Fish / 1000 + timeout / 1000).toFixed(0);\n\n            return client.errWait({ time: time, type: 'editreply' }, interaction);\n        }\n        else {\n            client.succNormal({ text: `You've fished and gotten a ${fishToWin}`, type: 'editreply' }, interaction);\n\n            if (userItems) {\n                userItems.FishingRodUsage += 1;\n                userItems.save();\n            }\n\n            if (dataTime) {\n                dataTime.Fish = Date.now();\n                dataTime.save();\n            }\n            else {\n                new Schema2({\n                    Guild: message.guild.id,\n                    User: user.id,\n                    Fish: Date.now()\n                }).save();\n            }\n        }\n    })\n\n}\n\n ","size_bytes":2532},"src/commands/economy/hourly.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/economy\");\nconst Schema2 = require(\"../../database/models/economyTimeout\");\n\nmodule.exports = async (client, interaction, args) => {\n    let user = interaction.user;\n    let timeout = 3600000;\n    let amount = 10;\n\n    Schema2.findOne({ Guild: interaction.guild.id, User: user.id }, async (err, dataTime) => {\n        if (dataTime && dataTime.Hourly !== null && timeout - (Date.now() - dataTime.Hourly) > 0) {\n            let time = (dataTime.Hourly / 1000 + timeout / 1000).toFixed(0);\n            return client.errWait({\n                time: time,\n                type: 'editreply'\n            }, interaction);\n        }\n        else {\n\n            client.succNormal({\n                text: `You've collected your hourly reward!`,\n                fields: [\n                    {\n                        name: `${client.emotes.economy.coins}┆Amount`,\n                        value: `$${amount}`,\n                        inline: true\n                    }\n                ],\n                type: 'editreply'\n            }, interaction);\n\n            if (dataTime) {\n                dataTime.Hourly = Date.now();\n                dataTime.save();\n            }\n            else {\n                new Schema2({\n                    Guild: interaction.guild.id,\n                    User: user.id,\n                    Hourly: Date.now()\n                }).save();\n            }\n\n            client.addMoney(interaction, user, amount);\n        }\n    })\n}\n\n ","size_bytes":1540},"src/commands/economy/hunt.js":{"content":"const Discord = require('discord.js');\nconst ms = require(\"ms\");\n\nconst Schema = require(\"../../database/models/economy\");\nconst Schema2 = require(\"../../database/models/economyTimeout\");\nconst itemSchema = require(\"../../database/models/economyItems\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    const rand = (min, max) => {\n        return Math.floor(Math.random() * (max - min)) + min;\n    };\n\n    let user = interaction.user;\n\n    let timeout = 60000;\n    let hunt =\n        [\"Rabbit :rabbit:\",\n            \"Frog :frog:\",\n            \"Monkey :monkey:\",\n            \"Chicken :chicken:\",\n            \"Wolf :wolf:\",\n            \"Rooster :rooster:\",\n            \"Turkey :turkey:\",\n            \"Chipmunk :chipmunk:\",\n            \"Water Buffalo :water_buffalo:\",\n            \"Race Horse :racehorse:\",\n            \"Pig :pig:\",\n            \"Snake :snake:\",\n            \"Cow :cow:\"];\n\n    let randn = rand(0, parseInt(hunt.length));\n    let randrod = rand(15, 30);\n\n    let huntToWin = hunt[randn];\n\n    Schema2.findOne({ Guild: interaction.guild.id, User: user.id }, async (err, dataTime) => {\n        if (dataTime && dataTime.Hunt !== null && timeout - (Date.now() - dataTime.Hunt) > 0) {\n            let time = (dataTime.Hunt / 1000 + timeout / 1000).toFixed(0);\n\n            return client.errWait({ time: time, type: 'editreply' }, interaction);\n        }\n        else {\n            client.succNormal({ text: `You've hunted and gotten a ${huntToWin}`, type: 'editreply' }, interaction);\n\n            if (dataTime) {\n                dataTime.Hunt = Date.now();\n                dataTime.save();\n            }\n            else {\n                new Schema2({\n                    Guild: interaction.guild.id,\n                    User: user.id,\n                    Hunt: Date.now()\n                }).save();\n            }\n        }\n    })\n\n}\n\n ","size_bytes":1857},"src/commands/economy/leaderboard.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/economy\");\n\nmodule.exports = async (client, interaction, args) => {\n    const type = interaction.options.getString(\"type\");\n\n    if (type == \"money\") {\n        const rawLeaderboard = await Schema.find({ Guild: interaction.guild.id }).sort(([['Money', 'descending']]));\n\n        if (!rawLeaderboard) return client.errNormal({ \n            error: \"No data found!\",\n            type: 'editreply'\n        }, interaction);\n\n        const lb = rawLeaderboard.map(e => `**${rawLeaderboard.findIndex(i => i.Guild === interaction.guild.id && i.User === e.User) + 1}** | <@!${e.User}> - ${client.emotes.economy.coins} \\`$${e.Money}\\``);\n\n        await client.createLeaderboard(`🪙・Money - ${interaction.guild.name}`, lb, interaction);\n    }\n    else if (type == \"bank\") {\n        const rawLeaderboard = await Schema.find({ Guild: interaction.guild.id }).sort(([['Bank', 'descending']]));\n\n        if (!rawLeaderboard) return client.errNormal({ \n            error: \"No data found!\",\n            type: 'editreply'\n        }, interaction);\n\n        const lb = rawLeaderboard.map(e => `**${rawLeaderboard.findIndex(i => i.Guild === interaction.guild.id && i.User === e.User) + 1}** | <@!${e.User}> - ${client.emotes.economy.bank} \\`$${e.Bank}\\``);\n\n        await client.createLeaderboard(`🏦・Bank - ${interaction.guild.name}`, lb, interaction);\n    }\n}\n\n ","size_bytes":1435},"src/commands/economy/monthly.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/economy\");\nconst Schema2 = require(\"../../database/models/economyTimeout\");\n\nmodule.exports = async (client, interaction, args) => {\n  let user = interaction.user;\n  let timeout = 2419200000;\n  let amount = 1000;\n\n  Schema2.findOne({ Guild: interaction.guild.id, User: user.id }, async (err, dataTime) => {\n    if (dataTime && dataTime.Monthly !== null && timeout - (Date.now() - dataTime.Monthly) > 0) {\n      let time = (dataTime.Monthly / 1000 + timeout / 1000).toFixed(0);\n      return client.errWait({\n        time: time,\n        type: 'editreply'\n      }, interaction);\n    }\n    else {\n\n      client.succNormal({\n        text: `You've collected your monthly reward!`,\n        fields: [\n          {\n            name: `${client.emotes.economy.coins}┆Amount`,\n            value: `$${amount}`,\n            inline: true\n          }\n        ],\n        type: 'editreply'\n      }, interaction);\n\n      if (dataTime) {\n        dataTime.Monthly = Date.now();\n        dataTime.save();\n      }\n      else {\n        new Schema2({\n          Guild: interaction.guild.id,\n          User: user.id,\n          Monthly: Date.now()\n        }).save();\n      }\n\n      client.addMoney(interaction, user, amount);\n    }\n  })\n}\n\n ","size_bytes":1299},"src/commands/economy/pay.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/economy\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    const user = await interaction.guild.members.fetch(interaction.options.getUser('user'));\n    let amount = interaction.options.getNumber('amount');\n    \n    if (amount < 0) return client.errNormal({ error: `You can't pay negative money!`, type: 'editreply' }, interaction);\n\n    if (user.id == interaction.user.id) {\n        return client.errNormal({\n            error: \"You cannot pay money to yourself!\",\n            type: 'editreply'\n        }, interaction)\n    }\n\n    Schema.findOne({ Guild: interaction.guild.id, User: interaction.user.id }, async (err, data) => {\n        if (data) {\n            if (data.Money < parseInt(amount)) return client.errNormal({ error: `You don't have that much money!`, type: 'editreply' }, interaction);\n\n            let money = parseInt(amount);\n\n            data.Money -= money;\n            data.save();\n\n            client.addMoney(interaction, user, money);\n\n            client.succNormal({\n                text: `You have payed some money to a user!`,\n                fields: [\n                    {\n                        name: `👤┆User`,\n                        value: `$${user}`,\n                        inline: true\n                    },\n                    {\n                        name: `${client.emotes.economy.coins}┆Amount`,\n                        value: `$${amount}`,\n                        inline: true\n                    }\n                ],\n                type: 'editreply'\n            }, interaction);\n        }\n        else {\n            client.errNormal({ text: `You don't have any money!`, type: 'editreply' }, interaction);\n        }\n    })\n}\n\n ","size_bytes":1775},"src/commands/economy/present.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/economy\");\nconst Schema2 = require(\"../../database/models/economyTimeout\");\n\nmodule.exports = async (client, interaction, args) => {\n    let user = interaction.user;\n    let timeout = 604800000;\n\n\n    Schema2.findOne({ Guild: interaction.guild.id, User: user.id }, async (err, dataTime) => {\n        if (dataTime && dataTime.Present !== null && timeout - (Date.now() - dataTime.Present) > 0) {\n            let time = (dataTime.Present / 1000 + timeout / 1000).toFixed(0);\n            return client.errWait({\n                time: time,\n                type: 'editreply'\n            }, interaction);\n        }\n        else {\n            let amount = Math.floor(Math.random() * 1000) + 1;\n\n            client.succNormal({\n                text: `You've collected your present reward!`,\n                fields: [\n                    {\n                        name: `${client.emotes.economy.coins}┆Amount`,\n                        value: `$${amount}`,\n                        inline: true\n                    }\n                ],\n                type: 'editreply'\n            }, interaction);\n\n            if (dataTime) {\n                dataTime.Present = Date.now();\n                dataTime.save();\n            }\n            else {\n                new Schema2({\n                    Guild: interaction.guild.id,\n                    User: user.id,\n                    Present: Date.now()\n                }).save();\n            }\n\n            client.addMoney(interaction, user, amount);\n        }\n    })\n}\n\n ","size_bytes":1591},"src/commands/economy/removemoney.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/economy\");\n\nmodule.exports = async (client, interaction, args) => {\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.Administrator],\n        perms: [Discord.PermissionsBitField.Flags.Administrator]\n    }, interaction)\n\n    if (perms == false) return;\n\n    const user = interaction.options.getUser('user');\n    let amount = interaction.options.getNumber('amount');\n\n    if (!user || !amount) return client.errUsage({ usage: \"addmoney [user] [amount]\", type: 'editreply' }, interaction);\n\n    if (isNaN(amount)) return client.errNormal({ error: \"Enter a valid number!\", type: 'editreply' }, interaction);\n\n    if (user.bot) return client.errNormal({\n        error: \"You cannot remove money from a bot!\",\n        type: 'editreply'\n    }, interaction);\n\n    client.removeMoney(interaction, user, parseInt(amount));\n\n    setTimeout(() => {\n        Schema.findOne({ Guild: interaction.guild.id, User: user.id }, async (err, data) => {\n            if (data) {\n\n                client.succNormal({\n                    text: `Removed money from a user!`,\n                    fields: [\n                        {\n                            name: `👤┆User`,\n                            value: `<@!${user.id}>`,\n                            inline: true\n                        },\n                        {\n                            name: `${client.emotes.economy.coins}┆Amount`,\n                            value: `$${amount}`,\n                            inline: true\n                        }\n                    ],\n                    type: 'editreply'\n                }, interaction);\n            }\n            else {\n                client.errNormal({ error: `This user doesn't have any money!`, type: 'editreply' }, interaction);\n            }\n        }, 500)\n    })\n}\n ","size_bytes":1907},"src/commands/economy/rob.js":{"content":"const Discord = require('discord.js');\nconst ms = require(\"ms\");\n\nconst Schema = require(\"../../database/models/economy\");\nconst Schema2 = require(\"../../database/models/economyTimeout\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    const user = interaction.options.getUser('user');\n    if (!user) return client.errUsage({ usage: \"rob [mention user]\", type: 'editreply' }, interaction);\n\n    if (user.bot) return client.errNormal({\n        error: \"You rob a bot!\",\n        type: 'editreply'\n    }, interaction);\n\n    try {\n        let timeout = 600000;\n\n        Schema2.findOne({ Guild: interaction.guild.id, User: interaction.user.id }, async (err, dataTime) => {\n            if (dataTime && dataTime.Rob !== null && timeout - (Date.now() - dataTime.Rob) > 0) {\n                let time = (dataTime.Rob / 1000 + timeout / 1000).toFixed(0);\n                return client.errWait({ time: time, type: 'editreply' }, interaction);\n            }\n            else {\n                Schema.findOne({ Guild: interaction.guild.id, User: interaction.user.id }, async (err, authorData) => {\n                    if (authorData) {\n                        if (authorData.Money < 200) return client.errNormal({ error: `You need atleast 200 coins in your wallet to rob someone!`, type: 'editreply' }, interaction);\n\n                        Schema.findOne({ Guild: interaction.guild.id, User: user.id }, async (err, targetData) => {\n                            if (targetData) {\n                                var targetMoney = targetData.Money;\n                                if (targetData = undefined || !targetData || targetMoney == 0 || targetMoney < 0) {\n                                    return client.errNormal({ error: `${user.username} does not have anything you can rob!`, type: 'editreply' }, interaction);\n                                }\n\n                                if (dataTime) {\n                                    dataTime.Rob = Date.now();\n                                    dataTime.save();\n                                }\n                                else {\n                                    new Schema2({\n                                        Guild: interaction.guild.id,\n                                        User: interaction.user.id,\n                                        Rob: Date.now()\n                                    }).save();\n                                }\n\n                                var random = Math.floor(Math.random() * 100) + 1;\n                                if (targetMoney < random) {\n                                    random = targetMoney;\n\n                                    authorData.Money += targetMoney;\n                                    authorData.save();\n\n                                    client.removeMoney(interaction, user, targetMoney);\n                                }\n                                else {\n                                    authorData.Money += random;\n                                    authorData.save();\n\n                                    client.removeMoney(interaction, user, random);\n                                }\n\n                                client.succNormal({\n                                    text: `Your robbed a user and got away!`,\n                                    fields: [\n                                        {\n                                            name: `👤┆User`,\n                                            value: `${user}`,\n                                            inline: true\n                                        },\n                                        {\n                                            name: `${client.emotes.economy.coins}┆Robbed`,\n                                            value: `$${random}`,\n                                            inline: true\n                                        }\n                                    ],\n                                    type: 'editreply'\n                                }, interaction);\n                            }\n                            else {\n                                return client.errNormal({ error: `${user.username} does not have anything you can rob!`, type: 'editreply' }, interaction);\n                            }\n                        })\n                    }\n                })\n            }\n        })\n    }\n    catch { }\n}\n\n ","size_bytes":4399},"src/commands/economy/store.js":{"content":"const Discord = require('discord.js');\n\nconst store = require(\"../../database/models/economyStore\");\n\nmodule.exports = async (client, interaction, args, message) => {\n    store.find({ Guild: interaction.guild.id }, async (err, storeData) => {\n        if (storeData && storeData.length > 0) {\n            const lb = storeData.map(e => `**<@&${e.Role}>** - ${client.emotes.economy.coins} $${e.Amount} \\n**To buy:** \\`buy ${e.Role}\\``);\n\n            await client.createLeaderboard(`🛒・${interaction.guild.name}'s Store`, lb, interaction);\n            client.embed({ \n                title: `🛒・Bot's Store`, \n                desc: `**Fishingrod** - ${client.emotes.economy.coins} $100 \\n**To buy:** \\`buy fishingrod\\``, \n            }, interaction.channel);\n        }\n        else {\n            client.errNormal({ \n                error: `No store found in this guild!`, \n                type: 'editreply' \n            }, interaction);\n        }\n    })\n\n}\n\n ","size_bytes":963},"src/commands/economy/weekly.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/economy\");\nconst Schema2 = require(\"../../database/models/economyTimeout\");\n\nmodule.exports = async (client, interaction, args) => {\n  let user = interaction.user;\n  let timeout = 604800000;\n  let amount = 500;\n\n  Schema2.findOne({ Guild: interaction.guild.id, User: user.id }, async (err, dataTime) => {\n    if (dataTime && dataTime.Weekly !== null && timeout - (Date.now() - dataTime.Weekly) > 0) {\n      let time = (dataTime.Weekly / 1000 + timeout / 1000).toFixed(0);\n      return client.errWait({\n        time: time,\n        type: 'editreply'\n      }, interaction);\n    }\n    else {\n\n      client.succNormal({\n        text: `You've collected your weekly reward!`,\n        fields: [\n          {\n            name: `${client.emotes.economy.coins}┆Amount`,\n            value: `$${amount}`,\n            inline: true\n          }\n        ],\n        type: 'editreply'\n      }, interaction);\n\n      if (dataTime) {\n        dataTime.Weekly = Date.now();\n        dataTime.save();\n      }\n      else {\n        new Schema2({\n          Guild: interaction.guild.id,\n          User: user.id,\n          Weekly: Date.now()\n        }).save();\n      }\n\n      client.addMoney(interaction, user, amount);\n    }\n  })\n}\n\n ","size_bytes":1291},"src/commands/economy/withdraw.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/economy\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    let amount = interaction.options.getNumber('amount');\n    let user = interaction.user;\n\n    if (!amount) return client.errUsage({ usage: \"withdraw [amount]\", type: 'editreply' }, interaction);\n\n    if (isNaN(amount)) return client.errNormal({ error: \"Enter a valid number!\", type: 'editreply' }, interaction);\n\n    if (amount < 0) return client.errNormal({ error: `You can't withdraw negative money!`, type: 'editreply' }, interaction);\n\n    Schema.findOne({ Guild: interaction.guild.id, User: user.id }, async (err, data) => {\n        if (data) {\n            if (data.Bank === 0) return client.errNormal({ error: `You have nothing left in the bank!`, type: 'editreply' }, interaction);\n\n            let money = parseInt(amount);\n\n            data.Money += money;\n            data.Bank -= money;\n            data.save();\n\n            client.succNormal({\n                text: `You've have withdrawn some money from your bank!`,\n                fields: [\n                    {\n                        name: `${client.emotes.economy.coins}┆Amount`,\n                        value: `$${amount}`,\n                        inline: true\n                    }\n                ],\n                type: 'editreply'\n            }, interaction);\n        }\n        else {\n            client.errNormal({ text: `You don't have any money to withdraw!`, type: 'editreply' }, interaction);\n        }\n    })\n}\n ","size_bytes":1552},"src/commands/economy/work.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/economy\");\nconst Schema2 = require(\"../../database/models/economyTimeout\");\n\nmodule.exports = async (client, interaction, args) => {\n  let user = interaction.user;\n  let timeout = 600000;\n\n  Schema2.findOne({ Guild: interaction.guild.id, User: user.id }, async (err, dataTime) => {\n    if (dataTime && dataTime.Work !== null && timeout - (Date.now() - dataTime.Work) > 0) {\n      let time = (dataTime.Work / 1000 + timeout / 1000).toFixed(0);\n      return client.errWait({\n        time: time,\n        type: 'editreply'\n      }, interaction);\n    }\n    else {\n      let replies = ['Programmer', 'Hacker', 'Waiter', 'Busboy', 'Chief', 'Mechanic']\n\n      let result = Math.floor((Math.random() * replies.length));\n      let amount = Math.floor(Math.random() * 100) + 1;\n\n      client.succNormal({ text: `You worked as a ${replies[result]} and earned: **${client.emotes.economy.coins} $${amount}**`, type: 'editreply' }, interaction);\n\n      client.succNormal({\n        text: `You've wokred and earned some money!`,\n        fields: [\n          {\n            name: `🦹‍♂️┆Crime`,\n            value: `${replies[result]}`,\n            inline: true\n          },\n          {\n            name: `${client.emotes.economy.coins}┆Earned`,\n            value: `$${amount}`,\n            inline: true\n          }\n        ],\n        type: 'editreply'\n      }, interaction);\n\n      if (dataTime) {\n        dataTime.Work = Date.now();\n        dataTime.save();\n      }\n      else {\n        new Schema2({\n          Guild: interaction.guild.id,\n          User: user.id,\n          Work: Date.now()\n        }).save();\n      }\n\n      client.addMoney(interaction, user, amount);\n    }\n  })\n}\n\n ","size_bytes":1764},"src/commands/economy/yearly.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/economy\");\nconst Schema2 = require(\"../../database/models/economyTimeout\");\n\nmodule.exports = async (client, interaction, args) => {\n  let user = interaction.user;\n  let timeout = 31557600000;\n  let amount = 5000;\n\n  Schema2.findOne({ Guild: interaction.guild.id, User: user.id }, async (err, dataTime) => {\n    if (dataTime && dataTime.Yearly !== null && timeout - (Date.now() - dataTime.Yearly) > 0) {\n      let time = (dataTime.Yearly / 1000 + timeout / 1000).toFixed(0);\n      return client.errWait({\n        time: time,\n        type: 'editreply'\n      }, interaction);\n    }\n    else {\n      client.succNormal({\n        text: `You've collected your yearly reward of **${client.emotes.economy.coins} $${amount}**`,\n        type: 'editreply'\n      }, interaction);\n\n      client.succNormal({\n        text: `You've collected your yearly reward!`,\n        fields: [\n          {\n            name: `${client.emotes.economy.coins}┆Earned`,\n            value: `$${amount}`,\n            inline: true\n          }\n        ],\n        type: 'editreply'\n      }, interaction);\n\n      if (dataTime) {\n        dataTime.Yearly = Date.now();\n        dataTime.save();\n      }\n      else {\n        new Schema2({\n          Guild: interaction.guild.id,\n          User: user.id,\n          Yearly: Date.now()\n        }).save();\n      }\n\n      client.addMoney(interaction, user, amount);\n    }\n  })\n}\n\n ","size_bytes":1471},"src/commands/family/adopt.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/family\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    const target = interaction.options.getUser('user');\n    const author = interaction.user;\n\n    if (author.id == target.id) return client.errNormal({\n        error: \"You cannot adopt yourself\",\n        type: 'editreply'\n    }, interaction);\n\n    if (target.bot) return client.errNormal({\n        error: \"You cannot adopt a bot\",\n        type: 'editreply'\n    }, interaction);\n\n    const familyMember = await Schema.findOne({ Guild: interaction.guild.id, User: target.id, Parent: author.id });\n    const familyMember2 = await Schema.findOne({ Guild: interaction.guild.id, User: author.id, Parent: target.id });\n    const familyMember3 = await Schema.findOne({ Guild: interaction.guild.id, User: author.id, Partner: target.id });\n\n    if (familyMember || familyMember2 || familyMember3) {\n        return client.errNormal({\n            error: `You cannot adopt a family member!`,\n            type: 'editreply'\n        }, interaction);\n    }\n\n    const checkAdopt = await Schema.findOne({ Guild: interaction.guild.id, Children: target.username });\n    if (checkAdopt) {\n        return client.errNormal({\n            error: `This user has already been adopted`,\n            type: 'editreply'\n        }, interaction);\n    }\n\n    const row = new Discord.ActionRowBuilder()\n        .addComponents(\n            new Discord.ButtonBuilder()\n                .setCustomId('adopt_yes')\n                .setEmoji('✅')\n                .setStyle(Discord.ButtonStyle.Success),\n\n            new Discord.ButtonBuilder()\n                .setCustomId('adopt_deny')\n                .setEmoji('❌')\n                .setStyle(Discord.ButtonStyle.Danger),\n        );\n\n    client.embed({\n        title: `👪・Adoption`,\n        desc: `${author} has ${target} asked to adopt him! \\n${target} click on one of the buttons`,\n        components: [row],\n        content: `${target}`,\n        type: 'editreply',\n    }, interaction)\n\n    const filter = i => i.user.id === target.id;\n\n    interaction.channel.awaitMessageComponent({ filter, componentType: Discord.ComponentType.Button, time: 60000 }).then(async i => {\n        if (i.customId == \"adopt_yes\") {\n\n            Schema.findOne({ Guild: interaction.guild.id, User: author.id }, async (err, data) => {\n                if (data) {\n                    data.Children.push(target.username);\n                    data.save();\n                }\n                else {\n                    new Schema({\n                        Guild: interaction.guild.id,\n                        User: author.id,\n                        Children: target.username\n                    }).save();\n                }\n            })\n\n            Schema.findOne({ Guild: interaction.guild.id, User: target.id }, async (err, data) => {\n                if (data) {\n                    data.Parent.push(author.username);\n                    data.save();\n                }\n                else {\n                    new Schema({\n                        Guild: interaction.guild.id,\n                        User: target.id,\n                        Parent: author.username\n                    }).save();\n                }\n            })\n\n            client.embed({\n                title: `👪・Adoption - Approved`,\n                desc: `${author} is now the proud parent of ${target}! 🎉`,\n                components: [],\n                type: 'editreply'\n            }, interaction);\n        }\n\n        if (i.customId == \"adopt_deny\") {\n            client.embed({\n                title: `👪・Adoption - Denied`,\n                desc: `${target} don't want to be adopted by ${author}`,\n                components: [],\n                type: 'editreply'\n            }, interaction);\n        }\n    }).catch(() => {\n        client.embed({\n            title: `👪・Adoption - Denied`,\n            desc: `${target} has not answered anything! The adoption is canceled`,\n            components: [],\n            type: 'editreply'\n        }, interaction);\n    });\n}\n\n ","size_bytes":4115},"src/commands/family/delete.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/family\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    const row = new Discord.ActionRowBuilder()\n        .addComponents(\n            new Discord.ButtonBuilder()\n                .setCustomId('family_delete')\n                .setEmoji('✅')\n                .setStyle(Discord.ButtonStyle.Success),\n\n            new Discord.ButtonBuilder()\n                .setCustomId('family_stop')\n                .setEmoji('❌')\n                .setStyle(Discord.ButtonStyle.Danger),\n        );\n\n    client.embed({\n        title: `${client.emotes.normal.error}・Reset family`,\n        desc: `Are you sure you want to reset your family?`,\n        components: [row],\n        type: 'editreply'\n    }, interaction);\n\n    const filter = i => i.user.id === interaction.user.id;\n\n    interaction.channel.awaitMessageComponent({ filter, time: 60000 })\n        .then(async i => {\n            if (i.customId == \"family_delete\") {\n                i.message.delete();\n\n                var remove = await Schema.findOneAndDelete({ Guild: interaction.guild.id, User: interaction.user.id });\n                const parent = await Schema.findOne({ Guild: interaction.guild.id, Parent: interaction.user.id });\n                const partner = await Schema.findOne({ Guild: interaction.guild.id, Partner: interaction.user.id });\n\n                if (parent) {\n                    parent.Parent = \" \";\n                    parent.save();\n                }\n\n                if (partner) {\n                    partner.Partner = \" \";\n                    partner.save();\n                }\n\n                client.succNormal({ text: `Your family has been deleted!`, type: 'editreply' }, interaction);\n            }\n\n            if (i.customId == \"family_stop\") {\n                i.message.delete();\n            }\n        })\n        .catch((err) => {\n            console.log(err)\n            client.errNormal({ error: \"Time's up! Cancelled backup loading!\", type: 'editreply' }, interaction);\n        });\n}\n\n ","size_bytes":2071},"src/commands/family/disown.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/family\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    const target = interaction.options.getUser('user');\n    const author = interaction.user;\n    const guild = { Guild: interaction.guild.id };\n\n    if (author.id == target.id) return client.errNormal({\n        error: \"You cannot disown yourself\",\n        type: 'editreply'\n    }, interaction);\n\n    if (target.bot) return client.errNormal({\n        error: \"You cannot disown a bot\",\n        type: 'editreply'\n    }, interaction);\n\n    Schema.findOne({ Guild: interaction.guild.id, Parent: target.id }, async (err, data) => {\n        if (data) {\n            Schema.findOne({ Guild: interaction.guild.id, User: data.Parent }, async (err, data2) => {\n                if (data2) {\n                    client.embed({ title: `👪・Disowned`, desc: `${author} has disowned <@!${data.Parent}>`, type: 'editreply' }, interaction);\n\n                    data.Parent = null;\n                    data.save();\n                }\n            })\n        }\n        else {\n            Schema.findOne({ Guild: interaction.guild.id, User: author.id }, async (err, data) => {\n                if (data) {\n                    if (data.Children.includes(target.username)) {\n                        const filtered = data.Children.filter((user) => user !== target.username);\n\n                        await Schema.findOneAndUpdate(guild, {\n                            Guild: interaction.guild.id,\n                            User: author.id,\n                            Children: filtered\n                        });\n\n                        Schema.findOne({ Guild: interaction.guild.id, Parent: author.id }, async (err, data) => {\n                            if (data) {\n                                data.Parent = null;\n                                data.save();\n                            }\n                        })\n\n                        client.embed({ title: `👪・Disowned`, desc: `${author} has disowned <@!${target.id}>`, type: 'editreply' }, interaction);\n                    }\n                    else {\n                        client.errNormal({ error: \"You have no children/parents at the moment\", type: 'editreply' }, interaction);\n                    }\n                }\n                else {\n                    client.errNormal({ error: \"You have no children/parents at the moment\", type: 'editreply' }, interaction);\n                }\n            })\n        }\n    })\n}\n\n ","size_bytes":2529},"src/commands/family/divorce.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/family\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    const target = interaction.options.getUser('user');\n    const author = interaction.user;\n\n    if (author.id == target.id) return client.errNormal({\n        error: \"You cannot divorce yourself\",\n        type: 'editreply'\n    }, interaction);\n\n    if (target.bot) return client.errNormal({\n        error: \"You cannot divorce a bot\",\n        type: 'editreply'\n    }, interaction);\n\n    const data = await Schema.findOne({ Guild: interaction.guild.id, User: author.id, Partner: target.id });\n    if (data) {\n        const data2 = await Schema.findOne({ Guild: interaction.guild.id, User: target.id });\n        if (data2) {\n            data2.Partner = null;\n            data2.save();\n        }\n\n        data.Partner = null;\n        data.save();\n\n        client.embed({ \n            title: `👰・Divorced`, \n            desc: `${author} and ${target} have been divorced`, \n            type: 'editreply' \n        }, interaction);\n\n    }\n    else {\n        client.errNormal({ \n            error: \"You are not married at the moment\", \n            type: 'editreply' \n        }, interaction);\n    }\n}\n\n ","size_bytes":1252},"src/commands/family/family.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/family\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    const target = interaction.options.getUser('user') || interaction.user;\n\n    const data = await Schema.findOne({ Guild: interaction.guild.id, User: target.id });\n\n    client.embed({\n        title: `👪・${target.username}'s Family`,\n        thumbnail: target.avatarURL({ size: 1024 }),\n        fields: [\n            {\n                name: `Partner`,\n                value: `${data && data.Partner ? `<@!${data.Partner}>` : `This user is not married`}`\n            },\n            {\n                name: `Parent`,\n                value: `${data && data.Parent.length > 0 ? `${data.Parent.join(\", \")}` : `This user has no parents`}`\n            },\n            {\n                name: `Children`,\n                value: `${data && data.Children.length > 0 ? `${data.Children.join(\", \")}` : `This user has no children`}`\n            }\n        ],\n        type: 'editreply'\n    }, interaction)\n}\n\n ","size_bytes":1053},"src/commands/family/propose.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/family\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    const target = interaction.options.getUser('user');\n    const author = interaction.user;\n    const guild = { Guild: interaction.guild.id };\n\n    if (author.id == target.id) return client.errNormal({ error: \"You cannot marry yourself!\", type: 'editreply' }, interaction);\n\n    Schema.findOne({ Guild: interaction.guild.id, Partner: author.id }, async (err, data) => {\n        if (data) {\n            client.errNormal({ error: \"Someone in the couple is already married!\", type: 'editreply' }, interaction);\n        }\n        else {\n            Schema.findOne({ Guild: interaction.guild.id, Partner: target.id }, async (err, data) => {\n                if (data) {\n                    client.errNormal({ error: \"Someone in the couple is already married!\", type: 'editreply' }, interaction);\n                }\n                else {\n                    Schema.findOne({ Guild: interaction.guild.id, User: target.id, Parent: author.id }, async (err, data) => {\n                        if (data) {\n                            client.errNormal({ error: \"You cannot marry a family member!\", type: 'editreply' }, interaction);\n                        }\n                        else {\n                            Schema.findOne({ Guild: interaction.guild.id, User: author.id, Parent: target.id }, async (err, data) => {\n                                if (data) {\n                                    client.errNormal({ error: \"You cannot marry a family member!\", type: 'editreply' }, interaction);\n                                }\n                                else {\n                                    Schema.findOne({ Guild: interaction.guild.id, User: author.id }, async (err, data) => {\n                                        if (data) {\n                                            if (data.Children.includes(target.id)) {\n                                                client.errNormal({ error: \"You cannot marry a family member!\", type: 'editreply' }, interaction);\n                                            }\n                                            else {\n                                                propose();\n                                            }\n                                        }\n                                        else {\n                                            propose();\n                                        }\n                                    })\n                                }\n                            })\n                        }\n                    })\n                }\n            })\n        }\n    })\n\n    function propose() {\n        const row = new Discord.ActionRowBuilder()\n            .addComponents(\n                new Discord.ButtonBuilder()\n                    .setCustomId('propose_accept')\n                    .setEmoji('✅')\n                    .setStyle(Discord.ButtonStyle.Success),\n\n                new Discord.ButtonBuilder()\n                    .setCustomId('propose_deny')\n                    .setEmoji('❌')\n                    .setStyle(Discord.ButtonStyle.Danger),\n            );\n\n        client.embed({\n            title: `👰・Marriage proposal`,\n            desc: `${author} has ${target} asked to propose him! \\n${target} click on one of the buttons`,\n            components: [row],\n            content: `${target}`,\n            type: 'editreply'\n        }, interaction);\n\n        const filter = i => i.user.id === target.id;\n\n        interaction.channel.awaitMessageComponent({ filter, componentType: Discord.ComponentType.Button, time: 60000 }).then(async i => {\n            if (i.customId == \"propose_accept\") {\n\n                Schema.findOne({ Guild: interaction.guild.id, User: author.id }, async (err, data) => {\n                    if (data) {\n                        data.Partner = target.id\n                        data.save();\n                    }\n                    else {\n                        new Schema({\n                            Guild: interaction.guild.id,\n                            User: author.id,\n                            Partner: target.id\n                        }).save();\n                    }\n                })\n\n                Schema.findOne({ Guild: interaction.guild.id, User: target.id }, async (err, data) => {\n                    if (data) {\n                        data.Partner = author.id\n                        data.save();\n                    }\n                    else {\n                        new Schema({\n                            Guild: interaction.guild.id,\n                            User: target.id,\n                            Partner: author.id\n                        }).save();\n                    }\n                })\n\n                client.embed({\n                    title: `👰・Marriage proposal - Approved`,\n                    desc: `${author} and ${target} are now married! 👰🎉`,\n                    components: [],\n                    content: `${target}`,\n                    type: 'editreply'\n                }, interaction);\n            }\n\n            if (i.customId == \"propose_deny\") {\n                client.embed({\n                    title: `👰・Marriage proposal - Denied`,\n                    desc: `${target} loves someone else and chose not to marry ${author}`,\n                    components: [],\n                    content: `${target}`,\n                    type: 'editreply'\n                }, interaction);\n            }\n        }).catch(() => {\n            client.embed({\n                title: `👰・Marriage proposal - Denied`,\n                desc: `${target} has not answered anything! The wedding is canceled`,\n                components: [],\n                content: `${target}`,\n                type: 'editreply'\n            }, interaction);\n        });\n    }\n}\n\n ","size_bytes":5918},"src/commands/fun/ascii.js":{"content":"const Discord = require('discord.js');\nconst figlet = require('figlet');\n\nmodule.exports = async (client, interaction, args) => {\n    const msg = interaction.options.getString('text');\n\n    if (msg.length > 2000) return client.errNormal({ error: \"Please provide text shorter than 2000 character!\", type: 'editreply' }, interaction);\n\n    figlet.text(msg, function (err, data) {\n\n        if (err) {\n            return client.errNormal({ error: \"Something went wrong!\", type: 'editreply' }, interaction);\n        }\n\n        client.embed({\n            title: '💬・Ascii',\n            desc: `\\`\\`\\` ${data} \\`\\`\\``,\n            type: 'editreply',\n        }, interaction);\n    })\n}\n\n ","size_bytes":682},"src/commands/fun/birdfact.js":{"content":"const Discord = require('discord.js');\nconst fetch = require(\"node-fetch\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    fetch(\n        `https://some-random-api.ml/facts/bird`\n    )\n        .then((res) => res.json()).catch({})\n        .then(async (json) => {\n            client.embed({\n                title: `💡・Random bird fact`,\n                desc: json.fact,\n                type: 'editreply',\n            }, interaction);\n        }).catch({})\n}\n\n ","size_bytes":475},"src/commands/fun/catfact.js":{"content":"const Discord = require('discord.js');\nconst fetch = require(\"node-fetch\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    fetch(\n        `https://some-random-api.ml/facts/cat`\n    )\n        .then((res) => res.json()).catch({})\n        .then(async (json) => {\n            client.embed({\n                title: `💡・Random cat fact`,\n                desc: json.fact,\n                type: 'editreply',\n            }, interaction);\n        }).catch({})\n}\n\n ","size_bytes":473},"src/commands/fun/cleverrate.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    var result = Math.ceil(Math.random() * 100);\n\n    client.embed({\n        title: `💡・Clever Rate`,\n        desc: `You are ${result}% clever!`,\n        type: 'editreply'\n    }, interaction)\n}\n\n ","size_bytes":258},"src/commands/fun/confused.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    client.embed({\n        title: '😲・Confused Nick',\n        image: \"https://cdn.discordapp.com/attachments/825305196355780628/836154426481704980/nick-young-confused-face-300x256-nqlyaa.png\",\n        type: 'editreply'\n    }, interaction)\n}\n\n ","size_bytes":305},"src/commands/fun/dinochrome.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    let msg = await interaction.editReply({ content: `---------------🦖`, fetchReply: true });\n    let time = 1 * 1000;\n    setTimeout(function () {\n        interaction.editReply(`-----------🦖----`);\n    }, time);\n    time += 1.5 * 1000;\n\n    setTimeout(function () {\n        interaction.editReply(`----------🦖------`);\n    }, time);\n    time += 1.5 * 1000;\n\n    setTimeout(function () {\n        interaction.editReply(`--------🦖--------`);\n    }, time);\n    time += 1.5 * 1000;\n\n    setTimeout(function () {\n        interaction.editReply(`------🦖-----------`);\n    }, time);\n    time += 1.5 * 1000;\n\n    setTimeout(function () {\n        interaction.editReply(`-------🦖-----------`);\n    }, time);\n    time += 1.5 * 1000;\n\n    setTimeout(function () {\n        interaction.editReply(`---🌵-----🦖---------`);\n    }, time);\n    time += 1.5 * 1000;\n\n    setTimeout(function () {\n        interaction.editReply(`---🌵-🦖-------------`);\n    }, time);\n    time += 1.5 * 1000;\n\n    setTimeout(function () {\n        interaction.editReply(`🦖\\n ---🌵--------------`);\n    }, time);\n    time += 1.5 * 1000;\n\n    setTimeout(function () {\n        interaction.editReply(`------🦖---🌵--------------`);\n    }, time);\n    time += 1.5 * 1000;\n\n    setTimeout(function () {\n        interaction.editReply(`----🦖-----🌵----------------`);\n    }, time);\n    time += 1.5 * 1000;\n\n    setTimeout(function () {\n        interaction.editReply(`-🌵🌵-----🦖-------🌵--------`);\n    }, time);\n    time += 1.5 * 1000;\n\n    setTimeout(function () {\n        interaction.editReply(`----🌵🌵-🦖----------🌵------`);\n    }, time);\n    time += 1.5 * 1000;\n\n    setTimeout(function () {\n        interaction.editReply(`🦖\\n ---🌵🌵-------------🌵---`);\n    }, time);\n    time += 1.5 * 1000;\n\n    setTimeout(function () {\n        interaction.editReply(`-----🦖---🌵🌵-------------🌵--`);\n    }, time);\n    time += 1.5 * 1000;\n\n    setTimeout(function () {\n        interaction.editReply(`-------🦖-----🌵🌵-------------`);\n    }, time);\n    time += 1.5 * 1000;\n\n    setTimeout(function () {\n        interaction.editReply(`🎂----🦖--------🌵🌵-----------`);\n    }, time);\n    time += 1.5 * 1000;\n\n    setTimeout(function () {\n        interaction.editReply(`---🎂--🦖----------🌵🌵---------`);\n    }, time);\n    time += 1.5 * 1000;\n\n    setTimeout(function () {\n        interaction.editReply(`**Ⓜⓘⓢⓢⓘⓞⓝ Ⓒⓞⓜⓟⓛⓔⓣⓔⓓ !**\\n ---🎂🦖----------🌵🌵-------------`);\n    }, time);\n}\n\n ","size_bytes":2624},"src/commands/fun/dogfact.js":{"content":"const Discord = require('discord.js');\nconst fetch = require(\"node-fetch\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    fetch(\n        `https://some-random-api.ml/facts/dog`\n    )\n        .then((res) => res.json()).catch({})\n        .then(async (json) => {\n            client.embed({\n                title: `💡・Random dog fact`,\n                desc: json.fact,\n                type: 'editreply',\n            }, interaction);\n        }).catch({})\n}\n\n ","size_bytes":473},"src/commands/fun/epicgamerrate.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n    var result = Math.ceil(Math.random() * 100);\n\n    client.embed({\n        title: `🎮・Epic gamer rate`,\n        desc: `You are ${result}% epic gamer!`,\n        type: 'editreply'\n    }, interaction)\n}\n\n ","size_bytes":265},"src/commands/fun/fact.js":{"content":"const Discord = require('discord.js');\nconst request = require('request');\n\nmodule.exports = async (client, interaction, args) => {\n\n    var url = 'https://uselessfacts.jsph.pl/random.json?language=en'\n\n\n    request(url, function (err, response, body) {\n        fact = JSON.parse(body).text;\n\n        client.embed({\n            title: `😂・Fact`,\n            desc: fact,\n            type: 'editreply',\n        }, interaction);\n    })\n}\n\n ","size_bytes":441},"src/commands/fun/gif.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    const msg = interaction.options.getString('text');\n\n    if (!msg) return client.errUsage({ usage: \"gif [text]\", type: 'editreply' }, interaction);\n\n    var giphy = require('giphy-api')(process.env.GIPHY_TOKEN);\n\n    giphy.random(msg, function (err, res) {\n        client.embed({\n            title: `📺・${msg} Gif`,\n            image: `https://media1.giphy.com/media/${res.data.id}/giphy.gif`,\n            type: 'editreply'\n        }, interaction);\n    });\n}\n\n ","size_bytes":564},"src/commands/fun/hack.js":{"content":"const fetch = require(\"node-fetch\");\nconst generator = require('generate-password');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const password = generator.generate({\n        length: 10,\n        symbols: true,\n        numbers: true\n    });\n\n    const user = interaction.options.getUser('user');\n\n    if (!user) return client.errUsage({ usage: \"hack [mention user]\", type: 'editreply' }, interaction)\n\n    function wait(ms) {\n        let start = new Date().getTime();\n        let end = start;\n        while (end < start + ms) {\n            end = new Date().getTime();\n        }\n    }\n\n    client.embed({\n        title: '💻・Hacking',\n        desc: `The hack on ${user} started...`,\n        type: 'editreply'\n    }, interaction).then(msg => {\n\n        wait(140);\n        client.embed({\n            title: '💻・Hacking',\n            desc: `Searching for user information..`,\n            type: 'edit',\n        }, msg).then(i => {\n\n            wait(133);\n            client.embed({\n                title: '💻・Hacking',\n                desc: `Searching for IP address...`,\n                type: 'edit',\n            }, msg).then(i => {\n\n                wait(140);\n                client.embed({\n                    title: '💻・Hacking',\n                    desc: `The users ip address was found!`,\n                    fields: [\n                        {\n                            name: '🔗┆IP Adress',\n                            value: `\\`\\`\\`127.0.0.1\\`\\`\\``,\n                            inline: true,\n                        }\n                    ],\n                    type: 'edit',\n                }, msg).then(i => {\n\n                    wait(60);\n                    client.embed({\n                        title: '💻・Hacking',\n                        desc: `Searching for Discord login...`,\n                        type: 'edit',\n                    }, msg).then(i => {\n\n                        wait(230);\n                        client.embed({\n                            title: '💻・Hacking',\n                            desc: `The users discord login was found!`,\n                            fields: [\n                                {\n                                    name: '📨┆Email',\n                                    value: `\\`\\`\\`${user.username}onDiscord@gmail.com\\`\\`\\``\n                                },\n                                {\n                                    name: '🔑┆Password',\n                                    value: `\\`\\`\\`${password}\\`\\`\\``\n                                }\n                            ],\n                            type: 'edit',\n                        }, msg).then(i => {\n\n                            wait(200);\n                            client.embed({\n                                title: '💻・Hacking',\n                                desc: `Search for Discord token...`,\n                                type: 'edit'\n                            }, msg).then(i => {\n\n                                wait(200);\n                                fetch(`https://some-random-api.ml/bottoken?${user.id}`).then((res) => res.json()).catch({}).then(async (json) => {\n                                    client.embed({\n                                        title: '💻・Hacking',\n                                        desc: `The users discord account token was found!`,\n                                        fields: [\n                                            {\n                                                name: '🔧┆Token',\n                                                value: `\\`\\`\\`${json.token}\\`\\`\\``,\n                                                inline: true\n                                            }\n                                        ],\n                                        type: 'edit',\n                                    }, msg).then(i => {\n\n                                        wait(140);\n                                        client.embed({\n                                            title: '💻・Hacking',\n                                            desc: `Reporting account to Discord for breaking TOS...`,\n                                            type: 'edit',\n                                        }, msg).then(i => {\n\n                                            wait(180);\n                                            client.succNormal({ text: `${user} is succesfully hacked. All the user's information was send to your dm`, type: 'edit' }, msg);\n                                            client.embed({\n                                                title: '😂・Pranked',\n                                                image: \"https://media1.tenor.com/images/05006ed09075a0d6965383797c3cea00/tenor.gif?itemid=17987788\",\n                                            }, interaction.user)\n                                        })\n                                    })\n                                }).catch({})\n                            })\n                        })\n                    })\n                })\n            })\n        })\n    })\n\n}\n\n ","size_bytes":5130},"src/commands/fun/howgay.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n    var result = Math.ceil(Math.random() * 100);\n\n    client.embed({\n        title: `🏳️‍🌈・Gay rate`,\n        desc: `You are ${result}% gay!`,\n        type: 'editreply'\n    }, interaction)\n}\n\n ","size_bytes":261},"src/commands/fun/hug.js":{"content":"const axios = require('axios');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const user = interaction.options.getUser('user');\n    const url = 'https://some-random-api.ml/animu/hug';\n\n    if (!user) return client.errUsage({ usage: \"hug [mention user]\", type: 'editreply' }, interaction);\n\n    let response, data;\n    try {\n        response = await axios.get(url);\n        data = response.data;\n    } catch (e) {\n        return client.errNormal({ error: \"An error occured!\", type: 'editreply' }, interaction);\n    }\n\n    client.embed({\n        title: `${interaction.user.tag} hugs ${user.tag}`,\n        image: `${data.link}`,\n        type: 'editreply'\n    }, interaction);\n}\n\n     ","size_bytes":697},"src/commands/fun/kill.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    const user = interaction.options.getUser('user');\n\n    if (!user) return client.errUsage({ usage: \"hug [mention user]\", type: 'editreply' }, interaction);\n\n    var kills = [\n        ` after a long day, plops down on the couch with ${user} and turns on The Big Bang Theory. After a Sheldon Cooper joke, ${user} laughs uncontrollably as they die.`,\n        `${interaction.user} Alt+F4'd ${user}.exe!`,\n        `${interaction.user} attempted to play a flute, exploding the head of ${user}.`,\n        `${interaction.user} blew his ear drums out listening to music too hard.`,\n        `${interaction.user} challenges ${user} to a fist fight to the death. ${user} wins.`,\n        `${interaction.user} cleaves the head of ${user} with a keyboard.`,\n        `${interaction.user} crushes ${user} with a fridge.`,\n        `${interaction.user} decapitates ${user} with a sword.`,\n        `${interaction.user} drags ${user}s ears too hard and rips them off.`,\n        `${interaction.user} drowns ${user} in a beer barrel.`,\n        `${interaction.user} drowns ${user} in a tub of hot chocolate. *How was your last drink?*`,\n        `${interaction.user} eviscerates ${user} with a rusty butter knife. Ouch!`,\n        `${interaction.user} feeds toothpaste-filled oreos to ${user}, who were apparently allergic to fluorine. GGWP.`,\n        `${interaction.user} fell in love with ${user} then broke his heart literally.`,\n        `${interaction.user} fires a supersonic frozen turkey at ${user}, killing them instantly.`,\n        `${interaction.user} forgot to leave the car door window open and ${user} dies from overheating`,\n        `${interaction.user} forgot to zombie-proof ${user} lawn... Looks like zombies had a feast last night.`,\n        `${interaction.user} gets ${user} to watch anime with them. ${user} couldn't handle it.`,\n        `${interaction.user} grabs ${user} and shoves them into an auto-freeze machine with some juice and sets the temperature to 100 Kelvin, creating human ice pops.`,\n        `${interaction.user} hired me to kill you, but I don't want to! ${user}`,\n        `${interaction.user} hugs ${user} too hard..`,\n        `${interaction.user} hulk smashes ${user} into a pulp.`,\n        `${interaction.user} killed ${user} by ripping the skin off of their face and making a mask out of it.`,\n        `${interaction.user} kills ${user} after hours of torture.`,\n        `${interaction.user} kills ${user} with a candlestick in the study`,\n        `${interaction.user} kills ${user} with kindness`,\n        `${interaction.user} kills ${user} with their own foot.`,\n        `${interaction.user} murders ${user} with an axe.`,\n        `${interaction.user} pressed delete. It deleted ${user}`,\n        `${interaction.user} pushes ${user} into the cold vacuum of space.`,\n        `${interaction.user} runs ${user} over with a PT Cruiser.`,\n        `${interaction.user} shoots ${user} in the head.`,\n        `${interaction.user} shoots in ${user} mouth with rainbow laser, causing ${user} head to explode with rainbows and ${user} is reborn as unicorn. :unicorn:`,\n        `${interaction.user} shot ${user} using the Starkiller Base!`,\n        `${interaction.user} slips bleach into ${user}'s lemonade.`,\n        `${interaction.user} strangles ${user}.`,\n        `${interaction.user} straps ${user} to an ICBM and sends them to North Korea along with it.`,\n        `${interaction.user} strikes ${user} with the killing curse... *Avada Kedavra!*`,\n        `${interaction.user} tears off ${user}s lips after a kiss.`,\n        `${interaction.user} thicc and collapses ${user}'s rib cage`,\n        `${interaction.user} tries to shoot the broad side of a barn, misses and hits ${user} instead.`,\n        `${interaction.user} turns on Goosebumps(2015 film) on the TV. ${user} being a scaredy-cat, dies of an heart attack.`,\n        `${interaction.user} was so swag that ${user} died due to it. #Swag`,\n        `${interaction.user}, are you sure you want to kill ${user}? They seem nice to me.`,\n        `${user} accidentally clicked on a popup ad that reads \\`Doctors hate us, see the one best trick for dying today!\\``,\n        `${user} accidentally tripped and died while getting up to write their suicide note.`,\n        `${user} ate a piece of exotic butter. It was so amazing that it killed them.`,\n        `${user} ate an apple and turned out it was made out of wax. Someone died from wax poisoning later that day.`,\n        `${user} ate too many laxatives and drowned in their own shit. Ew.`,\n        `${user} bleeds out after trying to get on \\`Dumbest hillbilly moments\\`.`,\n        `${user} bought a fidget spinner and drowned in pussy.`,\n        `${user} can't be killed, as they are a ghost.`,\n        `${user} chokes in a trash can.`,\n        `${user} chokes on a chicken bone.`,\n        `${user} chokes on cheerios and dies. What an idiot...`,\n        `${user} cranks up the music system only to realize the volume was at max and the song playing was Baby by Justin Beiber...`,\n        `${user} cums in eye, goes blind, runs for help but ran straight onto train tracks and gets plowed by a train.`,\n        `${user} decided it was a good idea to fight a tiger while smelling like meat. It did not end well.`,\n        `${user} did not make a meme dank enough and was stoned.`,\n        `${user} died after fapping 50 times in a row with no break.`,\n        `${user} died after gaming for 90 hours straight without moving or eating.`,\n        `${user} died after playing with an edgy razor blade fidget spinner.`,\n        `${user} died after realizing how shitty their grammar was`,\n        `${user} died after trying to out-meme Dank Memer.`,\n        `${user} died an honorable death. Death by snoo snoo.`,\n        `${user} died because RemindMeBot forgot to remind them to breathe`,\n        `${user} died because they started playing with a fidget spinner but they realise its 2016 so you start fapping to the old witch in snow white and obama starts mowing their lawn and they jump out of the window and get ripped to pieces by Obama's lawn mower`,\n        `${user} died due to ${interaction.user} being so stupid`,\n        `${user} died due to eating WAY too many hotdogs in preparation for their date Friday night.`,\n        `${user} died eating expired and infected raw fish with the filthiest rice in the world as sushi while being constantly stabbed in the scrotum with a 9inch nail sharp enough to stab through kevlar. The soy sauce was cat piss.`,\n        `${user} died from a high salt intake`,\n        `${user} died from a swift kick to the brain.`,\n        `${user} died from a tragic amount of bad succ`,\n        `${user} died from doing the ice bucket challenge.`,\n        `${user} died from drinking too much water Huh, I guess it IS possible!.`,\n        `${user} died from eating cactus needles.`,\n        `${user} died from eating too much ass.`,\n        `${user} died from eating too much bread :/`,\n        `${user} died from ebola.`,\n        `${user} died from meme underdose :/`,\n        `${user} died from not eating enough ass.`,\n        `${user} died from not whacking it enough. (There's a healthy balance, boys)`,\n        `${user} died from reposting in the wrong neighborhood`,\n        `${user} died from shitting for 36 hours straight.`,\n        `${user} died from swallowing rocks too fast`,\n        `${user} died from too many sunburns.`,\n        `${user} died from whacking it too much. (There's a healthy balance, boys)`,\n        `${user} died of oversucc`,\n        `${user} died when testing a hydrogen bomb. There is nothing left to bury.`,\n        `${user} died while listening to 'It's every day bro'`,\n        `${user} died while playing hopscotch on *seemingly* deactivated land mines.`,\n        `${user} died while trying to find the city of England`,\n        `${user} died. OOF`,\n        `${user} dies after swallowing a toothpick.`,\n        `${user} dies at the hands of ${interaction.user}.`,\n        `${user} dies because they used a bobby pin to lift their eyelashes`,\n        `${user} dies because they were just too angry.`,\n        `${user} dies by swearing on a Christian Minecraft server`,\n        `${user} dies due to lack of friends.`,\n        `${user} dies from bad succ.`,\n        `${user} dies from dabbing too hard.`,\n        `${user} dies from dabbing too hard`,\n        `${user} dies from disrespecting wahmen.`,\n        `${user} dies from just being a bad, un-likeable dude.`,\n        `${user} dies from posting normie memes.`,\n        `${user} dies from severe dislike of sand. It's coarse and rough and irritating it gets everywhere`,\n        `${user} dies from watching the emoji movie and enjoying it.`,\n        `${user} dies in a horrible accident, and it was engineered by ${interaction.user}.`,\n        `${user} dies north of the wall and transforms into a white walker`,\n        `${user} dies of AIDS.`,\n        `${user} dies of dysentery.`,\n        `${user} dies of natural causes.`,\n        `${user} dies of starvation.`,\n        `${user} dies on death row via lethal injection after murdering ${interaction.user} and their family.`,\n        `${user} dies, but don't let this distract you from the fact that in 1998, The Undertaker threw Mankind off Hell In A Cell, and plummeted 16 ft through an announcer’s table`,\n        `${user} dies.`,\n        `After a struggle, ${user} kills ${interaction.user}`,\n        `${user} disappeared from the universe.`,\n        `${user} drank some toxic soda before it was recalled.`,\n        `${user} dropped a Nokia phone on their face and split their skull.`,\n        `${user} drowned in their own tears.`,\n        `${user} eats too much copypasta and explodes`,\n        `${user} fell down a cliff while playing Pokemon Go. Good job on keeping your nose in that puny phone. :iphone:`,\n        `${user} fell into a pit of angry feminists.`,\n        `${user} gets hit by a car.`,\n        `${user} gets stabbed by ${interaction.user}`,\n        `${user} gets struck by lightning.`,\n        `${user} goes genocide and Sans totally dunks ${user}!`,\n        `${user} got into a knife fight with the pope. One of them is in hell now.`,\n        `${user} got stepped on by an elephant.`,\n        `${user} died from eating too much ass.`,\n        `${user} has a stroke after a sad miserable existence. They are then devoured by their ample cats.`,\n        `${user} has been found guilty, time for their execution!`,\n        `${user} has some bad chinese food, and pays the ultimate price.`,\n        `${user} is abducted by aliens, and the government kills them to cover it up.`,\n        `${user} is dead at the hands of ${interaction.user}.`,\n        `${user} is injected with chocolate syrup, which mutates them into a person made out of chocolate. While doing a part-time job at the Daycare, they are devoured by the hungry babies. :chocolate_bar:`,\n        `${user} is killed by a rabbit with a vicious streak a mile wide`,\n        `${user} is killed by their own stupidity.`,\n        `${user} is killed in a robbery gone wrong.`,\n        `${user} is not able to be killed. Oh, wait, no, ${interaction.user} kills them anyway.`,\n        `${user} is so dumb that they choked on oxygen.`,\n        `${user} is stuffed into a suit by Freddy on their night guard duty. Oh, not those animatronics again!`,\n        `${user} is sucked into Minecraft. ${user}, being a noob at the so called Real-Life Minecraft faces the Game Over screen.`,\n        `${user} killed themselves after seeing the normie memes that ${interaction.user} posts.`,\n        `${user} kills themselves after realizing how dumb ${interaction.user} is.`,\n        `${user} lives, despite ${interaction.user}'s murder attempt.`,\n        `${user} loses the will to live`,\n        `${user} presses a random button and is teleported to the height of 100m, allowing them to fall to their inevitable death. Moral of the story: Don't go around pressing random buttons.`,\n        `${user} reads memes till they die.`,\n        `${user} ripped his heart out..`,\n        `${user} ripped their own heart out to show their love for ${interaction.user}.`,\n        `${user} screams in terror as they accidentally spawn in the cthulhu while uttering random latin words. Cthulhu grabs ${user} by the right leg and takes them to his dimension yelling, \\`Honey, Dinner's ready!\\``,\n        `${user} slipped in the bathroom and choked on the shower curtain.`,\n        `${user} slips on a banana peel and falls down the stairs.`,\n        `${user} spins a fidget spinner and when it stops he dies...`,\n        `${user} steps on a george foreman and dies of waffle foot.`,\n        `${user} takes an arrow to the knee. And everywhere else.`,\n        `${user} talked back to mods and got destroyed by the ban hammer.`,\n        `${user} tips his fedora too far and falls onto the tracks of an oncoming subway.`,\n        `${user} tried to get crafty, but they accidentally cut themselves with the scissors.:scissors:`,\n        `${user} tried to get famous on YouTube by live-streaming something dumb. Skydiving while chained to a fridge.`,\n        `${user} tried to outrun a train, the train won.`,\n        `${user} tried to pick out the holy grail. He chose... poorly.`,\n        `${user} tried to play in the street...`,\n        `${user} trips over his own shoe laces and dies.`,\n        `${user} vocally opposed the Clintons and then suddenly disappeared.`,\n        `${user} was a resident of Alderaan before Darth Vader destroyed the planet...`,\n        `${user} was accused of stealing Neptune's crown...`,\n        `${user} was charging their Samsung Galaxy Note 7...`,\n        `${user} was eaten alive by ants`,\n        `${user} was given a chance to synthesize element 119 (Ununennium) and have it named after them, but they messed up. R.I.P.`,\n        `${user} was killed by ${interaction.user} with baby wipes.`,\n        `${user} was murdered by ${interaction.user} and everyone knows it, but there is no proof.`,\n        `${user} was scooped by ${interaction.user} and their innards are now Ennard.`,\n        `${user} was teleported to the timeline where Jurassic World was real and they were eaten alive by the Indominus Rex.`,\n        `${user} was thrown in the crusher of a trash truck by ${interaction.user}.`,\n        `${user} was walking normally when out of the corner of their eye they saw someone do a bottle flip and dab causing ${user} to have a stroke.`,\n        `${user} watched the Emoji Movie and died of sheer cringe.`,\n        `${user} went on a ride with a lead balloon.`,\n        `After getting pushed into the ocean by ${interaction.user}, ${user} is eaten by a shark.`,\n        `After raid of roblox kids entered the server, ${user} died of cancer.`,\n        `Aids, ${user} died from aids.`,\n        `Calling upon the divine powers, ${interaction.user} smites ${user} and their heathen ways`,\n        `In a sudden turn of events, I **don't** kill ${user}.`,\n        `no u`,\n        `Our lord and savior Gaben strikes ${user} with a lighting bolt.`,\n        `Sorry, ${interaction.user}, I don't like killing people.`,\n        `The bullet missed Harambe and hit ${user} instead. Yay for Harambe!`,\n        `While performing colonoscopy on an elephant, ${user} gets their head stuck in the elephants rectum and chokes.`,\n    ];\n\n    client.embed({ title: `🔫・Kill`, desc: `${kills[Math.floor(Math.random() * kills.length)]}`, type: 'editreply' }, interaction)\n\n}\n\n     ","size_bytes":15510},"src/commands/fun/koalafact.js":{"content":"const Discord = require('discord.js');\nconst fetch = require(\"node-fetch\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    fetch(\n        `https://some-random-api.ml/facts/koala`\n    )\n        .then((res) => res.json()).catch({})\n        .then(async (json) => {\n            client.embed({\n                title: `💡・Random koala fact`,\n                desc: json.fact,\n                type: 'editreply',\n            }, interaction);\n        }).catch({})\n}\n\n ","size_bytes":477},"src/commands/fun/lovemeter.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    const user1 = interaction.options.getUser('user1');\n    const user2 = interaction.options.getUser('user2');\n\n    if (!user1 || !user2) return client.errUsage({ usage: \"lovemeter [user1]\", type: 'editreply' }, interaction);\n\n    if (user1 == user2) return client.errNormal({ error: \"You cannot give 2 of the same names!\", type: 'editreply' }, interaction);\n\n    var result = Math.ceil(Math.random() * 100);\n\n    client.embed({\n        title: `${client.emotes.normal.heart}・Love meter`,\n        desc: \"See how much you match!\",\n        fields: [\n            {\n                name: \"Name 1\",\n                value: `${user1}`,\n                inline: true,\n            },\n            {\n                name: \"Name 2\",\n                value: `${user2}`,\n                inline: true,\n            },\n            {\n                name: \"Result\",\n                value: `**${user2}** and **${user2}** match **${result}%**`,\n                inline: false,\n            },\n        ],\n        type: 'editreply'\n    }, interaction)\n}\n\n     ","size_bytes":1094},"src/commands/fun/pandafact.js":{"content":"const Discord = require('discord.js');\nconst fetch = require(\"node-fetch\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    fetch(\n        `https://some-random-api.ml/facts/panda`\n    )\n        .then((res) => res.json()).catch({})\n        .then(async (json) => {\n            client.embed({\n                title: `💡・Random panda fact`,\n                desc: json.fact,\n                type: 'editreply',\n            }, interaction);\n        }).catch({})\n}\n\n ","size_bytes":477},"src/commands/fun/reverse.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    const text = interaction.options.getString('text');\n\n    client.succNormal({\n        text: `${text.split(\"\").reverse().join(\"\")}`,\n        type: 'editreply'\n    }, interaction)\n}\n\n ","size_bytes":281},"src/commands/fun/rickroll.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const roll = [\n        \"Never gonna give you up\",\n        \"Never gonna let you down\",\n        \"Never gonna run around and desert you\",\n        \"Never gonna make you cry\",\n        \"Never gonna say goodbye\",\n        \"Never gonna tell a lie and hurt you\",\n      ];\n      const rick = roll[Math.floor(Math.random() * roll.length)];\n\n        client.embed({\n            title: `😂・${rick}`,\n            image: `https://i.pinimg.com/originals/88/82/bc/8882bcf327896ab79fb97e85ae63a002.gif`,\n            type: 'editreply',\n        }, interaction);\n}\n\n ","size_bytes":649},"src/commands/fun/roast.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    const user = interaction.options.getUser('user');\n\n    var roasts = [\n        \"*Puts you in the oven.*\",\n        \"You're so stupid.\",\n        \"Sorry, I can't hear you over how annoying you are.\",\n        \"I've got better things to do.\",\n        \"You're as dumb as Cleverbot.\",\n        \"Your IQ is lower than the Mariana Trench.\",\n        \"You're so annoying even the flies stay away from your stench.\",\n        \"Go away, please.\",\n        \"I'd give you a nasty look but you've already got one.\",\n        \"It looks like your face caught fire and someone tried to put it out with a hammer.\",\n        \"Your family tree must be a cactus because everyone on it is a prick.\",\n        \"Someday you will go far, and I hope you stay there.\",\n        \"The zoo called. They're wondering how you got out of your cage.\",\n        \"I was hoping for a battle of wits, but you appear to be unarmed.\",\n        \"You are proof that evolution can go in reverse.\",\n        \"Brains aren't everything, in your case, they're nothing.\",\n        \"Sorry I didn't get that, I don't speak idiot.\",\n        \"Why is it acceptable for you to be an idiot, but not for me to point it out?\",\n        \"We all sprang from apes, but you did not spring far enough.\",\n        \"Even monkeys can go to space, so clearly you lack some potential.\",\n        \"It's brains over brawn, yet you have neither.\",\n        \"You look like a monkey, and you smell like one too.\",\n        \"Even among idiots you're lacking.\",\n        \"You fail even when you're doing absolutely nothing.\",\n        \"If there was a vote for 'least likely to succeed' you'd win first prize.\",\n        \"I'm surrounded by idiots... Or, wait, that's just you.\",\n        \"I wanna go home. Well, really I just want to get away from the awful aroma you've got going there.\",\n        \"Every time you touch me I have to go home and wash all my clothes nine times just to get a normal smell back.\",\n        \"If I had a dollar for every brain you don't have, I'd have one dollar.\",\n        \"I'd help you succeed but you're incapable.\",\n        \"Your hairline is built like a graph chart, positive and negative forces attract but the clippers and your hair repel.\",\n        \"I know a good joke! You!\",\n        \"You have two parts of your brain, 'left' and 'right'. In the left side, there's nothing right. In the right side, there's nothing left.\",\n        \"Is your ass jealous of the amount of shit that just came out of your mouth?\",\n        \"I don't engage in mental combat with the unarmed.\",\n        \"Two wrongs don't make a right, take your parents as an example.\",\n        \"Your birth certificate is an apology letter from the condom factory.\",\n        \"You sound reasonable. It must be time to up my medication!\",\n        \"You must have been born on a highway because that's where most accidents happen.\",\n        \"You're so ugly, when your mom dropped you off at school she got a fine for littering.\",\n        \"If laughter is the best medicine, your face must be curing the world.\",\n        \"I'd like to see things from your point of view but I can't seem to get my head that far up my ass.\",\n        \"The only way you'll ever get laid is if you crawl up a chicken's ass and wait.\",\n        \"I'm jealous of all the people that haven't met you!\",\n        \"If I had a face like yours, I'd sue my parents.\",\n        \"There's only one problem with your face. I can see it.\",\n        \"Don't you love nature, despite what it did to you?\",\n        \"What language are you speaking? Cause it sounds like bullshit.\",\n        \"Stupidity is not a crime so you are free to go.\",\n        \"So, a thought crossed your mind? Must have been a long and lonely journey.\",\n        \"You have a room temperature IQ - if the room is in Antarctica.\",\n        \"If you really want to know about mistakes, you should ask your parents.\",\n        \"I would ask you how old you are but I know you can't count that high.\",\n        \"Do you want to know how I get all these insults? I use something called intelligence.\",\n        \"I was going to give you a nasty look, but you already have one.\",\n        \"I don't know what your problem is, but I'll bet it's hard to pronounce.\",\n        \"Brains aren't everything. In your case they're nothing.\",\n        \"As an outsider, what do you think of the human race?\",\n        \"You look like a before picture.\",\n        \"Oh, what? Sorry. I was trying to imagine you with a personality.\",\n        \"You're the reason the gene pool needs a lifeguard.\",\n        \"We can always tell when you are lying. Your lips move.\",\n        \"I may love to shop but I'm not buying your bullshit.\",\n        \"Hell is wallpapered with all your deleted selfies.\",\n        \"You are living proof that manure can sprout legs and walk.\",\n        \"You do realize makeup isn't going to fix your stupidity?\",\n        \"Calling you an idiot would be an insult to all stupid people.\",\n        \"You have the perfect face for radio.\",\n        \"Aww, it's so cute when you try to talk about things you don't understand.\",\n        \"If I wanted to hear from an asshole, I'd fart.\",\n        \"What's the difference between you and an egg? Eggs get laid!\",\n        \"You look like a rock smashed into a pile of sand, rolled into a blunt, and got smoked through an asthma inhaler.\",\n        \"Your advice is about as useful as a paper-mache bomb shelter.\",\n        \"Is it sad that your theme song might as well have a 0/0 signature?\",\n        \"You're so fat, you make the galaxy look like it's on the molecular scale.\",\n    ];\n\n    client.embed({\n        title: `😓・Roast`,\n        desc: `${user}, ${roasts[Math.floor(Math.random() * roasts.length)]}`,\n        type: 'editreply'\n    }, interaction)\n}\n\n ","size_bytes":5753},"src/commands/fun/say.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {    \n    const text = interaction.options.getString('text');\n\n    if (text.length >= 2000) return client.errNormal({ \n        error: \"You may not use more than 2000 characters!\", \n        type: 'editreply' \n    }, interaction);\n\n    await interaction.channel.send({ content: client.removeMentions(text) }).then(() => {\n        client.succNormal({\n            text: `Message sent successfully`,\n            type: 'ephemeraledit'\n        }, interaction)\n    })\n}\n\n ","size_bytes":558},"src/commands/fun/simprate.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n    var result = Math.ceil(Math.random() * 100);\n\n    client.embed({\n        title: `👀・Simp rate`,\n        desc: `You are ${result}% simp!`,\n        type: 'editreply'\n    }, interaction)\n}\n\n ","size_bytes":253},"src/commands/fun/stankrate.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n    var result = Math.ceil(Math.random() * 100);\n\n    client.embed({\n        title: `💨・Stank rate`,\n        desc: `You are ${result}% stanky!`,\n        type: 'editreply'\n    }, interaction)\n}\n\n ","size_bytes":256},"src/commands/fun/sudo.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const user = interaction.options.getUser('user');\n    const text = interaction.options.getString('text');\n\n    if (text.length >= 2000) return client.errNormal({ error: \"You may not use more than 2000 characters!\", type: 'editreply' }, interaction);\n\n    interaction.channel.createWebhook({\n        name: user.username,\n        avatar: user.displayAvatarURL(),\n    }).then(async (_webhook) => {\n        await _webhook.send(client.removeMentions(text));\n        _webhook.delete();\n\n        client.succNormal({\n            text: `The sudo message was sent!`, \n            type: 'ephemeraledit' \n        }, interaction);\n    });\n}\n\n ","size_bytes":731},"src/commands/fun/token.js":{"content":"const Discord = require('discord.js');\nconst fetch = require(\"node-fetch\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    fetch(\n        `https://some-random-api.ml/bottoken?id=${interaction.user.id}`\n    )\n        .then((res) => res.json()).catch({})\n        .then(async (json) => {\n\n            client.embed({\n                title: `🤖・Bot token`,\n                desc: json.token,\n                type: 'editreply',\n            }, interaction);\n        }).catch({})\n\n}\n\n ","size_bytes":495},"src/commands/fun/worldclock.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n    var gmt = new Date().toLocaleString(\"en-US\", {\n        timeZone: \"Europe/London\",\n    });\n    var est = new Date().toLocaleString(\"en-US\", {\n        timeZone: \"America/New_York\",\n    });\n    var pst = new Date().toLocaleString(\"en-US\", {\n        timeZone: \"America/Los_Angeles\",\n    });\n    var cst = new Date().toLocaleString(\"en-US\", {\n        timeZone: \"America/Mexico_City\",\n    });\n    var aest = new Date().toLocaleString(\"en-US\", {\n        timeZone: \"Australia/Sydney\",\n    });\n    var awst = new Date().toLocaleString(\"en-US\", {\n        timeZone: \"Australia/Perth\",\n    });\n    var kst = new Date().toLocaleString(\"en-US\", { timeZone: \"Asia/Seoul\" });\n    var ist = new Date().toLocaleString(\"en-US\", {\n        timeZone: \"Asia/Calcutta\",\n    });\n\n    client.embed({\n        title: `⏰・World clock`,\n        fields: [\n            {\n                name: \":flag_eu:┇London (GMT)\",\n                value: `${gmt}\\n(GMT+0/GMT+1)`,\n                inline: true,\n            },\n            {\n                name: \":flag_us:┇New York (EST)\",\n                value: `${est}\\n(GMT-5)`,\n                inline: true,\n            },\n            {\n                name: \":flag_us:┇Los Angles (PST)\",\n                value: `${pst}\\n(GMT-8)`,\n                inline: true,\n            },\n            {\n                name: \":flag_us:┇Mexico City (CST)\",\n                value: `${cst}\\n(GMT-7)`,\n                inline: true,\n            },\n            {\n                name: \":flag_au:┇Sydney (AEST)\",\n                value: `${aest}\\n(GMT+11)`,\n                inline: true,\n            },\n            {\n                name: \":flag_au:┇Perth (AWST)\",\n                value: `${awst}\\n(GMT+8)`,\n                inline: true,\n            },\n            {\n                name: \":flag_kr:┇Korean (KST)\",\n                value: `${kst}\\n(GMT+9)`,\n                inline: true,\n            },\n            {\n                name: \":flag_in:┇India (IST)\",\n                value: `${ist}\\n(GMT+05:30)`,\n                inline: true,\n            },\n            {\n                name: \"\\u200b\",\n                value: `\\u200b`,\n                inline: true,\n            },\n        ],\n        type: 'editreply'\n    }, interaction)\n}\n\n ","size_bytes":2306},"src/commands/fun/xmas.js":{"content":"module.exports = async (client, interaction, args) => {\n    let today = new Date();\n     let xmas = new Date(today.getFullYear(), 11, 24);\n     if (today.getMonth() == 11 && today.getDate() > 24) {\n         xmas.setFullYear(xmas.getFullYear() + 1);\n     }\n     let one_day = 1000 * 60 * 60 * 24;\n     let daysleft = Math.ceil((xmas.getTime() - today.getTime()) / (one_day));\n     let days = daysleft + 1\n\n client.embed({\n         title: `🎄・Christmas`,\n         desc: `${days} days until Christmas`,\n     type: 'editreply'\n }, interaction)\n}\n\n","size_bytes":547},"src/commands/games/8ball.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const question = interaction.options.getString('question');\n\n    var antwoorden = [\n        \"Yes!\",\n        \"Unfortunately not\",\n        \"You are absolutely right!\",\n        \"No, sorry.\",\n        \"I agree\",\n        \"No idea!\",\n        \"I am not that smart ..\",\n        \"My sources say no!\",\n        \"It is certain\",\n        \"You can rely on it\",\n        \"Probably not\",\n        \"Everything points to a no\",\n        \"No doubt\",\n        \"Absolutely\",\n        \"I do not know\"\n    ];\n    var resultaat = Math.floor((Math.random() * antwoorden.length));\n\n    client.embed({\n        title: `${client.emotes.normal.ball}・8ball`,\n        desc: `See the answer on your question!`,\n        fields: [\n            {\n                name: `💬┆Your Question`,\n                value: `\\`\\`\\`${question}\\`\\`\\``,\n                inline: false\n            },\n            {\n                name: `🤖┆Bot Answer`,\n                value: `\\`\\`\\`${antwoorden[resultaat]}\\`\\`\\``,\n                inline: false\n            }\n        ],\n        type: 'editreply'\n    }, interaction);\n}\n\n ","size_bytes":1174},"src/commands/games/fasttype.js":{"content":"const Discord = require('discord.js');\nconst ms = require('ms');\n\nlet timeLength = 50000;\nmodule.exports = async (client, interaction, args) => {\n\n    let list = `Because we were lost, we had to go back the way we came.\n    He's in a boy band which doesn't make much sense for a snake.\n    A dead duck doesn't fly backward.\n    Don't piss in my garden and tell me you're trying to help my plants grow.\n    Her scream silenced the rowdy teenagers.\n    The team members were hard to tell apart since they all wore their hair in a ponytail.\n    I hear that Nancy is very pretty.\n    Nudist colonies shun fig-leaf couture.\n    A song can make or ruin a person’s day if they let it get to them.\n    She saw no irony asking me to change but wanting me to accept her for who she is.\n    My uncle's favorite pastime was building cars out of noodles.\n    In the end, he realized he could see sound and hear words.\n    Please look up a recipe for chicken soup on the internet.\n    It didn't take long for Gary to detect the robbers were amateurs.\n    How did you get hurt?\n    It was obvious she was hot, sweaty, and tired.\n    He appeared to be confusingly perplexed.\n    Love is not like pizza.\n    It was always dangerous to drive with him since he insisted the safety cones were a slalom course.\n    As he waited for the shower to warm, he noticed that he could hear water change temperature.\n    Greetings from the galaxy MACS0647-JD, or what we call home.\n    The world has changed a lot during the last ten years.\n    As he entered the church he could hear the soft voice of someone whispering into a cell phone.\n    Now I need to ponder my existence and ask myself if I'm truly real\n    Yesterday's weather was good for climbing.\n    Waffles are always better without fire ants and fleas.\n    Nancy was proud that she ran a tight shipwreck.\n    He was so preoccupied with whether or not he could that he failed to stop to consider if he should.\n    If eating three-egg omelets causes weight-gain, budgie eggs are a good substitute.\n    I don’t respect anybody who can’t tell the difference between Pepsi and Coke.\n    He found the end of the rainbow and was surprised at what he found there.\n    He wondered why at 18 he was old enough to go to war, but not old enough to buy cigarettes.\n    She lived on Monkey Jungle Road and that seemed to explain all of her strangeness.\n    Julie wants a perfect husband.\n    Can I get you something to drink?\n    Please wait outside of the house.\n    His son quipped that power bars were nothing more than adult candy bars.\n    My older sister looks like my mom.\n    The thick foliage and intertwined vines made the hike nearly impossible.\n    A glittering gem is not enough.\n    Thirty years later, she still thought it was okay to put the toilet paper roll under rather than over.\n    Each person who knows you has a different perception of who you are.\n    Go down the stairs carefully.\n    Facing his greatest fear, he ate his first marshmallow.\n    She cried diamonds.\n    Tomorrow will bring something new, so leave today as a memory.\n    Erin accidentally created a new universe.\n    David subscribes to the \"stuff your tent into the bag\" strategy over nicely folding it.\n    The waitress was not amused when he ordered green eggs and ham.\n    All you need to do is pick up the pen and begin.`;\n\n    async function start() {\n        const inGame = new Set();\n        const filter = m => m.author.id === interaction.user.id;\n        if (inGame.has(interaction.user.id)) return;\n        inGame.add(interaction.user.id);\n        var i;\n        for (i = 0; i < 25; i++) {\n            const time = Date.now();\n\n            list = list.split(\"\\n\");\n            let sentenceList = list[Math.floor(Math.random() * list.length)];\n\n            let sentence = '';\n            let ogSentence = sentenceList.toLowerCase().replace(\"    \", \"\");\n\n            ogSentence.split(' ').forEach(argument => {\n                sentence += '`' + argument.split('').join(' ') + '` '\n            });\n\n            await client.embed({\n                title: `💬・FastType`,\n                desc: `Type the below in ${ms(timeLength, { long: true })}! \\n${sentence}`,\n                type: 'editreply'\n            }, interaction)\n\n            try {\n                var msg = await interaction.channel.awaitMessages({\n                    filter,\n                    max: 1,\n                    time: timeLength,\n                    errors: ['time']\n                });\n            } catch (ex) {\n                client.errNormal({\n                    error: \"Time\\'s up!\",\n                    type: 'editreply'\n                }, interaction)\n                inGame.delete(interaction.user.id)\n                break;\n            }\n\n            if (['cancel', 'end'].includes(msg.first().content.toLowerCase().trim())) {\n                msg.first().delete();\n                client.succNormal({\n                    text: \"Ended!\",\n                    type: 'editreply'\n                }, interaction)\n                inGame.delete(interaction.user.id)\n                break\n            } else if (msg.first().content.toLowerCase().trim() === ogSentence.toLowerCase()) {\n                msg.first().delete();\n                client.succNormal({\n                    text: `You did it in ${ms(Date.now() - time, { long: true })}!`,\n                    type: 'editreply'\n                }, interaction)\n                break;\n            } else {\n                client.errNormal({\n                    error: \"Unfortunately you didn't succeed!\",\n                    type: 'editreply'\n                }, interaction)\n                inGame.delete(interaction.user.id)\n                break;\n            }\n\n            if (i === 25) {\n                client.succNormal({ text: `You did it!`, type: 'editreply' }, interaction)\n                inGame.delete(interaction.user.id)\n                break\n            }\n        }\n    }\n\n    start()\n}\n\n ","size_bytes":5961},"src/commands/games/music-trivia.js":{"content":"const Discord = require('discord.js');\nconst {\n    joinVoiceChannel,\n    VoiceConnectionStatus,\n    entersState\n} = require('@discordjs/voice');\nconst fs = require('fs');\nconst TriviaPlayer = require('../../assets/utils/TriviaPlayer.js');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const number = interaction.options.getNumber('number');\n\n    if (!number || isNaN(number)) return client.errUsage({ usage: \"music-trivia [amount of numbers]\", type: 'editreply' }, interaction);\n\n    const channel = interaction.member.voice.channel;\n    if (!channel) return client.errNormal({ error: `You're not in a voice channel!`, type: 'editreply' }, interaction);\n\n    if (interaction.guild.members.me.voice.channel && interaction.member.voice.channel.id !== interaction.guild.members.me.voice.channel.id) return client.errNormal({ error: `You are not in the same voice channel!`, type: 'editreply' }, interaction);\n\n    if (interaction.client.playerManager.get(interaction.guild.id)) return client.errNormal({ error: `You can't use this while a track is playing!`, type: 'editreply' }, interaction);\n\n    if (interaction.client.triviaManager.get(interaction.guildId)) return client.errNormal({ error: `There is already a trivia in play!`, type: 'editreply' }, interaction);\n\n    const jsonSongs = fs.readFileSync(\n        './src/config/data/musictrivia.json',\n        'utf8'\n    );\n    const videoDataArray = JSON.parse(jsonSongs).songs;\n\n    const randomLinks = getRandom(videoDataArray, parseInt(number));\n    interaction.client.triviaManager.set(\n        interaction.guildId,\n        new TriviaPlayer()\n    );\n\n    const triviaPlayer = interaction.client.triviaManager.get(\n        interaction.guildId\n    );\n\n    randomLinks.forEach(link => {\n        triviaPlayer.queue.push({\n            url: link.url,\n            singer: link.singer,\n            title: link.title,\n            channel\n        });\n    });\n\n    const membersInChannel = interaction.member.voice.channel.members;\n\n    membersInChannel.each(user => {\n        if (user.user.bot) return;\n        triviaPlayer.score.set(user.user.username, 0);\n    });\n\n    handleSubscription(interaction, triviaPlayer, client);\n}\n\nasync function handleSubscription(interaction, player, client) {\n    const queue = player.queue;\n    let voiceChannel = queue[0].channel;\n\n    const connection = joinVoiceChannel({\n        channelId: voiceChannel.id,\n        guildId: interaction.guild.id,\n        adapterCreator: interaction.guild.voiceAdapterCreator\n    });\n\n    player.textChannel = interaction.channel;\n    player.passConnection(connection);\n    try {\n        await entersState(player.connection, VoiceConnectionStatus.Ready, 10000);\n    } catch (error) {\n        connection.destroy();\n        return client.emit(\"voiceError\", error);\n    }\n\n    player.process(player.queue);\n\n    client.embed({\n        title: `🎶・Music Quiz`,\n        desc: `Get ready! Vote skip the song by entering the word 'skip'. Good luck! \\n\\n**Songs in queue:** ${queue.length} \\n**Time to play:** 30 seconds`,\n        type: 'editreply'\n    }, interaction);\n}\n\nfunction getRandom(arr, n) {\n    var result = new Array(n),\n        len = arr.length,\n        taken = new Array(len);\n    if (n > len)\n        throw new RangeError('getRandom: More elements taken than available!');\n    while (n--) {\n        var x = Math.floor(Math.random() * len);\n        result[n] = arr[(x in taken) ? taken[x] : x];\n        taken[x] = (--len in taken) ? taken[len] : len;\n    }\n    return result;\n}\n\n ","size_bytes":3520},"src/commands/games/roll.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    var result = Math.ceil(Math.random() * 6);\n\n    client.embed({\n        title: `🎲・Roll`,\n        desc: `You rolled ${result}`,\n        type: 'editreply'\n    }, interaction);\n}\n\n ","size_bytes":282},"src/commands/games/rps.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    const option = interaction.options.getString(\"option\");\n\n    let options = [\"rock\", \"paper\", \"scissors\"];\n    const result = options[Math.floor(Math.random() * options.length)];\n\n    switch (option) {\n        case \"rock\":\n            if (result == \"paper\") return client.embed({\n                title: `${client.emotes.normal.paper}・Rock paper scissors`,\n                desc: `I have ${result}, I win!`,\n                type: 'editreply'\n            }, interaction);\n\n            if (result == \"scissors\") return client.embed({\n                title: `${client.emotes.normal.paper}・Rock paper scissors`,\n                desc: `I have ${result}, You win!`,\n                type: 'editreply'\n            }, interaction);\n\n            if (result == \"rock\") return client.embed({\n                title: `${client.emotes.normal.paper}・Rock paper scissors`,\n                desc: `I have ${result}, It's a draw!`,\n                type: 'editreply'\n            }, interaction);\n            break;\n\n        case \"paper\":\n            if (result == \"paper\") return client.embed({\n                title: `${client.emotes.normal.paper}・Rock paper scissors`,\n                desc: `I have ${result}, It's a draw!`,\n                type: 'editreply'\n            }, interaction);\n\n            if (result == \"scissors\") return client.embed({\n                title: `${client.emotes.normal.paper}・Rock paper scissors`,\n                desc: `I have ${result}, I win!`,\n                type: 'editreply'\n            }, interaction);\n\n            if (result == \"rock\") return client.embed({\n                title: `${client.emotes.normal.paper}・Rock paper scissors`,\n                desc: `I have ${result}, You win!`,\n                type: 'editreply'\n            }, interaction);\n            break;\n\n        case \"scissors\":\n            if (result == \"paper\") return client.embed({\n                title: `${client.emotes.normal.paper}・Rock paper scissors`,\n                desc: `I have ${result}, You win!`,\n                type: 'editreply'\n            }, interaction);\n\n            if (result == \"scissors\") return client.embed({\n                title: `${client.emotes.normal.paper}・Rock paper scissors`,\n                desc: `I have ${result}, It's a draw!`,\n                type: 'editreply'\n            }, interaction);\n\n            if (result == \"rock\") return client.embed({\n                title: `${client.emotes.normal.paper}・Rock paper scissors`,\n                desc: `I have ${result}, I win!`,\n                type: 'editreply'\n            }, interaction);\n            break;\n    }\n}\n\n ","size_bytes":2706},"src/commands/games/skipword.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/guessWord\");\n\nmodule.exports = async (client, interaction, args) => {\n    let wordList = client.config.wordList;\n\n    Schema.findOne({ Guild: interaction.guild.id, Channel: interaction.channel.id }, async (err, data) => {\n        if (data) {\n            try {\n                wordList = wordList.split(\"\\n\");\n                var word = wordList[Math.floor(Math.random() * wordList.length)];\n                var shuffled = word.split('').sort(function () { return 0.5 - Math.random() }).join('');\n\n                data.Word = word;\n                data.save();\n\n                client.succNormal({ \n                    text: `Word skipped successfully!`,\n                    type: 'ephemeral'\n                }, interaction);\n\n                return client.embed({ \n                    title: `💬・Guess the word`, \n                    desc: `Put the letters in the right position! \\n\\n🔀 ${shuffled.toLowerCase()}`,\n                }, interaction.channel)\n            }\n            catch { }\n        }\n        else {\n            client.errNormal({\n                error: \"You are not in the right channel!\",\n                type: 'editreply'\n            }, interaction)\n        }\n    })\n}\n\n ","size_bytes":1282},"src/commands/games/snake.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    const getRandomString = (length) => {\n        const randomChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n        let result = '';\n        for (let i = 0; i < length; i++) {\n            result += randomChars.charAt(\n                Math.floor(Math.random() * randomChars.length),\n            );\n        }\n        return result;\n    };\n\n    const id1 =\n        getRandomString(20) +\n        '-' +\n        getRandomString(20) +\n        '-' +\n        getRandomString(20) +\n        '-' +\n        getRandomString(20);\n\n    const id2 =\n        getRandomString(20) +\n        '-' +\n        getRandomString(20) +\n        '-' +\n        getRandomString(20) +\n        '-' +\n        getRandomString(20);\n\n    const id3 =\n        getRandomString(20) +\n        '-' +\n        getRandomString(20) +\n        '-' +\n        getRandomString(20) +\n        '-' +\n        getRandomString(20);\n\n    const id4 =\n        getRandomString(20) +\n        '-' +\n        getRandomString(20) +\n        '-' +\n        getRandomString(20) +\n        '-' +\n        getRandomString(20);\n\n    const id5 =\n        getRandomString(20) +\n        '-' +\n        getRandomString(20) +\n        '-' +\n        getRandomString(20) +\n        '-' +\n        getRandomString(20);\n\n    const id6 =\n        getRandomString(20) +\n        '-' +\n        getRandomString(20) +\n        '-' +\n        getRandomString(20) +\n        '-' +\n        getRandomString(20);\n\n    const id7 =\n        getRandomString(20) +\n        '-' +\n        getRandomString(20) +\n        '-' +\n        getRandomString(20) +\n        '-' +\n        getRandomString(20);\n\n    let score = 0;\n    const width = 15;\n    const height = 10;\n    const gameBoard = [];\n    let inGame = false;\n    let snakeLength = 1;\n    const apple = { x: 0, y: 0 };\n    let snake = [{ x: 0, y: 0 }];\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            gameBoard[y * width + x] = \"⬛\";\n        }\n    }\n\n    function gameBoardToString() {\n        let str = '';\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                if (x == apple.x && y == apple.y) {\n                    str += \"🍎\";\n                    continue;\n                }\n                let flag = true;\n                for (let s = 0; s < snake.length; s++) {\n                    if (x == snake[s].x && y == snake[s].y) {\n                        str += \"🐍\";\n                        flag = false;\n                    }\n                }\n                if (flag) {\n                    str += gameBoard[y * width + x];\n                }\n            }\n            str += '\\n';\n        }\n        return str;\n    }\n\n    function isLocInSnake(pos) {\n        return snake.find((sPos) => sPos.x == pos.x && sPos.y == pos.y);\n    }\n\n    function newappleLoc() {\n        let newapplePos = {\n            x: 0,\n            y: 0,\n        };\n        do {\n            newapplePos = {\n                x: parseInt(Math.random() * width),\n                y: parseInt(Math.random() * height),\n            };\n        } while (isLocInSnake(newapplePos));\n        apple.x = newapplePos.x;\n        apple.y = newapplePos.y;\n    }\n\n    function step(msg) {\n        if (apple.x == snake[0].x && apple.y == snake[0].y) {\n            score += 1;\n            snakeLength++;\n            newappleLoc();\n        }\n\n        lock1 = new Discord.ButtonBuilder()\n            .setLabel('\\u200b')\n            .setStyle(Discord.ButtonStyle.Secondary)\n            .setCustomId(id1)\n            .setDisabled(true);\n        w = new Discord.ButtonBuilder()\n            .setEmoji(\"⬆️\")\n            .setStyle(Discord.ButtonStyle.Primary)\n            .setCustomId(id2);\n        lock2 = new Discord.ButtonBuilder()\n            .setLabel('\\u200b')\n            .setStyle(Discord.ButtonStyle.Secondary)\n            .setCustomId(id7)\n            .setDisabled(true);\n        a = new Discord.ButtonBuilder()\n            .setEmoji(\"⬅️\")\n            .setStyle(Discord.ButtonStyle.Primary)\n            .setCustomId(id3);\n        s = new Discord.ButtonBuilder()\n            .setEmoji(\"⬇️\")\n            .setStyle(Discord.ButtonStyle.Primary)\n            .setCustomId(id4);\n        d = new Discord.ButtonBuilder()\n            .setEmoji(\"➡️\")\n            .setStyle(Discord.ButtonStyle.Primary)\n            .setCustomId(id5);\n        stopy = new Discord.ButtonBuilder()\n            .setLabel(\"Cancel\")\n            .setStyle(Discord.ButtonStyle.Danger)\n            .setCustomId(id6);\n\n\n        client.embed({\n            title: `🐍・Snake`,\n            desc: gameBoardToString(),\n            components: [\n                {\n                    type: 1,\n                    components: [lock1, w, lock2, stopy],\n                },\n                {\n                    type: 1,\n                    components: [a, s, d],\n                },\n            ],\n            type: 'editreply'\n        }, interaction)\n    }\n\n    function gameOver(msg) {\n        if (apple.x == snake[0].x && apple.y == snake[0].y) {\n            score += 1;\n            snakeLength++;\n            newappleLoc();\n        }\n\n        lock1 = new Discord.ButtonBuilder()\n            .setLabel('\\u200b')\n            .setStyle(Discord.ButtonStyle.Secondary)\n            .setCustomId(id1)\n            .setDisabled(true);\n        w = new Discord.ButtonBuilder()\n            .setEmoji(\"⬆️\")\n            .setStyle(Discord.ButtonStyle.Primary)\n            .setCustomId(id2)\n            .setDisabled(true);\n        lock2 = new Discord.ButtonBuilder()\n            .setLabel('\\u200b')\n            .setStyle(Discord.ButtonStyle.Secondary)\n            .setCustomId(id7)\n            .setDisabled(true);\n        a = new Discord.ButtonBuilder()\n            .setEmoji(\"⬅️\")\n            .setStyle(Discord.ButtonStyle.Primary)\n            .setCustomId(id3)\n            .setDisabled(true);\n        s = new Discord.ButtonBuilder()\n            .setEmoji(\"⬇️\")\n            .setStyle(Discord.ButtonStyle.Primary)\n            .setCustomId(id4)\n            .setDisabled(true);\n        d = new Discord.ButtonBuilder()\n            .setEmoji(\"➡️\")\n            .setStyle(Discord.ButtonStyle.Primary)\n            .setCustomId(id5)\n            .setDisabled(true);\n        stopy = new Discord.ButtonBuilder()\n            .setLabel(\"Cancel\")\n            .setStyle(Discord.ButtonStyle.Danger)\n            .setCustomId(id6)\n            .setDisabled(true);\n\n        client.embed({\n            title: `🐍・Snake`,\n            desc: `GG, you scored **${score}** points!`,\n            components: [\n                {\n                    type: 1,\n                    components: [lock1, w, lock2, stopy],\n                },\n                {\n                    type: 1,\n                    components: [a, s, d],\n                },\n            ],\n            type: 'editreply'\n        }, interaction)\n    }\n\n    if (inGame) return;\n    inGame = true;\n    score = 0;\n    snakeLength = 1;\n    snake = [{ x: 5, y: 5 }];\n    newappleLoc();\n\n    lock1 = new Discord.ButtonBuilder()\n        .setLabel('\\u200b')\n        .setStyle(Discord.ButtonStyle.Secondary)\n        .setCustomId(id1)\n        .setDisabled(true);\n    w = new Discord.ButtonBuilder()\n        .setEmoji(\"⬆️\")\n        .setStyle(Discord.ButtonStyle.Primary)\n        .setCustomId(id2);\n    lock2 = new Discord.ButtonBuilder()\n        .setLabel('\\u200b')\n        .setStyle(Discord.ButtonStyle.Secondary)\n        .setCustomId(id7)\n        .setDisabled(true);\n    a = new Discord.ButtonBuilder()\n        .setEmoji(\"⬅️\")\n        .setStyle(Discord.ButtonStyle.Primary)\n        .setCustomId(id3);\n    s = new Discord.ButtonBuilder()\n        .setEmoji(\"⬇️\")\n        .setStyle(Discord.ButtonStyle.Primary)\n        .setCustomId(id4);\n    d = new Discord.ButtonBuilder()\n        .setEmoji(\"➡️\")\n        .setStyle(Discord.ButtonStyle.Primary)\n        .setCustomId(id5);\n    stopy = new Discord.ButtonBuilder()\n        .setLabel(\"Cancel\")\n        .setStyle(Discord.ButtonStyle.Danger)\n        .setCustomId(id6);\n\n    client.embed({\n        title: `🐍・Snake`,\n        desc: gameBoardToString(),\n        components: [\n            {\n                type: 1,\n                components: [lock1, w, lock2, stopy],\n            },\n            {\n                type: 1,\n                components: [a, s, d],\n            },\n        ],\n        type: 'editreply'\n    }, interaction).then(async (m) => {\n        const collector = interaction.channel.createMessageComponentCollector({ componentType: Discord.ComponentType.Button });\n\n        collector.on('collect', async (btn) => {\n            if (btn.user.id !== interaction.user.id) return;\n\n            btn.deferUpdate();\n\n            const snakeHead = snake[0];\n            const nextPos = {\n                x: snakeHead.x,\n                y: snakeHead.y,\n            };\n            if (btn.customId === id3) {\n                let nextX = snakeHead.x - 1;\n                if (nextX < 0) {\n                    nextX = width - 1;\n                }\n                nextPos.x = nextX;\n            } else if (btn.customId === id2) {\n                let nextY = snakeHead.y - 1;\n                if (nextY < 0) {\n                    nextY = height - 1;\n                }\n                nextPos.y = nextY;\n            } else if (btn.customId === id4) {\n                let nextY = snakeHead.y + 1;\n                if (nextY >= height) {\n                    nextY = 0;\n                }\n                nextPos.y = nextY;\n            } else if (btn.customId === id5) {\n                let nextX = snakeHead.x + 1;\n                if (nextX >= width) {\n                    nextX = 0;\n                }\n                nextPos.x = nextX;\n            } else if (btn.customId === id6) {\n                gameOver(m);\n                collector.stop();\n            }\n\n            if (isLocInSnake(nextPos)) {\n                gameOver(m);\n                collector.stop();\n            } else {\n                snake.unshift(nextPos);\n                if (snake.length > snakeLength) {\n                    snake.pop();\n                }\n                step(m);\n            }\n        });\n    })\n}\n\n ","size_bytes":10241},"src/commands/games/trivia.js":{"content":"const Discord = require('discord.js');\nconst fetch = require(\"node-fetch\");\nconst { decode } = require('html-entities');\n\nmodule.exports = async (client, interaction, args) => {\n    const getRandomString = (length) => {\n        const randomChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n        let result = '';\n        for (let i = 0; i < length; i++) {\n            result += randomChars.charAt(\n                Math.floor(Math.random() * randomChars.length),\n            );\n        }\n        return result;\n    };\n\n    const shuffleArray = (array) => {\n        for (let i = array.length - 1; i > 0; i--) {\n            const j = Math.floor(Math.random() * (i + 1));\n            const temp = array[i];\n            array[i] = array[j];\n            array[j] = temp;\n        }\n        return array;\n    };\n\n    const convertTime = (time) => {\n        const absoluteSeconds = Math.floor((time / 1000) % 60);\n        const absoluteMinutes = Math.floor((time / (1000 * 60)) % 60);\n        const absoluteHours = Math.floor((time / (1000 * 60 * 60)) % 24);\n        const absoluteDays = Math.floor(time / (1000 * 60 * 60 * 24));\n        const d = absoluteDays\n            ? absoluteDays === 1\n                ? '1 day'\n                : `${absoluteDays} days`\n            : null;\n        const h = absoluteHours\n            ? absoluteHours === 1\n                ? '1 hour'\n                : `${absoluteHours} hours`\n            : null;\n        const m = absoluteMinutes\n            ? absoluteMinutes === 1\n                ? '1 minute'\n                : `${absoluteMinutes} minutes`\n            : null;\n        const s = absoluteSeconds\n            ? absoluteSeconds === 1\n                ? '1 second'\n                : `${absoluteSeconds} seconds`\n            : null;\n        const absoluteTime = [];\n        if (d) absoluteTime.push(d);\n        if (h) absoluteTime.push(h);\n        if (m) absoluteTime.push(m);\n        if (s) absoluteTime.push(s);\n        return absoluteTime.join(', ');\n    }\n\n    const id1 =\n        getRandomString(20) +\n        '-' +\n        getRandomString(20) +\n        '-' +\n        getRandomString(20) +\n        '-' +\n        getRandomString(20);\n\n    const id2 =\n        getRandomString(20) +\n        '-' +\n        getRandomString(20) +\n        '-' +\n        getRandomString(20) +\n        '-' +\n        getRandomString(20);\n\n    const id3 =\n        getRandomString(20) +\n        '-' +\n        getRandomString(20) +\n        '-' +\n        getRandomString(20) +\n        '-' +\n        getRandomString(20);\n\n    const id4 =\n        getRandomString(20) +\n        '-' +\n        getRandomString(20) +\n        '-' +\n        getRandomString(20) +\n        '-' +\n        getRandomString(20);\n\n    const question = {};\n\n    await fetch(`https://opentdb.com/api.php?amount=1&type=multiple&difficulty=hard`).then((res) => res.json()).then(async (res) => {\n        const q = [];\n        q.push(res.results[0]);\n        question.question = res.results[0].question;\n        question.difficulty = res.results[0].difficulty;\n        await q[0].incorrect_answers.push(q[0].correct_answer);\n        const shuffledArray = shuffleArray(q[0].incorrect_answers);\n        question.correct = shuffledArray.indexOf(res.results[0].correct_answer);\n        question.options = shuffledArray;\n    });\n\n    let winningID;\n    if (question.correct === 0) {\n        winningID = id1;\n    } else if (question.correct === 1) {\n        winningID = id2;\n    } else if (question.correct === 2) {\n        winningID = id3;\n    } else if (question.correct === 3) {\n        winningID = id4;\n    }\n\n    let btn = new Discord.ButtonBuilder()\n        .setStyle(Discord.ButtonStyle.Primary)\n        .setLabel(\"1️⃣\")\n        .setCustomId(id1);\n\n    let btn2 = new Discord.ButtonBuilder()\n        .setStyle(Discord.ButtonStyle.Primary)\n        .setLabel(\"2️⃣\")\n        .setCustomId(id2);\n\n    let btn3 = new Discord.ButtonBuilder()\n        .setStyle(Discord.ButtonStyle.Primary)\n        .setLabel(\"3️⃣\")\n        .setCustomId(id3);\n\n    let btn4 = new Discord.ButtonBuilder()\n        .setStyle(Discord.ButtonStyle.Primary)\n        .setLabel(\"4️⃣\")\n        .setCustomId(id4);\n\n    let row = new Discord.ActionRowBuilder()\n        .addComponents(btn, btn2, btn3, btn4);\n\n    let opt = '';\n    for (let i = 0; i < question.options.length; i++) {\n        opt += `**${i + 1})** ${decode(question.options[i])}\\n`;\n    }\n\n    await client.embed({\n        title: `🕹️・Trivia`,\n        fields: [\n            {\n                name: `${decode(question.question)}`,\n                value: `You only have **${convertTime(60000)}** to guess the answer!\\n\\n${opt}`\n            }\n        ],\n        components: [row],\n        type: 'editreply'\n    }, interaction).then(async (m) => {\n        const gameCreatedAt = Date.now();\n\n        const collector = interaction.channel.createMessageComponentCollector({ componentType: Discord.ComponentType.Button, time: 60000 });\n\n        collector.on('collect', async (trivia) => {\n            if (trivia.user.id !== interaction.user.id) return;\n\n            trivia.deferUpdate();\n\n            if (trivia.customId === winningID) {\n                let fbtn1 = new Discord.ButtonBuilder()\n                    .setStyle(Discord.ButtonStyle.Primary)\n                    .setLabel(\"1️⃣\")\n                    .setCustomId(id1)\n                    .setDisabled(true);\n                let fbtn2 = new Discord.ButtonBuilder()\n                    .setStyle(Discord.ButtonStyle.Primary)\n                    .setLabel(\"2️⃣\")\n                    .setCustomId(id2)\n                    .setDisabled(true);\n                let fbtn3 = new Discord.ButtonBuilder()\n                    .setStyle(Discord.ButtonStyle.Primary)\n                    .setLabel(\"3️⃣\")\n                    .setCustomId(id3)\n                    .setDisabled(true);\n                let fbtn4 = new Discord.ButtonBuilder()\n                    .setStyle(Discord.ButtonStyle.Primary)\n                    .setLabel(\"4️⃣\")\n                    .setCustomId(id4)\n                    .setDisabled(true);\n\n                collector.stop();\n\n                if (winningID === id1) {\n                    fbtn1.setStyle(Discord.ButtonStyle.Success);\n                    fbtn2.setStyle(Discord.ButtonStyle.Danger);\n                    fbtn3.setStyle(Discord.ButtonStyle.Danger);\n                    fbtn4.setStyle(Discord.ButtonStyle.Danger);\n                } else if (winningID === id2) {\n                    fbtn1.setStyle(Discord.ButtonStyle.Danger);\n                    fbtn2.setStyle(Discord.ButtonStyle.Success);\n                    fbtn3.setStyle(Discord.ButtonStyle.Danger);\n                    fbtn4.setStyle(Discord.ButtonStyle.Danger);\n                } else if (winningID === id3) {\n                    fbtn1.setStyle(Discord.ButtonStyle.Danger);\n                    fbtn2.setStyle(Discord.ButtonStyle.Danger);\n                    fbtn3.setStyle(Discord.ButtonStyle.Success);\n                    fbtn4.setStyle(Discord.ButtonStyle.Danger);\n                } else if (winningID === id4) {\n                    fbtn1.setStyle(Discord.ButtonStyle.Danger);\n                    fbtn2.setStyle(Discord.ButtonStyle.Danger);\n                    fbtn3.setStyle(Discord.ButtonStyle.Danger);\n                    fbtn4.setStyle(Discord.ButtonStyle.Success);\n                }\n\n                const time = convertTime(Date.now() - gameCreatedAt);\n\n                await client.embed({\n                    title: `🕹️・Trivia`,\n                    desc: `GG, It was **${question.options[question.correct]}**. You gave the correct answer in **${time}**.`,\n                    components: [{ type: 1, components: [fbtn1, fbtn2, fbtn3, fbtn4] }],\n                    type: 'editreply'\n                }, interaction)\n            } else {\n                let fbtn1 = new Discord.ButtonBuilder()\n                    .setStyle(Discord.ButtonStyle.Primary)\n                    .setLabel(\"1️⃣\")\n                    .setCustomId(id1)\n                    .setDisabled(true);\n                let fbtn2 = new Discord.ButtonBuilder()\n                    .setStyle(Discord.ButtonStyle.Primary)\n                    .setLabel(\"2️⃣\")\n                    .setCustomId(id2)\n                    .setDisabled(true);\n                let fbtn3 = new Discord.ButtonBuilder()\n                    .setStyle(Discord.ButtonStyle.Primary)\n                    .setLabel(\"3️⃣\")\n                    .setCustomId(id3)\n                    .setDisabled(true);\n                let fbtn4 = new Discord.ButtonBuilder()\n                    .setStyle(Discord.ButtonStyle.Primary)\n                    .setLabel(\"4️⃣\")\n                    .setCustomId(id4)\n                    .setDisabled(true);\n\n                collector.stop();\n\n                if (winningID === id1) {\n                    fbtn1.setStyle(Discord.ButtonStyle.Success);\n                    if (trivia.customId === id2) {\n                        fbtn2.setStyle(Discord.ButtonStyle.Danger);\n                        fbtn3.setStyle(Discord.ButtonStyle.Secondary);\n                        fbtn4.setStyle(Discord.ButtonStyle.Secondary);\n                    } else if (trivia.customId === id3) {\n                        fbtn2.setStyle(Discord.ButtonStyle.Secondary);\n                        fbtn3.setStyle(Discord.ButtonStyle.Danger);\n                        fbtn4.setStyle(Discord.ButtonStyle.Secondary);\n                    } else if (trivia.customId === id4) {\n                        fbtn2.setStyle(Discord.ButtonStyle.Secondary);\n                        fbtn3.setStyle(Discord.ButtonStyle.Secondary);\n                        fbtn4.setStyle(Discord.ButtonStyle.Danger);\n                    }\n                } else if (winningID === id2) {\n                    fbtn2.setStyle(Discord.ButtonStyle.Success);\n                    if (trivia.customId === id1) {\n                        fbtn1.setStyle(Discord.ButtonStyle.Danger);\n                        fbtn3.setStyle(Discord.ButtonStyle.Secondary);\n                        fbtn4.setStyle(Discord.ButtonStyle.Secondary);\n                    } else if (trivia.customId === id3) {\n                        fbtn1.setStyle(Discord.ButtonStyle.Secondary);\n                        fbtn3.setStyle(Discord.ButtonStyle.Danger);\n                        fbtn4.setStyle(Discord.ButtonStyle.Secondary);\n                    } else if (trivia.customId === id4) {\n                        fbtn1.setStyle(Discord.ButtonStyle.Secondary);\n                        fbtn3.setStyle(Discord.ButtonStyle.Secondary);\n                        fbtn4.setStyle(Discord.ButtonStyle.Danger);\n                    }\n                } else if (winningID === id3) {\n                    fbtn3.setStyle(Discord.ButtonStyle.Success);\n                    if (trivia.customId === id1) {\n                        fbtn1.setStyle(Discord.ButtonStyle.Danger);\n                        fbtn2.setStyle(Discord.ButtonStyle.Secondary);\n                        fbtn4.setStyle(Discord.ButtonStyle.Secondary);\n                    } else if (trivia.customId === id2) {\n                        fbtn1.setStyle(Discord.ButtonStyle.Secondary);\n                        fbtn2.setStyle(Discord.ButtonStyle.Danger);\n                        fbtn4.setStyle(Discord.ButtonStyle.Secondary);\n                    } else if (trivia.customId === id4) {\n                        fbtn1.setStyle(Discord.ButtonStyle.Secondary);\n                        fbtn2.setStyle(Discord.ButtonStyle.Secondary);\n                        fbtn4.setStyle(Discord.ButtonStyle.Danger);\n                    }\n                } else if (winningID === id4) {\n                    fbtn4.setStyle(Discord.ButtonStyle.Success);\n                    if (trivia.customId === id1) {\n                        fbtn1.setStyle(Discord.ButtonStyle.Danger);\n                        fbtn2.setStyle(Discord.ButtonStyle.Secondary);\n                        fbtn3.setStyle(Discord.ButtonStyle.Secondary);\n                    } else if (trivia.customId === id2) {\n                        fbtn1.setStyle(Discord.ButtonStyle.Secondary);\n                        fbtn2.setStyle(Discord.ButtonStyle.Danger);\n                        fbtn3.setStyle(Discord.ButtonStyle.Secondary);\n                    } else if (trivia.customId === id3) {\n                        fbtn1.setStyle(Discord.ButtonStyle.Secondary);\n                        fbtn2.setStyle(Discord.ButtonStyle.Secondary);\n                        fbtn3.setStyle(Discord.ButtonStyle.Danger);\n                    }\n                }\n\n                await client.embed({\n                    title: `🕹️・Trivia`,\n                    desc: `Better luck next time! The correct answer was **${question.options[question.correct]}**.`,\n                    components: [{ type: 1, components: [fbtn1, fbtn2, fbtn3, fbtn4] }],\n                    type: 'editreply'\n                }, interaction)\n            }\n        })\n\n        collector.on('end', (trivia, reason) => {\n            if (reason === 'time') {\n                let fbtn1 = new Discord.ButtonBuilder()\n                    .setLabel(\"1️⃣\")\n                    .setCustomId(id1)\n                    .setDisabled(true);\n                let fbtn2 = new Discord.ButtonBuilder()\n                    .setLabel(\"2️⃣\")\n                    .setCustomId(id2)\n                    .setDisabled(true);\n                let fbtn3 = new Discord.ButtonBuilder()\n                    .setLabel(\"3️⃣\")\n                    .setCustomId(id3)\n                    .setDisabled(true);\n                let fbtn4 = new Discord.ButtonBuilder()\n                    .setLabel(\"4️⃣\")\n                    .setCustomId(id4)\n                    .setDisabled(true);\n\n                if (winningID === id1) {\n                    fbtn1.setStyle(Discord.ButtonStyle.Success);\n                    fbtn2.setStyle(Discord.ButtonStyle.Secondary);\n                    fbtn3.setStyle(Discord.ButtonStyle.Secondary);\n                    fbtn4.setStyle(Discord.ButtonStyle.Secondary);\n                } else if (winningID === id2) {\n                    fbtn1.setStyle(Discord.ButtonStyle.Secondary);\n                    fbtn2.setStyle(Discord.ButtonStyle.Success);\n                    fbtn3.setStyle(Discord.ButtonStyle.Secondary);\n                    fbtn4.setStyle(Discord.ButtonStyle.Secondary);\n                } else if (winningID === id3) {\n                    fbtn1.setStyle(Discord.ButtonStyle.Secondary);\n                    fbtn2.setStyle(Discord.ButtonStyle.Secondary);\n                    fbtn3.setStyle(Discord.ButtonStyle.Success);\n                    fbtn4.setStyle(Discord.ButtonStyle.Secondary);\n                } else if (winningID === id4) {\n                    fbtn1.setStyle(Discord.ButtonStyle.Secondary);\n                    fbtn2.setStyle(Discord.ButtonStyle.Secondary);\n                    fbtn3.setStyle(Discord.ButtonStyle.Secondary);\n                    fbtn4.setStyle(Discord.ButtonStyle.Success);\n                }\n\n                client.embed({\n                    title: `🕹️・Trivia`,\n                    desc: `Better luck next time! The correct answer was **${question.options[question.correct]}**.`,\n                    components: [{ type: 1, components: [fbtn1, fbtn2, fbtn3, fbtn4] }],\n                    type: 'editreply'\n                }, interaction)\n            }\n        });\n    })\n}\n\n ","size_bytes":15356},"src/commands/games/willyoupressthebutton.js":{"content":"const Discord = require('discord.js');\nconst { truncate } = require('fs/promises');\nconst { decode } = require('html-entities');\nconst fetch = require(\"node-fetch\");\n\nmodule.exports = async (client, interaction, args) => {\n    const getRandomString = (length) => {\n        const randomChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n        let result = '';\n        for (let i = 0; i < length; i++) {\n            result += randomChars.charAt(\n                Math.floor(Math.random() * randomChars.length),\n            );\n        }\n        return result;\n    };\n\n    const id1 =\n        getRandomString(20) +\n        '-' +\n        getRandomString(20) +\n        '-' +\n        getRandomString(20) +\n        '-' +\n        getRandomString(20);\n    const id2 =\n        getRandomString(20) +\n        '-' +\n        getRandomString(20) +\n        '-' +\n        getRandomString(20) +\n        '-' +\n        getRandomString(20);\n\n    fetch('https://api2.willyoupressthebutton.com/api/v2/dilemma ', {\n        method: 'POST',\n    }).then((data) => data.json()).then((data) => {\n        const res = {\n            questions: [data.dilemma.txt1, data.dilemma.txt2],\n            percentage: {\n                1: data.dilemma.yes,\n                2: data.dilemma.no,\n            },\n        };\n\n        let btn = new Discord.ButtonBuilder()\n            .setStyle(Discord.ButtonStyle.Success)\n            .setLabel(\"Yes\")\n            .setCustomId(id1);\n        let btn2 = new Discord.ButtonBuilder()\n            .setStyle(Discord.ButtonStyle.Danger)\n            .setLabel(\"No\")\n            .setCustomId(id2);\n\n        let row = new Discord.ActionRowBuilder()\n            .addComponents(btn, btn2);\n\n        client.embed({\n            title: `🤔・Will you press the button?`,\n            desc: `\\`\\`\\`${decode(res.questions[0].charAt(0).toUpperCase() + res.questions[0].slice(1))} \\`\\`\\`\\n**But** \\`\\`\\`\\n\\n${decode(res.questions[1].charAt(0).toUpperCase() + res.questions[1].slice(1))}\\`\\`\\``,\n            components: [row],\n            type: 'editreply'\n        }, interaction).then(async (m) => {\n            const collector = interaction.channel.createMessageComponentCollector({ componentType: Discord.ComponentType.Button });\n\n            collector.on('collect', (btn) => {\n                if (btn.user.id !== interaction.user.id) return;\n\n                btn.deferUpdate();\n                if (btn.customId === id1) {\n                    btn = new Discord.ButtonBuilder()\n                        .setStyle(Discord.ButtonStyle.Success)\n                        .setLabel(`Yes (${res.percentage['1']})`)\n                        .setCustomId(id1)\n                        .setDisabled(true);\n                    btn2 = new Discord.ButtonBuilder()\n                        .setStyle(Discord.ButtonStyle.Danger)\n                        .setLabel(`No (${res.percentage['2']})`)\n                        .setCustomId(id2)\n                        .setDisabled(true);\n                    collector.stop();\n\n                    client.embed({\n                        title: `🤔・Will you press the button?`,\n                        desc: `\\`\\`\\`${decode(res.questions[0].charAt(0).toUpperCase() + res.questions[0].slice(1))} \\`\\`\\`\\n**But** \\`\\`\\`\\n\\n${decode(res.questions[1].charAt(0).toUpperCase() + res.questions[1].slice(1))}\\`\\`\\``,\n                        components: [{ type: 1, components: [btn, btn2] }],\n                        type: 'editreply'\n                    }, interaction)\n                } else if (btn.customId === id2) {\n                    btn = new Discord.ButtonBuilder()\n                        .setStyle(Discord.ButtonStyle.Danger)\n                        .setLabel(`Yes (${res.percentage['1']})`)\n                        .setCustomId(id1)\n                        .setDisabled(true);\n                    btn2 = new Discord.ButtonBuilder()\n                        .setStyle(Discord.ButtonStyle.Success)\n                        .setLabel(`No (${res.percentage['2']})`)\n                        .setCustomId(id2)\n                        .setDisabled(true);\n                    collector.stop();\n\n                    client.embed({\n                        title: `🤔・Will you press the button?`,\n                        desc: `\\`\\`\\`${decode(res.questions[0].charAt(0).toUpperCase() + res.questions[0].slice(1))} \\`\\`\\`\\n**But** \\`\\`\\`\\n\\n${decode(res.questions[1].charAt(0).toUpperCase() + res.questions[1].slice(1))}\\`\\`\\``,\n                        components: [{ type: 1, components: [btn, btn2] }],\n                        type: 'editreply'\n                    }, interaction)\n                }\n            });\n        });\n    });\n}\n\n ","size_bytes":4643},"src/commands/games/wouldyourather.js":{"content":"const Discord = require('discord.js');\nconst { decode } = require('html-entities');\nconst axios = require('axios');\nconst cheerio = require('cheerio');\n\nmodule.exports = async (client, interaction, args) => {\n    const getRandomString = (length) => {\n        const randomChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n        let result = '';\n        for (let i = 0; i < length; i++) {\n            result += randomChars.charAt(\n                Math.floor(Math.random() * randomChars.length),\n            );\n        }\n        return result;\n    };\n\n    const fetchhtml = async (url) => {\n        const options = {\n            header: {\n                'user-agent':\n                    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36',\n                referer: 'https://www.google.com/',\n            },\n        };\n        const html = await axios.get(url, options);\n        return cheerio.load(html.data);\n    };\n\n    client.simpleEmbed({ \n        title: `${client.emotes.animated.loading}┆Loading...`,\n        type: 'editreply'\n    }, interaction).then(async msg => {\n\n        const id1 =\n            getRandomString(20) +\n            '-' +\n            getRandomString(20) +\n            '-' +\n            getRandomString(20) +\n            '-' +\n            getRandomString(20);\n        const id2 =\n            getRandomString(20) +\n            '-' +\n            getRandomString(20) +\n            '-' +\n            getRandomString(20) +\n            '-' +\n            getRandomString(20);\n\n        const $ = await fetchhtml('http://either.io');\n\n        const blue = $('div.result.result-1').children();\n        const red = $('div.result.result-2').children();\n\n        const res = {\n            questions: [blue.eq(3).text(), red.eq(3).text()],\n            percentage: {\n                1: blue.eq(1).text(),\n                2: red.eq(1).text(),\n            },\n        };\n\n        let btn = new Discord.ButtonBuilder()\n            .setStyle(Discord.ButtonStyle.Primary)\n            .setLabel(\"Option A\")\n            .setCustomId(id1);\n        let btn2 = new Discord.ButtonBuilder()\n            .setStyle(Discord.ButtonStyle.Primary)\n            .setLabel(\"Option B\")\n            .setCustomId(id2);\n\n        let row = new Discord.ActionRowBuilder()\n            .addComponents(btn, btn2);\n\n        client.embed({\n            title: `🤔・Would you rather...`,\n            desc: `**A)** ${decode(res.questions[0])} \\n**B)** ${decode(res.questions[1])}`,\n            components: [row],\n            type: 'editreply'\n        }, interaction).then(async (m) => {\n            const collector = interaction.channel.createMessageComponentCollector({ componentType: Discord.ComponentType.Button });\n\n            collector.on('collect', (btn) => {\n                if (btn.user.id !== interaction.user.id) return;\n\n                btn.deferUpdate();\n                if (btn.customId === id1) {\n                    btn = new Discord.ButtonBuilder()\n                        .setStyle(Discord.ButtonStyle.Primary)\n                        .setLabel(`Option A (${res.percentage['1']})`)\n                        .setCustomId(id1)\n                        .setDisabled(true);\n                    btn2 = new Discord.ButtonBuilder()\n                        .setStyle(Discord.ButtonStyle.Secondary)\n                        .setLabel(`Option B (${res.percentage['2']})`)\n                        .setCustomId(id2)\n                        .setDisabled(true);\n                    collector.stop();\n\n                    client.embed({\n                        title: `🤔・Would you rather...`,\n                        desc: `**A) ${decode(res.questions[0])} (${res.percentage['1']})** \\nB) ${decode(res.questions[1])} (${res.percentage['2']})`,\n                        components: [{ type: 1, components: [btn, btn2] }],\n                        type: 'editreply'\n                    }, interaction)\n                } else if (btn.customId === id2) {\n                    btn = new Discord.ButtonBuilder()\n                        .setStyle(Discord.ButtonStyle.Secondary)\n                        .setLabel(`Option A (${res.percentage['1']})`)\n                        .setCustomId(id1)\n                        .setDisabled(true);\n                    btn2 = new Discord.ButtonBuilder()\n                        .setStyle(Discord.ButtonStyle.Primary)\n                        .setLabel(`Option B (${res.percentage['2']})`)\n                        .setCustomId(id2)\n                        .setDisabled(true);\n                    collector.stop();\n\n                    client.embed({\n                        title: `🤔・Would you rather...`,\n                        desc: `A) ${decode(res.questions[0])} (${res.percentage['1']}) \\n**B) ${decode(res.questions[1])} (${res.percentage['2']})**`,\n                        components: [{ type: 1, components: [btn, btn2] }],\n                        type: 'editreply'\n                    }, interaction)\n                }\n            });\n        });\n    });\n}\n\n ","size_bytes":5045},"src/commands/giveaway/delete.js":{"content":"const Discord = require('discord.js');\nconst ms = require('ms');\n\nmodule.exports = async (client, interaction, args) => {\n    const messageID = interaction.options.getString('message');\n    const giveaway = client.giveawaysManager.giveaways.find((g) => g.guildId === interaction.guildId && g.messageId === messageID);\n    if (!giveaway) return client.errNormal({ error: \"This message ID is not from this guild\", type: 'editreply' }, interaction)\n    client.giveawaysManager.delete(messageID).then(() => {\n        client.succNormal({\n            text: `The giveaway has been successfully removed`,\n            type: 'editreply'\n        }, interaction);\n    }).catch((err) => {\n        client.errNormal({\n            error: `I can't find the giveaway for ${messageID}!`,\n            type: 'editreply'\n        }, interaction)\n    });\n}\n\n ","size_bytes":835},"src/commands/giveaway/drop.js":{"content":"const Discord = require('discord.js');\nconst ms = require('ms');\n\nmodule.exports = async (client, interaction, args) => {\n    const gchannel = interaction.options.getChannel('channel');\n    const duration = interaction.options.getString('duration');\n    const winnerCount = interaction.options.getNumber('winners');\n    const prize = interaction.options.getString('prize');\n\n    client.giveawaysManager.start(gchannel, {\n        duration: ms(duration),\n        prize: `${client.emotes.normal.gift} - ${prize}`,\n        lastChance: {\n            enabled: true,\n            content: `${client.emotes.normal.error} **LAST CHANCE TO ENTER !** ${client.emotes.normal.error}`,\n            threshold: 5000,\n            embedColor: '#FF0000'\n        },\n        pauseOptions: {\n            isPaused: true,\n            content: '⚠️ **THIS GIVEAWAY IS PAUSED !** ⚠️',\n            unPauseAfter: null,\n            embedColor: '#FFFF00'\n        },\n        winnerCount: parseInt(winnerCount),\n        hostedBy: interaction.user,\n        thumbnail: interaction.guild.iconURL({ dynamic: true, size: 1024 }),\n        isDrop: true,\n        messages: {\n            giveaway: `${client.emotes.normal.party} **GIVEAWAY** ${client.emotes.normal.party}`,\n            giveawayEnded: `${client.emotes.normal.party} **GIVEAWAY ENDED** ${client.emotes.normal.party}`,\n            drawing: `${client.emotes.normal.clock} - Ends at: **{timestamp}**!`,\n            dropMessage: `Be the first to react with 🥳`,\n            winMessage: \"Congratulations {winners}! You just won the **{this.prize}** !\",\n            embedFooter: \"Giveaway!\",\n            embedColor: client.config.colors.normal,\n            noWinner: \"Giveaway canceled, not enough participants. \\n\",\n            hostedBy: `${client.emotes.normal.party} - Hosted by: {this.hostedBy}`,\n            winners: `🏆 - Winner(s)`,\n            endedAt: \"Ends at:\",\n            units: {\n                seconds: \"seconds\",\n                minutes: \"minutes\",\n                hours: \"hours\",\n                days: \"days\",\n                pluralS: false\n            },\n        },\n\n    }).then((gData) => {\n        client.succNormal({ \n            text: `Giveaway started in ${gchannel}`,\n            type: 'ephemeraledit'\n        }, interaction);\n    });\n}\n\n ","size_bytes":2292},"src/commands/giveaway/edit.js":{"content":"const Discord = require('discord.js');\nconst ms = require('ms');\n\nmodule.exports = async (client, interaction, args) => {\n    const messageID = interaction.options.getString('message');\n    const giveaway = client.giveawaysManager.giveaways.find((g) => g.guildId === interaction.guildId && g.messageId === messageID);\n    if (!giveaway) return client.errNormal({ error: \"This message ID is not from this guild\", type: 'editreply' }, interaction)\n    client.giveawaysManager.edit(messageID, {\n        addTime: 5000,\n    }).then(() => {\n        const numberOfSecondsMax = client.giveawaysManager.options.updateCountdownEvery / 1000;\n        client.succNormal({\n            text: `Giveaway will updated in less than ${numberOfSecondsMax} seconds`,\n            type: 'editreply'\n        }, interaction);\n    }).catch((err) => {\n        client.errNormal({\n            error: `I can't find the giveaway for ${messageID}!`,\n            type: 'editreply'\n        }, interaction)\n    });\n}\n\n ","size_bytes":983},"src/commands/giveaway/end.js":{"content":"const Discord = require('discord.js');\nconst ms = require('ms');\n\nmodule.exports = async (client, interaction, args) => {\n    const messageID = interaction.options.getString('message');\n    const giveaway = client.giveawaysManager.giveaways.find((g) => g.guildId === interaction.guildId && g.messageId === messageID);\n    if (!giveaway) return client.errNormal({ error: \"This message ID is not from this guild\", type: 'editreply' }, interaction)\n    client.giveawaysManager.edit(messageID, {\n        setEndTimestamp: Date.now()\n    }).then(() => {\n        client.succNormal({\n            text: `Giveaway wil end in less than ${client.giveawaysManager.options.updateCountdownEvery / 1000} seconds`,\n            type: 'editreply'\n        }, interaction);\n    }).catch((err) => {\n        client.errNormal({\n            error: `I can't find the giveaway for ${messageID}!`,\n            type: 'editreply'\n        }, interaction)\n    });\n}\n\n ","size_bytes":936},"src/commands/giveaway/pause.js":{"content":"const Discord = require('discord.js');\nconst ms = require('ms');\n\nmodule.exports = async (client, interaction, args) => {\n    const messageID = interaction.options.getString('message');\n    const giveaway = client.giveawaysManager.giveaways.find((g) => g.guildId === interaction.guildId && g.messageId === messageID);\n    if (!giveaway) return client.errNormal({ error: \"This message ID is not from this guild\", type: 'editreply' }, interaction)\n    client.giveawaysManager.pause(messageID).then(() => {\n        client.succNormal({ \n            text: `Giveaway paused!`, \n            type: 'editreply' \n        }, interaction);\n    }).catch((err) => {\n        client.errNormal({ \n            error: `I can't find the giveaway for ${messageID}!`, \n            type: 'editreply' \n        }, interaction)\n    });\n}\n\n ","size_bytes":814},"src/commands/giveaway/reroll.js":{"content":"const Discord = require('discord.js');\nconst ms = require('ms');\n\n/**\n * \n * @param {Discord.Client} client \n * @param {Discord.Interaction} interaction \n * @param {*} args \n * @returns \n */\nmodule.exports = async (client, interaction, args) => {\n    const messageID = interaction.options.getString('message');\n    const giveaway = client.giveawaysManager.giveaways.find((g) => g.guildId === interaction.guildId && g.messageId === messageID);\n    if (!giveaway) return client.errNormal({ error: \"This message ID is not from this guild\", type: 'editreply' }, interaction)\n    client.giveawaysManager.reroll(messageID).then(() => {\n        client.succNormal({\n            text: `Giveaway gererolled`,\n            type: 'editreply'\n        }, interaction);\n    }).catch((err) => {\n        client.errNormal({\n            error: `I can't find the giveaway for ${messageID}!`,\n            type: 'editreply'\n        }, interaction)\n    });\n}\n\n","size_bytes":936},"src/commands/giveaway/start.js":{"content":"const Discord = require('discord.js');\nconst ms = require('ms');\n\nmodule.exports = async (client, interaction, args) => {\n    const gchannel = interaction.options.getChannel('channel');\n    const duration = interaction.options.getString('duration');\n    const winnerCount = interaction.options.getNumber('winners');\n    const prize = interaction.options.getString('prize');\n\n    client.giveawaysManager.start(gchannel, {\n        duration: ms(duration),\n        prize: `${client.emotes.normal.gift} - ${prize}`,\n        lastChance: {\n            enabled: true,\n            content: `${client.emotes.normal.error} **LAST CHANCE TO ENTER !** ${client.emotes.normal.error}`,\n            threshold: 5000,\n            embedColor: '#FF0000'\n        },\n        pauseOptions: {\n            isPaused: false,\n            content: '⚠️ **THIS GIVEAWAY IS PAUSED !** ⚠️',\n            unPauseAfter: null,\n            embedColor: '#FFFF00'\n        },\n        winnerCount: parseInt(winnerCount),\n        hostedBy: interaction.user,\n        thumbnail: interaction.guild.iconURL({ dynamic: true, size: 1024 }),\n        messages: {\n            giveaway: `${client.emotes.normal.party} **GIVEAWAY** ${client.emotes.normal.party}`,\n            giveawayEnded: `${client.emotes.normal.party} **GIVEAWAY ENDED** ${client.emotes.normal.party}`,\n            drawing: `${client.emotes.normal.clock} - Ends at: **{timestamp}**!`,\n            inviteToParticipate: \"React with 🥳 to enter the giveaway! \\n\",\n            winMessage: \"Congratulations {winners}! You just won the **{this.prize}** !\",\n            embedFooter: \"Giveaway!\",\n            embedColor: client.config.colors.normal,\n            noWinner: \"Giveaway canceled, not enough participants. \\n\",\n            hostedBy: `${client.emotes.normal.party} - Hosted by: {this.hostedBy}`,\n            winners: `🏆 - Winner(s)`,\n            endedAt: \"Ends at:\",\n            units: {\n                seconds: \"seconds\",\n                minutes: \"minutes\",\n                hours: \"hours\",\n                days: \"days\",\n                pluralS: false\n            },\n        },\n\n    }).then((gData) => {\n        client.succNormal({ \n            text: `Giveaway started in ${gchannel}`,\n            type: 'ephemeraledit'\n        }, interaction);\n    });\n}\n\n ","size_bytes":2289},"src/commands/giveaway/unpause.js":{"content":"const Discord = require('discord.js');\nconst ms = require('ms');\n\nmodule.exports = async (client, interaction, args) => {\n    const messageID = interaction.options.getString('message');\n    const giveaway = client.giveawaysManager.giveaways.find((g) => g.guildId === interaction.guildId && g.messageId === messageID);\n    if (!giveaway) return client.errNormal({ error: \"This message ID is not from this guild\", type: 'editreply' }, interaction)\n    client.giveawaysManager.unpause(messageID).then(() => {\n        client.succNormal({\n            text: `Giveaway unpaused!`,\n            type: 'editreply'\n        }, interaction);\n    }).catch((err) => {\n        client.errNormal({\n            error: `I can't find the giveaway for ${messageID}!`,\n            type: 'editreply'\n        }, interaction)\n    });\n}\n\n ","size_bytes":812},"src/commands/guild/channelinfo.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n  const channel = interaction.options.getChannel('channel');\n\n  client.embed({\n      title: `ℹ・Channel information`,\n      desc: `Channel information about: <#${channel.id}>`,\n      fields: [\n          {\n              name: \"Type\",\n              value: `${channel.type}`,\n              inline: true,\n          },\n          {\n              name: \"ID\",\n              value: `${channel.id}`,\n              inline: true,\n          },\n          {\n              name: \"Type\",\n              value: `${channel.type}`,\n              inline: true,\n          },\n          {\n              name: \"Made on\",\n              value: `${channel.createdAt}`,\n              inline: true,\n          },\n          {\n              name: \"Subject\",\n              value: `${channel.topic ? channel.topic : 'N/A'}`,\n              inline: true,\n          },\n          {\n              name: \"NSFW\",\n              value: `${channel.nsfw}`,\n              inline: true,\n          },\n          {\n              name: \"Parent\",\n              value: `${channel.parentID ? channel.parentID : 'N/A'}`,\n              inline: true,\n          },\n      ],\n      type: 'editreply'\n  }, interaction)\n}\n\n   ","size_bytes":1261},"src/commands/guild/emojis.js":{"content":"const Discord = require('discord.js');\nconst axios = require(\"axios\");\n\nconst model = require('../../database/models/badge');\n\nmodule.exports = async (client, interaction, args) => {\n  let Emojis = \"\";\n  let EmojisAnimated = \"\";\n  let EmojiCount = 0;\n  let Animated = 0;\n  let OverallEmojis = 0;\n\n  function Emoji(id) {\n    return client.emojis.cache.get(id).toString();\n  }\n\n  interaction.guild.emojis.cache.forEach((emoji) => {\n    OverallEmojis++;\n    if (emoji.animated) {\n      Animated++;\n      EmojisAnimated += Emoji(emoji.id);\n    } else {\n      EmojiCount++;\n      Emojis += Emoji(emoji.id);\n    }\n  });\n\n  client.embed({\n    title: `😛・Emoji's!`,\n    desc: `${OverallEmojis} Emoji's - ${interaction.guild.name}`,\n    fields: [\n      {\n        name: `Animated [${Animated}]`,\n        value: EmojisAnimated.substr(0, 1021) + \"...\",\n        inline: false,\n      },\n      {\n        name: `Standard [${EmojiCount}]`,\n        value: Emojis.substr(0, 1021) + \"...\",\n        inline: false,\n      },\n    ],\n    type: 'editreply'\n  }, interaction)\n}\n\n ","size_bytes":1057},"src/commands/guild/info.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n  let verifLevels = {\n    \"NONE\": \"None\",\n    \"LOW\": \"Low\",\n    \"MEDIUM\": \"Medium\",\n    \"HIGH\": \"(╯°□°）╯︵  ┻━┻\",\n    \"VERY_HIGH\": \"┻━┻ミヽ(ಠ益ಠ)ノ彡┻━┻\"\n  }\n\n  let region = {\n    \"brazil\": `:flag_br: `,\n    \"eu-central\": `:flag_eu: `,\n    \"singapore\": `:flag_sg: `,\n    \"us-central\": `:flag_us: `,\n    \"sydney\": `:flag_au: `,\n    \"us-east\": `:flag_us: `,\n    \"us-south\": `:flag_us: `,\n    \"us-west\": `:flag_us: `,\n    \"eu-west\": `:flag_eu: `,\n    \"vip-us-east\": `:flag_us: `,\n    \"europe\": `:flag_gb:`,\n    \"amsterdam\": `:flag_nl:`,\n    \"hongkong\": `:flag_hk: `,\n    \"russia\": `:flag_ru: `,\n    \"southafrica\": `:flag_za: `\n  }\n\n  let tier = {\n    \"TIER_1\": `1`,\n    \"TIER_2\": `2`,\n    \"TIER_3\": `3`,\n    \"NONE\": `0`,\n  }\n\n  const members = await interaction.guild.members.fetch();\n\n  client.embed({\n    title: `ℹ️・Server Information`,\n    desc: `Information about the server ${interaction.guild.name}`,\n    thumbnail: interaction.guild.iconURL({ dynamic: true, size: 1024 }),\n    image: interaction.guild.bannerURL({ size: 1024 }),\n    fields: [\n      {\n        name: \"Server name:\",\n        value: `${interaction.guild.name}`,\n        inline: true,\n      },\n      {\n        name: \"Server id:\",\n        value: `${interaction.guild.id}`,\n        inline: true,\n      },\n      {\n        name: \"Owner: \",\n        value: `<@!${interaction.guild.ownerId}>`,\n        inline: true\n      },\n      {\n        name: \"Verify level: \",\n        value: `${verifLevels[interaction.guild.verificationLevel]}`,\n        inline: true\n      },\n      {\n        name: \"Boost tier: \",\n        value: `Tier ${tier[interaction.guild.premiumTier] || 'None'}`,\n        inline: true\n      },\n      {\n        name: \"Boost count:\",\n        value: `${interaction.guild.premiumSubscriptionCount || '0'} boosts`,\n        inline: true\n      },\n      {\n        name: \"Created on:\",\n        value: `<t:${Math.round(interaction.guild.createdTimestamp / 1000)}>`,\n        inline: true\n      },\n      {\n        name: \"Members:\",\n        value: `${interaction.guild.memberCount} members!`,\n        inline: true\n      },\n      {\n        name: \"Bots:\",\n        value: `${members.filter(member => member.user.bot).size} bots!`,\n        inline: true\n      },\n      {\n        name: \"Text Channels: \",\n        value: `${interaction.guild.channels.cache.filter(channel => channel.type === Discord.ChannelType.GuildText).size} channels!`,\n        inline: true\n      },\n      {\n        name: \"Voice Channels:\",\n        value: `${interaction.guild.channels.cache.filter(channel => channel.type ===  Discord.ChannelType.GuildVoice).size} channels!`,\n        inline: true\n      },\n      {\n        name: \"Stage Channels:\",\n        value: `${interaction.guild.channels.cache.filter(channel => channel.type ===  Discord.ChannelType.GuildStageVoice).size} channels!`,\n        inline: true\n      },\n      {\n        name: \"News Channels:\",\n        value: `${interaction.guild.channels.cache.filter(channel => channel.type ===  Discord.ChannelType.GuildAnnouncement).size} channels!`,\n        inline: true\n      },\n      {\n        name: \"Public Threads:\",\n        value: `${interaction.guild.channels.cache.filter(channel => channel.type === 'GUILD_PUBLIC_THREAD').size} threads!`,\n        inline: true\n      },\n      {\n        name: \"Private Threads:\",\n        value: `${interaction.guild.channels.cache.filter(channel => channel.type === 'GUILD_PRIVATE_THREAD').size} threads!`,\n        inline: true\n      },\n      {\n        name: \"Roles:\",\n        value: `${interaction.guild.roles.cache.size} roles!`,\n        inline: true\n      },\n      {\n        name: \"Emoji count:\",\n        value: `${interaction.guild.emojis.cache.size} emoji's`,\n        inline: true\n      },\n      {\n        name: \"Sticker count:\",\n        value: `${interaction.guild.stickers.cache.size} stickers`,\n        inline: true\n      }\n    ],\n    type: 'editreply'\n  }, interaction)\n}\n\n   ","size_bytes":4039},"src/commands/guild/inviteinfo.js":{"content":"const Discord = require('discord.js');\nconst axios = require(\"axios\");\n\nconst model = require('../../database/models/badge');\n\nmodule.exports = async (client, interaction, args) => {\n  const invite = interaction.options.getString('invite');\n\n  const verifyFlags = {\n    0: `Unrestricted`,\n    1: `Must have verified email on account`,\n    2: `Must be registered on Discord for longer than 5 minutes`,\n    3: `Must be a member of the server for longer than 10 minutes`,\n    4: `Must have a verified phone number`\n  }\n\n  axios.get(`https://discord.com/api/v9/invites/${encodeURIComponent(invite)}`).catch(async () => {\n    return client.errNormal({\n      error: \"I couldn't find the server\",\n      type: 'editreply'\n    }, interaction)\n  }).then(async (raw) => {\n    const { data } = raw;\n    if (!data) return;\n\n    let guildTimestamp = (await toUnix(data.guild.id)).timestamp;\n    let channelTimestamp = (await toUnix(data.channel.id)).timestamp;\n\n    return client.embed({\n      title: `📨・Invite information`,\n      thumbnail: `https://cdn.discordapp.com/icons/${data.guild.id}/${data.guild.icon}.png?size=1024`,\n      image: `https://cdn.discordapp.com/banners/${data.guild.id}/${data.guild.banner}.png?size=1024`,\n      fields: [\n        {\n          name: \"Server Name\",\n          value: `${data.guild.name}`,\n          inline: true,\n        },\n        {\n          name: \"Server ID\",\n          value: `${data.guild.id}`,\n          inline: true,\n        },\n        {\n          name: \"Server Created\",\n          value: `<t:${guildTimestamp}>`,\n          inline: true,\n        },\n        {\n          name: \"Channel Name\",\n          value: `${data.channel.name}`,\n          inline: true,\n        },\n        {\n          name: \"Channel ID\",\n          value: `${data.channel.id}`,\n          inline: true,\n        },\n        {\n          name: \"Channel Created\",\n          value: `<t:${channelTimestamp}>`,\n          inline: true,\n        },\n        {\n          name: \"Server Images\",\n          value: `${data.guild.icon && data.guild.banner && data.guild.splash ? `` : `No data`}\n          ${data.guild.icon ? `[Server Icon](https://cdn.discordapp.com/icons/${data.guild.id}/${data.guild.icon}.png?size=4096)` : ``}\n          ${data.guild.banner ? `[Server Banner](https://cdn.discordapp.com/banners/${data.guild.id}/${data.guild.banner}.png?size=4096)` : ``}`,\n          inline: true,\n        },\n        {\n          name: \"Server Verification Level\",\n          value: `${verifyFlags[data.guild.verification_level]}`,\n          inline: true,\n        },\n      ],\n      type: 'editreply'\n    }, interaction)\n  })\n}\n\nconst toUnix = (snowflake) => {\n  const EPOCH = 1420070400000;\n  const BINARY = idToBinary(snowflake.toString()).toString(2).padStart(64, '0');\n  let timestamp = parseInt(((parseInt(BINARY.substring(0, 42), 2) + EPOCH).toString().substring(0, (parseInt(BINARY.substring(0, 42), 2) + EPOCH).toString().length - 3)));\n  let timestampms = parseInt(BINARY.substring(0, 42), 2) + EPOCH;\n  const date = new Date(timestampms);\n  const data = {\n    timestamp,\n    timestampms,\n    date\n  }\n  return data\n}\n\nconst idToBinary = (num) => {\n  let bin = '';\n  let high = parseInt(num.slice(0, -10)) || 0;\n  let low = parseInt(num.slice(-10));\n  while (low > 0 || high > 0) {\n    bin = String(low & 1) + bin;\n    low = Math.floor(low / 2);\n    if (high > 0) {\n      low += 5000000000 * (high % 2);\n      high = Math.floor(high / 2);\n    }\n  }\n  return bin;\n}\n\n   ","size_bytes":3463},"src/commands/guild/members.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n  const members = await interaction.guild.members.fetch();\n\n  client.embed({\n    title: `👤・Membercount`,\n    desc: `View the total number of members in the server`,\n    fields: [\n      {\n        name: `👤┆Members`,\n        value: `${members.filter(member => !member.user.bot).size} members`,\n        inline: true\n      },\n      {\n        name: `🤖┆Bots`,\n        value: `${members.filter(member => member.user.bot).size} bots`,\n        inline: true\n      },\n      {\n        name: `📘┆Total`,\n        value: `${interaction.guild.memberCount} members`,\n        inline: true\n      }\n    ],\n    type: 'editreply'\n  }, interaction)\n}\n\n   ","size_bytes":746},"src/commands/guild/oldestmember.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n  const members = await interaction.guild.members.fetch()\n  const getMember = members.filter(m => !m.user.bot)\n    .sort((a, b) => a.user.createdAt - b.user.createdAt);\n\n  const member = Array.from(getMember.values());\n\n  client.embed({\n    title: `👴・Oldest member`,\n    desc: `See who is the oldest member in **${interaction.guild.name}**`,\n    fields: [\n      {\n        name: `👤┆User`,\n        value: `${member[0]} (${member[0].user.username}#${member[0].user.discriminator})`,\n        inline: true\n      },\n      {\n        name: `⏰┆Account creation`,\n        value: `<t:${Math.round(member[0].user.createdTimestamp / 1000)}>`,\n        inline: true\n      },\n    ],\n    type: 'editreply'\n  }, interaction)\n}\n\n   ","size_bytes":823},"src/commands/guild/roleinfo.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n  const role = interaction.options.getRole('role');\n  const perms = role.permissions.toArray();\n\n  client.embed({\n    title: `ℹ️・Role information`,\n    thumbnail: interaction.guild.iconURL({ dynamic: true, size: 1024 }),\n    desc: `Information about the role ${role}`,\n    fields: [\n      {\n        name: 'Role ID:',\n        value: `${role.id}`,\n        inline: true\n      },\n      {\n        name: 'Role Name:',\n        value: `${role.name}`,\n        inline: true\n      },\n      {\n        name: 'Mentionable:',\n        value: `${role.mentionable ? 'Yes' : 'No'}`,\n        inline: true\n      },\n      {\n        name: 'Role Permissions:',\n        value: `${perms.join(', ')}`\n      }\n    ],\n    type: 'editreply'\n  }, interaction)\n}\n\n   ","size_bytes":837},"src/commands/guild/stealemoji.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n  const perms = await client.checkPerms({\n    flags: [Discord.PermissionsBitField.Flags.ManageEmojisAndStickers],\n    perms: [Discord.PermissionsBitField.Flags.ManageEmojisAndStickers]\n  }, interaction)\n\n  if (perms == false) return;\n\n  const rawEmoji = interaction.options.getString('emoji');\n  const role = interaction.options.getRole('role');\n  const parsedEmoji = Discord.parseEmoji(rawEmoji);\n\n  if (parsedEmoji.id) {\n    const extension = parsedEmoji.animated ? \".gif\" : \".png\";\n    const url = `https://cdn.discordapp.com/emojis/${parsedEmoji.id + extension}`;\n    if (role) {\n\n      interaction.guild.emojis.create({ attachment: url, name: parsedEmoji.name, roles: [role.id] }).then(emoji => {\n        client.succNormal({\n          text: `Emoji successfully added to the server`,\n          fields: [\n            {\n              name: \"😛┇Emoji\",\n              value: `${emoji}`,\n              inline: true,\n            },\n            {\n              name: \"😜┇Emoji name\",\n              value: `${emoji.name}`,\n              inline: true,\n            },\n            {\n              name: \"😝┇Emoji id\",\n              value: `${emoji.id}`,\n              inline: true,\n            },\n          ],\n          type: 'editreply'\n        }, interaction)\n      })\n    }else{\n      interaction.guild.emojis.create({ attachment: url, name: parsedEmoji.name }).then(emoji => {\n        client.succNormal({\n          text: `Emoji successfully added to the server`,\n          fields: [\n            {\n              name: \"😛┇Emoji\",\n              value: `${emoji}`,\n              inline: true,\n            },\n            {\n              name: \"😜┇Emoji name\",\n              value: `${emoji.name}`,\n              inline: true,\n            },\n            {\n              name: \"😝┇Emoji id\",\n              value: `${emoji.id}`,\n              inline: true,\n            },\n          ],\n          type: 'editreply'\n        }, interaction)\n      })\n    }\n  }\n  else {\n    client.errNormal({\n      error: \"Emoji not found!\",\n      type: 'editreply'\n    }, interaction)\n  }\n}\n\n","size_bytes":2182},"src/commands/guild/userinfo.js":{"content":"const Discord = require('discord.js');\nconst axios = require(\"axios\");\n\nconst model = require('../../database/models/badge');\n\nmodule.exports = async (client, interaction, args) => {\n  const member = await interaction.guild.members.fetch(interaction.options.getUser('user').id);\n  if(!member) return client.errNormal({\n    error: \"This user is not in this guild!\",\n    type: 'editreply'\n  }, interaction);\n  const badgeFlags = {\n    DEVELOPER: client.emotes.badges.developer,\n    BUGS: client.emotes.badges.bug,\n    MANAGEMENT: client.emotes.badges.management,\n    PREMIUM: client.emotes.badges.premium,\n    SUPPORTER: client.emotes.badges.supporter,\n    TEAM: client.emotes.badges.team,\n    BOOSTER: client.emotes.badges.booster,\n    PARTNER: client.emotes.badges.partner,\n    VOTER: client.emotes.badges.voter,\n    SUPPORT: client.emotes.badges.support,\n    MODERATOR: client.emotes.badges.moderator,\n    DESIGNER: client.emotes.badges.designer,\n    MARKETING: client.emotes.badges.marketing\n  }\n\n  const flags = {\n    ActiveDeveloper: \"👨‍💻・Active Developer\",\n    BugHunterLevel1: \"🐛・Discord Bug Hunter\",\n    BugHunterLevel2: \"🐛・Discord Bug Hunter\",\n    CertifiedModerator: \"👮‍♂️・Certified Moderator\",\n    HypeSquadOnlineHouse1: \"🏠・House Bravery Member\",\n    HypeSquadOnlineHouse2: \"🏠・House Brilliance Member\",\n    HypeSquadOnlineHouse3: \"🏠・House Balance Member\",\n    HypeSquadEvents: \"🏠・HypeSquad Events\",\n    PremiumEarlySupporter: \"👑・Early Supporter\",\n    Partner: \"👑・Partner\",\n    Quarantined: \"🔒・Quarantined\", // Not sure if this is still a thing\n    Spammer: \"🔒・Spammer\", // Not sure if this one works\n    Staff: \"👨‍💼・Discord Staff\",\n    TeamPseudoUser: \"👨‍💼・Discord Team\",\n    VerifiedBot: \"🤖・Verified Bot\",\n    VerifiedDeveloper: \"👨‍💻・(early)Verified Bot Developer\",\n  }\n\n  let Badges = await model.findOne({ User: member.user.id });\n  if (!Badges) Badges = { User: member.user.id }\n  const roles = member.roles.cache\n    .sort((a, b) => b.position - a.position)\n    .map(role => role.toString())\n    .slice(0, -1);\n  const userFlags = member.user.flags ? member.user.flags.toArray() : [];\n\n  return client.embed({\n    title: `👤・User information`,\n    desc: `Information about ${member.user.username}`,\n    thumbnail: member.user.displayAvatarURL({ dynamic: true, size: 1024 }),\n    image: member.user.bannerURL({ dynamic: true, size: 1024 }),\n    fields: [\n      {\n        name: \"Username\",\n        value: `${member.user.username}`,\n        inline: true,\n      },\n      {\n        name: \"Discriminator\",\n        value: `${member.user.discriminator}`,\n        inline: true,\n      },\n      {\n        name: \"Nickname\",\n        value: `${member.nickname || 'No nickname'}`,\n        inline: true,\n      },\n      {\n        name: \"Id\",\n        value: `${member.user.id}`,\n        inline: true,\n      },\n      {\n        name: \"Flags\",\n        value: `${userFlags.length ? userFlags.map(flag => flags[flag]).join(', ') : 'None'}`,\n        inline: true,\n      },\n      {\n        name: \"Badges\",\n        value: `${Badges.FLAGS ? Badges.FLAGS.map(flag => badgeFlags[flag]).join(' ') : 'None'}`,\n        inline: true,\n      },\n      {\n        name: \"Discord joined at\",\n        value: `<t:${Math.round(member.user.createdTimestamp / 1000)}>`,\n        inline: true,\n      },\n      {\n        name: \"Server joined at\",\n        value: `<t:${Math.round(member.joinedAt / 1000)}>`,\n        inline: true,\n      },\n      {\n        name: `Roles [${roles.length}]`,\n        value: `${roles.length ? roles.join(', ') : 'None'}`,\n        inline: false,\n      }\n    ],\n    type: 'editreply'\n  }, interaction)\n}\n\n   ","size_bytes":3710},"src/commands/guild/youngestmember.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n  const members = await interaction.guild.members.fetch()\n  const getMember = members.filter(m => !m.user.bot)\n    .sort((a, b) => b.user.createdAt - a.user.createdAt);\n\n  const member = Array.from(getMember.values());\n\n  client.embed({\n    title: `👶・Youngest member`,\n    desc: `See who is the youngest member in **${interaction.guild.name}**`,\n    fields: [\n      {\n        name: `👤┆User`,\n        value: `${member[0]} (${member[0].user.username}#${member[0].user.discriminator})`,\n        inline: true\n      },\n      {\n        name: `⏰┆Account creation`,\n        value: `<t:${Math.round(member[0].user.createdTimestamp / 1000)}>`,\n        inline: true\n      },\n    ],\n    type: 'editreply'\n  }, interaction)\n}\n\n   ","size_bytes":827},"src/commands/images/ad.js":{"content":"const Discord = require('discord.js');\nconst pop = require(\"popcat-wrapper\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    const member = interaction.options.getUser('user');\n\n    const userAvatar = member.displayAvatarURL({ dynamic: false, size: 1024, extension: 'png' });\n\n    const image = await pop.ad(userAvatar);\n    let attach = new Discord.AttachmentBuilder(image, { name: \"ad.png\" });\n\n    const embed = client.templateEmbed().setImage(\"attachment://ad.png\");\n    interaction.editReply({ files: [attach], embeds: [embed] });\n}","size_bytes":552},"src/commands/images/avatar.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n  const user = interaction.options.getUser('user') || interaction.user;\n\n  client.embed({\n    title: `🖼・User avatar`,\n    image: user.displayAvatarURL({ dynamic: false, size: 1024 }),\n    type: 'editreply'\n  }, interaction)\n}\n\n ","size_bytes":290},"src/commands/images/banner.js":{"content":"const Discord = require('discord.js');\nconst axios = require(\"axios\");\n\nmodule.exports = async (client, interaction, args) => {\n  const user = interaction.options.getUser('user') || interaction.user;\n\n  axios.get(`https://discord.com/api/users/${user.id}`, {\n    headers: {\n      Authorization: `Bot ${client.token}`,\n    },\n  }).then(res => {\n    const { banner, accent_color } = res.data;\n\n    if (banner) {\n      const extension = banner.startsWith(\"a_\") ? \".gif\" : \".png\";\n      const url = `https://cdn.discordapp.com/banners/${user.id}/${banner}${extension}?size=1024`;\n\n      client.embed({\n        title: `🖼・User Banner`,\n        image: url,\n        type: 'editreply'\n      }, interaction)\n    }\n    else {\n      if (accent_color) {\n\n        client.embed({\n          title: `🖼・User Banner`,\n          desc: `${user} doesn't have a banner but they do have a accent color`,\n          color: accent_color,\n          type: 'editreply'\n        }, interaction)\n      }\n      else {\n        client.embed({\n          title: `🖼・User Banner`,\n          desc: `${user} doesn't have a banner but they do have a accent color`,\n          color: accent_color,\n          type: 'editreply'\n        }, interaction)\n      }\n    }\n  })\n}\n\n ","size_bytes":1243},"src/commands/images/bed.js":{"content":"const Discord = require('discord.js');\nconst { Canvas } = require(\"canvacord\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    const member = interaction.options.getUser('user');\n\n    const userAvatar = member.displayAvatarURL({ dynamic: false, size: 1024, extension: 'png' });\n\n    const img = await Canvas.bed(interaction.user.avatarURL({ size: 1024, extension: 'png' }), userAvatar);\n\n    let attach = new Discord.AttachmentBuilder(img, { name: \"bed.png\" });\n    const embed = client.templateEmbed().setImage(\"attachment://bed.png\");\n    interaction.editReply({ files: [attach], embeds: [embed] });\n}\n\n","size_bytes":620},"src/commands/images/bird.js":{"content":"const Discord = require('discord.js');\nconst fetch = require(\"node-fetch\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    fetch(\n        `https://some-random-api.ml/img/bird`\n    )\n        .then((res) => res.json()).catch({})\n        .then(async (json) => {\n            client.embed({\n                title: `🐦・Random Bird`,\n                image: json.link,\n                type: 'editreply'\n            }, interaction)\n        }).catch({})\n}\n\n ","size_bytes":467},"src/commands/images/blur.js":{"content":"const Discord = require('discord.js');\nconst { Canvas } = require(\"canvacord\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    const member = interaction.options.getUser('user');\n\n    const userAvatar = member.displayAvatarURL({ dynamic: false, size: 1024, extension: 'png' });\n\n    const lvl = 4\n\n    const img = await Canvas.blur(userAvatar, lvl)\n\n    let attach = new Discord.AttachmentBuilder(img, { name: \"blurred.png\" });\n    const embed = client.templateEmbed().setImage(\"attachment://blurred.png\");\n    interaction.editReply({ files: [attach], embeds: [embed] });\n}\n\n","size_bytes":590},"src/commands/images/burn.js":{"content":"const Discord = require('discord.js');\nconst { Canvas } = require(\"canvacord\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    const member = interaction.options.getUser('user');\n\n    const userAvatar = member.displayAvatarURL({ dynamic: false, size: 1024, extension: 'png' });\n\n    const lvl = 4\n\n    const img = await Canvas.burn(userAvatar, lvl);\n\n    let attach = new Discord.AttachmentBuilder(img, { name: \"burn.png\" });\n    const embed = client.templateEmbed().setImage(\"attachment://burn.png\");\n    interaction.editReply({ files: [attach], embeds: [embed] });\n}\n\n","size_bytes":585},"src/commands/images/car.js":{"content":"const Discord = require('discord.js');\nconst pop = require(\"popcat-wrapper\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    const image = await pop.car();\n    let attach = new Discord.AttachmentBuilder(image.image, { name: \"car.png\" });\n\n    const embed = client.templateEmbed().setImage(\"attachment://car.png\");\n    interaction.editReply({ files: [attach], embeds: [embed] });\n};","size_bytes":396},"src/commands/images/cat.js":{"content":"const Discord = require('discord.js');\nconst fetch = require(\"node-fetch\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    fetch(\n        `https://some-random-api.ml/img/cat`\n    )\n        .then((res) => res.json()).catch({})\n        .then(async (json) => {\n            client.embed({\n                title: `🐱・Random Cat`,\n                image: json.link,\n                type: 'editreply'\n            }, interaction)\n        }).catch({})\n}\n\n \n","size_bytes":466},"src/commands/images/clown.js":{"content":"const Discord = require('discord.js');\nconst pop = require(\"popcat-wrapper\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    const member = interaction.options.getUser('user');\n\n    const userAvatar = member.displayAvatarURL({ dynamic: false, size: 1024, extension: 'png' });\n\n    const image = await pop.clown(userAvatar);\n    let attach = new Discord.AttachmentBuilder(image, { name: \"clown.png\" });\n\n    const embed = client.templateEmbed().setImage(\"attachment://clown.png\");\n    interaction.editReply({ files: [attach], embeds: [embed] });\n}\n\n","size_bytes":563},"src/commands/images/clyde.js":{"content":"const { Canvas } = require(\"canvacord\");\nconst Discord = require(\"discord.js\");\nmodule.exports = async (client, interaction, args) => {\n\n    const clydeMessage = interaction.options.getString('text');\n\n    const image = await Canvas.clyde(clydeMessage)\n\n    const attachment = new Discord.AttachmentBuilder(image, \"clyde.png\");\n\n    const embed = client.templateEmbed().setImage(\"attachment://clyde.png\");\n    interaction.editReply({ files: [attachment], embeds: [embed] });\n}\n\n ","size_bytes":479},"src/commands/images/colorify.js":{"content":"const Discord = require('discord.js');\nconst { Canvas } = require(\"canvacord\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    const member = interaction.options.getUser('user');\n\n    const userAvatar = member.displayAvatarURL({ dynamic: false, size: 1024, extension: 'png' });\n\n    const image = await Canvas.colorfy(userAvatar, \"#ff0000\")\n    let attach = new Discord.AttachmentBuilder(image, { name: \"colorify.png\" });\n\n    const embed = client.templateEmbed().setImage(\"attachment://colorify.png\");\n    interaction.editReply({ files: [attach], embeds: [embed] });\n}\n\n","size_bytes":586},"src/commands/images/darkness.js":{"content":"const Discord = require('discord.js');\nconst { Canvas } = require(\"canvacord\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    const member = interaction.options.getUser('user');\n\n    const userAvatar = member.displayAvatarURL({ dynamic: false, size: 1024, extension: 'png' });\n\n    const amount = 60\n\n    const image = await Canvas.darkness(userAvatar, amount);\n    let attach = new Discord.AttachmentBuilder(image, { name: \"darkness.gif\" });\n\n    const embed = client.templateEmbed().setImage(\"attachment://darkness.gif\");\n    interaction.editReply({ files: [attach], embeds: [embed] });    \n}\n\n","size_bytes":612},"src/commands/images/dog.js":{"content":"const Discord = require('discord.js');\nconst fetch = require(\"node-fetch\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    fetch(\n        `https://some-random-api.ml/img/dog`\n    )\n        .then((res) => res.json()).catch({})\n        .then(async (json) => {\n            client.embed({\n                title: `🐶・Random Dog`,\n                image: json.link,\n                type: 'editreply'\n            }, interaction)\n        }).catch({})\n}\n\n ","size_bytes":465},"src/commands/images/drake.js":{"content":"const Discord = require('discord.js');\nconst pop = require(\"popcat-wrapper\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    const splitArgs1 = interaction.options.getString('text1');\n    const splitArgs2 = interaction.options.getString('text2');\n\n    const image = await pop.drake(splitArgs1, splitArgs2);\n    let attach = new Discord.AttachmentBuilder(image, { name: \"drake.png\" });\n\n    const embed = client.templateEmbed().setImage(\"attachment://drake.png\");\n    interaction.editReply({ files: [attach], embeds: [embed] });\n}\n\n","size_bytes":546},"src/commands/images/facepalm.js":{"content":"const Discord = require('discord.js');\nconst { Canvas } = require(\"canvacord\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    const member = interaction.options.getUser('user');\n\n    const userAvatar = member.displayAvatarURL({ dynamic: false, size: 1024, extension: 'png' });\n\n    const image = await Canvas.facepalm(userAvatar);\n    let attach = new Discord.AttachmentBuilder(image, { name: \"facepalm.png\" });\n\n    const embed = client.templateEmbed().setImage(\"attachment://facepalm.png\");\n    interaction.editReply({ files: [attach], embeds: [embed] });\n}\n\n","size_bytes":577},"src/commands/images/fox.js":{"content":"const Discord = require('discord.js');\nconst fetch = require(\"node-fetch\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    fetch(\n        `https://some-random-api.ml/img/fox`\n    )\n        .then((res) => res.json()).catch({})\n        .then(async (json) => {\n            client.embed({\n                title: `🦊・Random Fox`,\n                image: json.link,\n                type: 'editreply'\n            }, interaction)\n        }).catch({})\n}\n\n ","size_bytes":465},"src/commands/images/glass.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n\n    let link = `https://some-random-api.ml/canvas/glass/?avatar=${interaction.user.avatarURL({ size: 1024, extension: 'png' })}`\n    const attachment = new Discord.AttachmentBuilder(link, {name:'glass.png'});\n\n    const embed = client.templateEmbed().setImage(\"attachment://glass.png\");\n    interaction.editReply({ files: [attachment], embeds: [embed] });\n};","size_bytes":455},"src/commands/images/greyscale.js":{"content":"const Discord = require('discord.js');\nconst { Canvas } = require(\"canvacord\");\nmodule.exports = async (client, interaction, args) => {\n\n    const member = interaction.options.getUser('user');\n\n    const userAvatar = member.displayAvatarURL({ dynamic: false, size: 1024, extension: 'png' });\n\n    const image = await Canvas.greyscale(userAvatar)\n    let attach = new Discord.AttachmentBuilder(image, { name: \"greyscale.png\" });\n\n    const embed = client.templateEmbed();\n    embed.setImage(\"attachment://greyscale.png\");\n    interaction.editReply({ files: [attach], embeds: [embed] })\n}\n\n","size_bytes":588},"src/commands/images/image.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    const image = interaction.options.getString('image-url');\n    const channel = interaction.options.getChannel('channel');\n\n    if (!channel) return client.errNormal({ error: `Channel not found`, type: 'editreply' }, interaction)\n\n    client.succNormal({\n        text: `The image was succesfully send to ${channel}`,\n        type: 'editreply'\n    }, interaction)\n\n    client.simpleEmbed({\n        image: `${image}`\n    }, channel)\n}\n\n ","size_bytes":495},"src/commands/images/invert.js":{"content":"const Discord = require('discord.js');\nconst pop = require(\"popcat-wrapper\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    const member = interaction.options.getUser('user');\n\n    const userAvatar = member.displayAvatarURL({ dynamic: false, size: 1024, extension: 'png' });\n\n    const image = await pop.invert(userAvatar);\n    let attach = new Discord.AttachmentBuilder(image, { name: \"invert.png\" });\n    const embed = client.templateEmbed().setImage('attachment://invert.png')\n    interaction.editReply({ files: [attach], embeds: [embed] })\n}\n\n","size_bytes":563},"src/commands/images/kiss.js":{"content":"const Discord = require('discord.js');\nconst DIG = require(\"discord-image-generation\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    const member = interaction.options.getUser('user');\n\n    const avatar = interaction.user.displayAvatarURL({ dynamic: false, size: 1024, extension: 'png' });\n    const userAvatar = member.displayAvatarURL({ dynamic: false, size: 1024, extension: 'png' });\n    const image = await new DIG.Kiss().getImage(avatar, userAvatar);\n    let attach = new Discord.AttachmentBuilder(image, { name: \"kiss.png\" });\n    const embed = client.templateEmbed();\n    embed.setImage('attachment://kiss.png')\n    embed.setDescription(`**${interaction.user.username}** kissed **${member.username}**`)\n    interaction.editReply({ files: [attach], embeds: [embed] })\n}\n\n","size_bytes":795},"src/commands/images/koala.js":{"content":"const Discord = require('discord.js');\nconst fetch = require(\"node-fetch\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    fetch(\n        `https://some-random-api.ml/img/koala`\n    )\n        .then((res) => res.json()).catch({})\n        .then(async (json) => {\n            client.embed({\n                title: `🐨・Random Koala`,\n                image: json.link,\n                type: 'editreply'\n            }, interaction)\n        }).catch({})\n}\n\n ","size_bytes":469},"src/commands/images/meme.js":{"content":"const fetch = require(\"node-fetch\");\nconst Discord = require('discord.js');\nmodule.exports = async (client, interaction, args) => {\n\n    fetch(`https://www.reddit.com/r/memes` + `.json?sort=top&t=week&limit=100`).then(res => res.json()).then(async (json) => {\n        let i = Math.floor(Math.random() * json.data.children.length)\n        let image = json.data.children[i].data.url\n        let caption = json.data.children[i].data.title\n        let embed = new Discord.EmbedBuilder()\n            .setTitle(caption)\n            .setImage(image)\n            .setColor(client.config.colors.normal)\n            .setFooter({ text: `👍 ${json.data.children[i].data.ups} | 💬 ${json.data.children[i].data.num_comments}` })\n        interaction.editReply({ embeds: [embed] })\n    }).catch({})\n}","size_bytes":788},"src/commands/images/panda.js":{"content":"const Discord = require('discord.js');\nconst fetch = require(\"node-fetch\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    fetch(\n        `https://some-random-api.ml/img/panda`\n    )\n        .then((res) => res.json()).catch({})\n        .then(async (json) => {\n            client.embed({\n                title: `🐼・Random Panda`,\n                image: json.link,\n                type: 'editreply'\n            }, interaction)\n        }).catch({})\n}\n\n ","size_bytes":469},"src/commands/images/podium.js":{"content":"const Discord = require('discord.js');\nconst DIG = require(\"discord-image-generation\");\n\nmodule.exports = async (client, interaction, args) => {\n    const user1 = interaction.options.getUser('user1') || interaction.user;\n    const user2 = interaction.options.getUser('user2') || interaction.user;\n    const user3 = interaction.options.getUser('user3') || interaction.user;\n\n    var user1Avatar = user1.displayAvatarURL({ dynamic: false, size: 1024, extension: 'png' });\n    var user2Avatar = user2.displayAvatarURL({ dynamic: false, size: 1024, extension: 'png' });\n    var user3Avatar = user3.displayAvatarURL({ dynamic: false, size: 1024, extension: 'png' });\n\n    var img = await new DIG.Podium().getImage(user1Avatar, user2Avatar, user3Avatar, user1.tag, user2.tag, user3.tag);\n    var attach = new Discord.AttachmentBuilder(img, { name: \"podium.png\" });\n    const embed = client.templateEmbed().setImage(\"attachment://podium.png\");\n    interaction.editReply({ files: [attach], embeds: [embed] });\n}\n\n","size_bytes":1005},"src/commands/images/pooh.js":{"content":"const Discord = require('discord.js');\nconst pop = require(\"popcat-wrapper\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    const splitArgs1 = interaction.options.getString('text1');\n    const splitArgs2 = interaction.options.getString('text2');\n\n    const image = await pop.pooh(splitArgs1, splitArgs2);\n    let attach = new Discord.AttachmentBuilder(image, { name: \"pooh.png\" });\n\n    const embed = client.templateEmbed().setImage(\"attachment://pooh.png\");\n    interaction.editReply({ files: [attach], embeds: [embed] });\n}\n\n","size_bytes":543},"src/commands/images/redpanda.js":{"content":"const Discord = require('discord.js');\nconst fetch = require(\"node-fetch\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    fetch(\n        `https://some-random-api.ml/img/red_panda`\n    )\n        .then((res) => res.json()).catch({})\n        .then(async (json) => {\n            client.embed({\n                title: `🔴・Random Redpanda`,\n                image: json.link,\n                type: 'editreply'\n            }, interaction)\n        }).catch({})\n}\n\n ","size_bytes":476},"src/commands/images/spank.js":{"content":"const Discord = require('discord.js');\nconst DIG = require(\"discord-image-generation\");\n\nmodule.exports = async (client, interaction, args) => {\n    const user = interaction.options.getUser('user') || interaction.user;\n\n    let avatar = interaction.user.displayAvatarURL({ dynamic: false, size: 1024, extension: 'png' });\n    const userAvatar = user.displayAvatarURL({ dynamic: false, size: 1024, extension: 'png' });\n    const image = await new DIG.Spank().getImage(avatar, userAvatar);\n    let attach = new Discord.AttachmentBuilder(image, {name: \"spank.png\"});\n\n    const embed = client.templateEmbed().setImage(\"attachment://spank.png\");\n    interaction.editReply({ files: [attach], embeds: [embed] });\n}\n\n ","size_bytes":711},"src/commands/images/triggered.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n\n    let link = `https://some-random-api.ml/canvas/triggered/?avatar=${interaction.user.avatarURL({ size: 1024, extension: 'png' })}`\n    const attachment = new Discord.AttachmentBuilder(link, { name: 'triggered.gif' });\n\n    const embed = client.templateEmbed().setImage(\"attachment://triggered.gif\");\n    interaction.editReply({ files: [attachment], embeds: [embed] });\n};","size_bytes":470},"src/commands/images/trumptweet.js":{"content":"const fetch = require('node-fetch');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const tweet = interaction.options.getString('text');\n\n    if (tweet.length > 68) tweet = tweet.slice(0, 65) + \"...\";\n\n    const res = await fetch(\"https://nekobot.xyz/api/imagegen?type=trumptweet&text=\" + tweet);\n\n    const img = (await res.json()).message;\n\n    client.embed({\n        title: `🖼・Trump tweet`,\n        image: img,\n        type: 'editreply'\n    }, interaction)\n}\n\n ","size_bytes":484},"src/commands/images/tweet.js":{"content":"const fetch = require(\"node-fetch\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    const user = interaction.user.username;\n    const text = interaction.options.getString('text');\n\n    try {\n        fetch(`https://nekobot.xyz/api/imagegen?type=tweet&username=${user}&text=${text}`)\n\n            .then((res) => res.json()).catch({})\n            .then(async (json) => {\n\n                client.embed({\n                    title: `🖼・Tweet`,\n                    image: json.message,\n                    type: 'editreply'\n                }, interaction)\n\n            }).catch({})\n    }\n    catch { }\n\n}\n\n ","size_bytes":620},"src/commands/images/wallpaper.js":{"content":"const fetch = require(\"node-fetch\")\nmodule.exports = async (client, interaction, args) => {\n    var images = []\n    const query = interaction.options.getString('name');\n\n    // Use FREE API \n    \n}\n\n","size_bytes":199},"src/commands/images/wanted.js":{"content":"const Discord = require('discord.js');\nconst DIG = require(\"discord-image-generation\");\n\nmodule.exports = async (client, interaction, args) => {\n    const user = interaction.options.getUser('user') || interaction.user;\n\n    let userAvatar = user.displayAvatarURL({ size: 1024, dynamic: false, extension: 'png' });\n    let img = await new DIG.Wanted().getImage(userAvatar, `€`);\n    let attach = new Discord.AttachmentBuilder(img, { name: \"wanted.png\" });\n    const embed = client.templateEmbed().setImage(\"attachment://wanted.png\");\n    interaction.editReply({ files: [attach], embeds: [embed] });\n}\n\n","size_bytes":603},"src/commands/images/wasted.js":{"content":"module.exports = async (client, interaction, args) => {\n\n    let link = `https://some-random-api.ml/canvas/wasted/?avatar=${interaction.user.avatarURL({ size: 1024, extension: 'png' })}`\n\n    client.embed({\n        title: `🖼・Generated image`,\n        image: link,\n        type: 'editreply'\n    }, interaction)\n}\n\n ","size_bytes":319},"src/commands/invites/add.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/invites\");\n\nmodule.exports = async (client, interaction, args) => {\n    let user = interaction.options.getUser('user');\n    let amount = interaction.options.getNumber('amount');\n\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n        perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n    }, interaction)\n\n    if (perms == false) return;\n\n    const data = await Schema.findOne({ Guild: interaction.guild.id, User: user.id });\n    if (data) {\n        data.Invites += amount;\n        data.Total += amount;\n        data.save();\n    }\n    else {\n        new Schema({\n            Guild: interaction.guild.id,\n            User: user.id,\n            Invites: amount,\n            Total: amount,\n            Left: 0\n        }).save();\n    }\n\n    client.succNormal({\n        text: `Added **${amount}** invites to ${user}`,\n        fields: [\n            {\n                name: \"📨┆Total invites\",\n                value: `${data.Invites}`,\n                inline: true,\n            }\n        ],\n        type: 'editreply'\n    }, interaction);\n}\n\n ","size_bytes":1200},"src/commands/invites/leaderboard.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/invites\");\n\nmodule.exports = async (client, interaction, args) => {\n    const rawLeaderboard = await Schema.find({ Guild: interaction.guild.id }).sort(([['Invites', 'descending']]));\n\n    if (!rawLeaderboard) return client.errNormal({\n        error: `No data found!`,\n        type: 'editreply'\n    }, interaction);\n\n    const lb = rawLeaderboard.map(e => `**${rawLeaderboard.findIndex(i => i.Guild === interaction.guild.id && i.User === e.User) + 1}** | <@!${e.User}> - Invites: \\`${e.Invites}\\``);\n\n    await client.createLeaderboard(`📨・Invites - ${interaction.guild.name}`, lb, interaction);\n}\n\n ","size_bytes":689},"src/commands/invites/remove.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/invites\");\n\nmodule.exports = async (client, interaction, args) => {\n    let user = interaction.options.getUser('user');\n    let amount = interaction.options.getNumber('amount');\n\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n        perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n    }, interaction)\n\n    if (perms == false) return;\n\n    const data = await Schema.findOne({ Guild: interaction.guild.id, User: user.id });\n    if (data) {\n        data.Invites -= amount;\n        data.Total -= amount;\n        data.save();\n    }\n    else {\n        return client.errNormal({\n            error: `No invite data found for ${user}`,\n            type: 'editreply'\n        }, interaction);\n    }\n\n    client.succNormal({\n        text: `Removed **${amount}** invites from ${user}`,\n        fields: [\n            {\n                name: \"📨┆Total invites\",\n                value: `${data.Invites}`,\n                inline: true,\n            }\n        ],\n        type: 'editreply'\n    }, interaction);\n}\n\n ","size_bytes":1164},"src/commands/invites/show.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/invites\");\n\nmodule.exports = async (client, interaction, args) => {\n    let user = interaction.options.getUser('user') || interaction.user;\n\n    Schema.findOne({ Guild: interaction.guild.id, User: user.id }, async (err, data) => {\n        if (data) {\n            client.embed({\n                title: \"📨・Invites\",\n                desc: `**${user.tag}** has \\`${data.Invites}\\` invites`,\n                fields: [\n                    {\n                        name: \"Total\",\n                        value: `${data.Total}`,\n                        inline: true\n                    },\n                    {\n                        name: \"Left\",\n                        value: `${data.Left}`,\n                        inline: true\n                    }\n                ],\n                type: 'editreply'\n            }, interaction)\n        }\n        else {\n            client.embed({\n                title: \"📨・Invites\",\n                desc: `**${user.tag}** has \\`0\\` invites`,\n                fields: [\n                    {\n                        name: \"Total\",\n                        value: `0`,\n                        inline: true\n                    },\n                    {\n                        name: \"Left\",\n                        value: `0`,\n                        inline: true\n                    }\n                ],\n                type: 'editreply'\n            }, interaction)\n        }\n    });\n}\n\n ","size_bytes":1513},"src/commands/levels/createreward.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/levelRewards\");\n\nmodule.exports = async (client, interaction, args) => {\n    let level = interaction.options.getNumber('level');\n    let role = interaction.options.getRole('role');\n\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n        perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n    }, interaction)\n\n    if (perms == false) return;\n\n    Schema.findOne({ Guild: interaction.guild.id, Level: level }, async (err, data) => {\n        if (data) {\n            return client.errNormal({ \n                error: \"This level already has a reward!\",\n                type: 'editreply'\n            }, interaction);\n        }\n        else {\n            new Schema({\n                Guild: interaction.guild.id,\n                Level: level,\n                Role: role.id\n            }).save();\n\n            client.succNormal({ \n                text: `Level reward created`,\n                fields: [\n                    {\n                        name: \"📘┆Role\",\n                        value: `${role}`,\n                        inline: true,\n                    }\n                ],\n                type: 'editreply'\n            }, interaction);\n        }\n    })\n}\n\n ","size_bytes":1329},"src/commands/levels/deletereward.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/levelRewards\");\n\nmodule.exports = async (client, interaction, args) => {\n    let level = interaction.options.getNumber('level');\n\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n        perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n    }, interaction)\n\n    if (perms == false) return;\n    \n    Schema.findOne({ Guild: interaction.guild.id, Level: level }, async (err, data) => {\n        if (data) {\n            Schema.findOneAndDelete({ Guild: interaction.guild.id, Level: level }).then(() => {\n                client.succNormal({\n                    text: `Level reward removed`,\n                    fields: [\n                        {\n                            name: \"🆙┆Level\",\n                            value: `${level}`,\n                            inline: true,\n                        }\n                    ],\n                    type: 'editreply'\n                }, interaction);\n            })\n        }\n        else {\n            return client.errNormal({\n                error: \"No level reward found at this level!\",\n                type: 'editreply'\n            }, interaction);\n        }\n    })\n}\n\n ","size_bytes":1286},"src/commands/levels/leaderboard.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/levels\");\n\nmodule.exports = async (client, interaction, args) => {\n    const rawLeaderboard = await Schema.find({ guildID: interaction.guild.id }).sort(([['xp', 'descending']])).exec();\n\n    if (!rawLeaderboard) return client.errNormal({\n        error: `No data found!`,\n        type: 'editreply'\n    }, interaction);\n\n    const lb = rawLeaderboard.map(e => `**${rawLeaderboard.findIndex(i => i.guildID === interaction.guild.id && i.userID === e.userID) + 1}** | <@!${e.userID}> - Level: \\`${e.level.toLocaleString()}\\` (${e.xp.toLocaleString()} xp)`);\n\n    await client.createLeaderboard(`🆙・Levels - ${interaction.guild.name}`, lb, interaction);\n}\n\n ","size_bytes":742},"src/commands/levels/rank.js":{"content":"const Discord = require('discord.js');\nconst Canvacord = require(\"canvacord\");\n\nconst Functions = require(\"../../database/models/functions\");\nconst Schema = require(\"../../database/models/levels\");\n\nmodule.exports = async (client, interaction, args) => {\n    const data = await Functions.findOne({ Guild: interaction.guild.id });\n\n    if (data && data.Levels == true) {\n        const target = interaction.options.getUser('user') || interaction.user;\n        const user = await client.fetchLevels(target.id, interaction.guild.id);\n        if(!user || !user.xp) return client.errNormal({\n            error: \"This user has no levels!\",\n            type: 'editreply'\n        }, interaction);\n        let xpRequired = client.xpFor(user.level + 1);\n\n        const rankCard = new Canvacord.Rank()\n            .setAvatar(target.displayAvatarURL({ dynamic: false, extension: 'png' }))\n            .setRequiredXP(xpRequired)\n            .setCurrentXP(user.xp)\n            .setLevel(user.level)\n            .setProgressBar(client.config.colors.normal, \"COLOR\")\n            .setUsername(target.username)\n            .setDiscriminator(target.discriminator)\n            .setStatus(\"dnd\")\n            .setRank(user.position)\n\n        rankCard.build()\n            .then(data => {\n                const attachment = new Discord.AttachmentBuilder(data, { name: \"RankCard.png\" });\n                interaction.editReply({ files: [attachment] });\n            });\n    }\n    else {\n        client.errNormal({\n            error: \"Levels are disabled in this guild!\",\n            type: 'editreply'\n        }, interaction);\n    }\n}\n\n","size_bytes":1607},"src/commands/levels/rewards.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/levelRewards\");\n\nmodule.exports = async (client, interaction, args) => {\n    const rawLeaderboard = await Schema.find({ Guild: interaction.guild.id });\n\n    if (rawLeaderboard.length < 1) return client.errNormal({\n        error: `No rewards found!`,\n        type: 'editreply'\n    }, interaction);\n\n    const lb = rawLeaderboard.map(e => `**Level ${e.Level}** - <@&${e.Role}>`);\n\n    await client.createLeaderboard(`🆙・Level rewards - ${interaction.guild.name}`, lb, interaction);\n}\n\n ","size_bytes":574},"src/commands/levels/setlevel.js":{"content":"const Discord = require('discord.js');\nconst Canvacord = require(\"canvacord\");\n\nconst Functions = require(\"../../database/models/functions\");\nconst Schema = require(\"../../database/models/levels\");\n\nmodule.exports = async (client, interaction, args) => {\n    const data = await Functions.findOne({ Guild: interaction.guild.id });\n\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n        perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n    }, interaction)\n\n    if (perms == false) return;\n    \n    if (data && data.Levels == true) {\n        const target = interaction.options.getUser('user');\n        const level = interaction.options.getNumber('level');\n\n        const user = await client.setLevel(target.id, interaction.guild.id, level);\n\n        client.succNormal({ \n            text: `Level has been modified successfully`,\n            fields: [\n                {\n                    name: \"🆕┆New Level\",\n                    value: `${user.level}`,\n                    inline: true,\n                },\n                {\n                    name: \"👤┆User\",\n                    value: `${target} (${target.tag})`,\n                    inline: true,\n                }\n            ],\n            type: 'editreply'\n        }, interaction);\n    }\n    else {\n        client.errNormal({\n            error: \"Levels are disabled in this guild!\",\n            type: 'editreply'\n        }, interaction);\n    }\n}\n\n ","size_bytes":1490},"src/commands/levels/setxp.js":{"content":"const Discord = require('discord.js');\nconst Canvacord = require(\"canvacord\");\n\nconst Functions = require(\"../../database/models/functions\");\nconst Schema = require(\"../../database/models/levels\");\n\nmodule.exports = async (client, interaction, args) => {\n    const data = await Functions.findOne({ Guild: interaction.guild.id });\n\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n        perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n    }, interaction)\n\n    if (perms == false) return;\n    \n    if (data && data.Levels == true) {\n        const target = interaction.options.getUser('user');\n        const xp = interaction.options.getNumber('amount');\n\n        const user = await client.setXP(target.id, interaction.guild.id, xp);\n\n        client.succNormal({ \n            text: `XP has been modified successfully`,\n            fields: [\n                {\n                    name: \"🆕┆New XP\",\n                    value: `${user.xp}`,\n                    inline: true,\n                },\n                {\n                    name: \"👤┆User\",\n                    value: `${target} (${target.tag})`,\n                    inline: true,\n                }\n            ],\n            type: 'editreply'\n        }, interaction);\n    }\n    else {\n        client.errNormal({\n            error: \"Levels are disabled in this guild!\",\n            type: 'editreply'\n        }, interaction);\n    }\n}\n\n ","size_bytes":1473},"src/commands/messages/add.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/messages\");\n\nmodule.exports = async (client, interaction, args) => {\n    let user = interaction.options.getUser('user');\n    let amount = interaction.options.getNumber('amount');\n\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n        perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n    }, interaction)\n\n    if (perms == false) return;\n\n    const data = await Schema.findOne({ Guild: interaction.guild.id, User: user.id });\n    if (data) {\n        data.Messages += amount;\n        await data.save();\n    }\n    else {\n        await new Schema({\n            Guild: interaction.guild.id,\n            User: user.id,\n            Messages: amount,\n        }).save();\n    }\n\n    client.succNormal({\n        text: `Added **${amount}** messages to ${user}`,\n        fields: [\n            {\n                name: \"💬┆Total messages\",\n                value: `${data.Messages}`,\n                inline: true,\n            }\n        ],\n        type: 'editreply'\n    }, interaction);\n}\n\n ","size_bytes":1141},"src/commands/messages/createreward.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/messageRewards\");\n\nmodule.exports = async (client, interaction, args) => {\n    let messages = interaction.options.getNumber('amount');\n    let role = interaction.options.getRole('role');\n\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n        perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n    }, interaction)\n\n    if (perms == false) return;\n    \n    Schema.findOne({ Guild: interaction.guild.id, Messages: messages }, async (err, data) => {\n        if (data) {\n            return client.errNormal({ \n                error: \"This message amount already has a reward!\",\n                type: 'editreply'\n            }, interaction);\n        }\n        else {\n            new Schema({\n                Guild: interaction.guild.id,\n                Messages: messages,\n                Role: role.id\n            }).save();\n\n            client.succNormal({ \n                text: `Message reward created`,\n                fields: [\n                    {\n                        name: \"📘┆Role\",\n                        value: `${role}`,\n                        inline: true,\n                    }\n                ],\n                type: 'editreply'\n            }, interaction);\n        }\n    })\n}\n\n ","size_bytes":1362},"src/commands/messages/deletereward.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/messageRewards\");\n\nmodule.exports = async (client, interaction, args) => {\n    let messages = interaction.options.getNumber('amount');\n\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n        perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n    }, interaction)\n\n    if (perms == false) return;\n    \n    Schema.findOne({ Guild: interaction.guild.id, Messages: messages }, async (err, data) => {\n        if (data) {\n            Schema.findOneAndDelete({ Guild: interaction.guild.id, Messages: messages }).then(() => {\n                client.succNormal({\n                    text: `Message reward removed`,\n                    fields: [\n                        {\n                            name: \"💬┆Messages\",\n                            value: `${messages}`,\n                            inline: true,\n                        }\n                    ],\n                    type: 'editreply'\n                }, interaction);\n            })\n        }\n        else {\n            return client.errNormal({\n                error: \"No message reward found at this message amount!\",\n                type: 'editreply'\n            }, interaction);\n        }\n    })\n}\n\n ","size_bytes":1323},"src/commands/messages/leaderboard.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/messages\");\n\nmodule.exports = async (client, interaction, args) => {\n    const rawLeaderboard = await Schema.find({ Guild: interaction.guild.id }).sort(([['Messages', 'descending']]));\n\n    if (!rawLeaderboard) return client.errNormal({\n        error: `No data found!`,\n        type: 'editreply'\n    }, interaction);\n\n    const lb = rawLeaderboard.map(e => `**${rawLeaderboard.findIndex(i => i.Guild === interaction.guild.id && i.User === e.User) + 1}** | <@!${e.User}> - Messages: \\`${e.Messages}\\``);\n\n    await client.createLeaderboard(`💬・Messages - ${interaction.guild.name}`, lb, interaction);\n}\n\n ","size_bytes":694},"src/commands/messages/remove.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/messages\");\n\nmodule.exports = async (client, interaction, args) => {\n    let user = interaction.options.getUser('user');\n    let amount = interaction.options.getNumber('amount');\n\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n        perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n    }, interaction)\n\n    if (perms == false) return;\n\n    const data = await Schema.findOne({ Guild: interaction.guild.id, User: user.id });\n    if (data) {\n        data.Messages -= amount;\n        await data.save();\n    }\n    else {\n        return client.errNormal({\n            error: `No message data found for ${user}`,\n            type: 'editreply'\n        }, interaction);\n    }\n\n    client.succNormal({\n        text: `Removed **${amount}** messages from ${user}`,\n        fields: [\n            {\n                name: \"💬┆Total messages\",\n                value: `${data.Messages}`,\n                inline: true,\n            }\n        ],\n        type: 'editreply'\n    }, interaction);\n}\n\n ","size_bytes":1146},"src/commands/messages/rewards.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/messageRewards\");\n\nmodule.exports = async (client, interaction, args) => {\n    const rawLeaderboard = await Schema.find({ Guild: interaction.guild.id });\n\n    if (rawLeaderboard.length < 1) return client.errNormal({\n        error: `No rewards found!`,\n        type: 'editreply'\n    }, interaction);\n\n    const lb = rawLeaderboard.map(e => `**${e.Messages} messages** - <@&${e.Role}>`);\n\n    await client.createLeaderboard(`💬・Message rewards - ${interaction.guild.name}`, lb, interaction);\n}\n\n ","size_bytes":584},"src/commands/messages/show.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/messages\");\n\nmodule.exports = async (client, interaction, args) => {\n    let user = interaction.options.getUser('user') || interaction.user;\n\n    Schema.findOne({ Guild: interaction.guild.id, User: user.id }, async (err, data) => {\n        if (data) {\n            client.embed({\n                title: \"💬・Messages\",\n                desc: `**${user.tag}** has \\`${data.Messages}\\` messages`,\n                type: 'editreply'\n            }, interaction)\n        }\n        else {\n            client.embed({\n                title: \"💬・Messages\",\n                desc: `**${user.tag}** has \\`0\\` messages`,\n                type: 'editreply'\n            }, interaction)\n        }\n    });\n}\n\n ","size_bytes":782},"src/commands/moderation/ban.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n  const perms = await client.checkPerms({\n    flags: [Discord.PermissionsBitField.Flags.BanMembers],\n    perms: [Discord.PermissionsBitField.Flags.BanMembers]\n  }, interaction)\n\n  if (perms == false) return;\n\n  const member = await interaction.guild.members.fetch(interaction.options.getUser('user').id);\n  const reason = interaction.options.getString('reason') || 'Not given';\n\n  if (member.permissions.has(Discord.PermissionsBitField.Flags.BanMembers) || member.permissions.has(Discord.PermissionsBitField.Flags.BanMembers)) return client.errNormal({\n    error: \"You can't ban a moderator\",\n    type: 'editreply'\n  }, interaction);\n\n  client.embed({\n    title: `🔨・Ban`,\n    desc: `You've been banned in **${interaction.guild.name}**`,\n    fields: [\n      {\n        name: \"👤┆Banned by\",\n        value: interaction.user.tag,\n        inline: true\n      },\n      {\n        name: \"💬┆Reason\",\n        value: reason,\n        inline: true\n      }\n    ]\n  }, member).then(function () {\n    member.ban({ reason: reason })\n    client.succNormal({\n      text: \"The specified user has been successfully banned and successfully received a notification!\",\n      fields: [\n        {\n          name: \"👤┆Banned user\",\n          value: member.user.tag,\n          inline: true\n        },\n        {\n          name: \"💬┆Reason\",\n          value: reason,\n          inline: true\n        }\n      ],\n      type: 'editreply'\n    }, interaction);\n  }).catch(function () {\n    member.ban({ reason: reason })\n    client.succNormal({\n      text: \"The given user has been successfully banned, but has not received a notification!\",\n      type: 'editreply'\n    }, interaction);\n  });\n}\n\n ","size_bytes":1777},"src/commands/moderation/banlist.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n  const perms = await client.checkPerms({\n    flags: [Discord.PermissionsBitField.Flags.BanMembers],\n    perms: [Discord.PermissionsBitField.Flags.BanMembers]\n  }, interaction)\n\n  if (perms == false) return;\n\n  interaction.guild.bans.fetch().then(async banned => {\n    let list = banned.map(banUser => `${banUser.user.tag}・**Reason:** ${banUser.reason || 'No reason'}`);\n\n    if (list.length == 0) return client.errNormal({\n      error: `This server has no bans`,\n      type: 'editreply'\n    }, interaction)\n\n    await client.createLeaderboard(`🔧・Banlist - ${interaction.guild.name}`, list, interaction);\n  }).catch(error => {\n    console.log(error)\n  })\n}\n\n ","size_bytes":762},"src/commands/moderation/clear.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    const perms = await client.checkPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n        perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n    }, interaction);\n\n    if (perms == false) return;\n\n    const amount = interaction.options.getNumber('amount');\n\n    if (amount > 100) return client.errNormal({\n        error: \"I cannot delete more than 100 messages at a time!\",\n        type: 'editreply'\n    }, interaction);\n\n    if (amount < 1) return client.errNormal({\n        error: \"I cannot delete less than 1 message!\",\n        type: 'editreply'\n    }, interaction);\n\n    interaction.channel.bulkDelete(amount + 1).then(() => {\n        client.succNormal({\n            text: `I have successfully deleted the messages`,\n            fields: [\n                {\n                    name: \"💬┆Amount\",\n                    value: `${amount}`,\n                    inline: true\n                }\n            ],\n            type: 'ephemeraledit'\n        }, interaction)\n    }).catch(err => {\n        client.errNormal({\n            error: \"There was an error trying to delete messages in this channel!\",\n            type: 'editreply'\n        }, interaction);\n    });\n}\n\n ","size_bytes":1299},"src/commands/moderation/clearuser.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    const perms = await client.checkPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n        perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n    }, interaction);\n\n    if (perms == false) return;\n\n    const member = interaction.options.getUser('user');\n\n    interaction.guild.channels.cache.forEach(async (channel) => {\n        if (channel.messages) {\n            let messages = await channel.messages.fetch();\n            let userMessages = messages.filter((m) => m.author.id === member.id);\n            await channel.bulkDelete(userMessages).then(() => {\n                client.succNormal({\n                    text: `I have successfully deleted the messages`,\n                    fields: [\n                        {\n                            name: \"👤┆User\",\n                            value: `${member} (${member.tag})`,\n                            inline: true\n                        }\n                    ],\n                    type: 'editreply'\n                }, interaction).then(msg => setTimeout(() => {\n                    msg.delete()\n                }, 5000));\n            }).catch(err => { });\n        }\n    });\n\n    interaction.channel.bulkDelete(amount + 1).then(() => {\n        client.succNormal({\n            text: `I have successfully deleted the messages`,\n            fields: [\n                {\n                    name: \"💬┆Amount\",\n                    value: amount,\n                    inline: true\n                }\n            ],\n            type: 'editreply'\n        }, interaction).then(msg => setTimeout(() => {\n            msg.delete()\n        }, 5000));\n    }).catch(err => {\n        client.errNormal({\n            error: \"There was an error trying to delete messages in this channel!\",\n            type: 'editreply'\n        }, interaction);\n    });\n}\n\n ","size_bytes":1930},"src/commands/moderation/demote.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n  const perms = await client.checkPerms({\n    flags: [Discord.PermissionsBitField.Flags.BanMembers],\n    perms: [Discord.PermissionsBitField.Flags.BanMembers]\n  }, interaction)\n\n  if (perms == false) return;\n\n  const member = await interaction.guild.members.fetch(interaction.options.getUser('user').id);\n\n  member.roles.remove(member.roles.highest.id).then(r => {\n    client.embed({\n      title: `🔨・Demote`,\n      desc: `You've been demoted from **${interaction.guild.name}**`,\n      fields: [\n        {\n          name: \"👤┆Moderator\",\n          value: interaction.user.tag,\n          inline: true\n        },\n      ]\n    }, member).catch(() => { })\n\n    client.succNormal({\n      text: `User successfully demoted`, fields: [\n        {\n          name: \"👤┆User\",\n          value: `${member}`,\n          inline: true\n        }\n      ],\n      type: 'editreply'\n    }, interaction);\n  }).catch(e => {\n    client.errNormal({\n      error: \"I can't demote the user\",\n      type: 'editreply'\n    }, interaction)\n  });\n}\n\n ","size_bytes":1124},"src/commands/moderation/kick.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n  const perms = await client.checkPerms({\n    flags: [Discord.PermissionsBitField.Flags.KickMembers],\n    perms: [Discord.PermissionsBitField.Flags.KickMembers]\n  }, interaction)\n\n  if (perms == false) return;\n\n  const member = await interaction.guild.members.fetch(interaction.options.getUser('user').id);\n  const reason = interaction.options.getString('reason') || 'Not given';\n\n  if (member.permissions.has(Discord.PermissionsBitField.Flags.KickMembers) || member.permissions.has(Discord.PermissionsBitField.Flags.KickMembers)) return client.errNormal({\n    error: \"You can't kick a moderator\",\n    type: 'editreply'\n  }, interaction);\n\n  client.embed({\n    title: `🔨・Kick`,\n    desc: `You've been kicked in **${interaction.guild.name}**`,\n    fields: [\n      {\n        name: \"👤┆Kicked by\",\n        value: interaction.user.tag,\n        inline: true\n      },\n      {\n        name: \"💬┆Reason\",\n        value: reason,\n        inline: true\n      }\n    ]\n  }, member).then(function () {\n    member.kick(reason)\n    client.succNormal({\n      text: \"The specified user has been successfully kicked and successfully received a notification!\",\n      fields: [\n        {\n          name: \"👤┆Kicked user\",\n          value: member.user.tag,\n          inline: true\n        },\n        {\n          name: \"💬┆Reason\",\n          value: reason,\n          inline: true\n        }\n      ],\n      type: 'editreply'\n    }, interaction);\n  }).catch(function () {\n    member.kick(reason)\n    client.succNormal({\n      text: \"The given user has been successfully kicked, but has not received a notification!\",\n      type: 'editreply'\n    }, interaction);\n  });\n}\n\n ","size_bytes":1761},"src/commands/moderation/lock.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    const perms = await client.checkPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageChannels],\n        perms: [Discord.PermissionsBitField.Flags.ManageChannels]\n    }, interaction);\n\n    if (perms == false) return;\n\n    const channel = interaction.options.getChannel('channel') || interaction.channel;\n\n    await channel.permissionOverwrites.edit(interaction.guild.roles.cache.find(x => x.name === '@everyone'), {\n        SendMessages: false,\n    });\n\n    client.succNormal({\n        text: \"Channel locked successfully!\",\n        fields: [\n            {\n                name: `📘┆Channel`,\n                value: `${channel} (${channel.name})`\n            }\n        ],\n        type: 'editreply'\n    }, interaction);\n}\n\n ","size_bytes":836},"src/commands/moderation/lockdown.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    const perms = await client.checkPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageChannels],\n        perms: [Discord.PermissionsBitField.Flags.ManageChannels]\n    }, interaction);\n\n    if (perms == false) return;\n\n    interaction.guild.channels.cache.forEach(ch => {\n        if (ch.type == Discord.ChannelType.GuildText) {\n            ch.permissionOverwrites.edit(interaction.guild.id, {\n                SendMessages: false,\n            });\n        }\n    })\n\n    client.succNormal({\n        text: \"Channels locked successfully\",\n        type: 'editreply'\n    }, interaction);\n}\n\n ","size_bytes":694},"src/commands/moderation/nuke.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    const perms = await client.checkPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageChannels],\n        perms: [Discord.PermissionsBitField.Flags.ManageChannels]\n    }, interaction);\n\n    if (perms == false) return;\n\n    interaction.channel.clone().then((channel) => {\n        channel.setPosition(interaction.channel.position).then(\n            interaction.channel.delete()\n        );\n\n        client.embed({\n            title: `Channel Nuked by **${interaction.user.tag}**`,\n            image: `https://i.imgur.com/Da7ScU4.gif`\n        }, channel)\n    })\n}\n\n ","size_bytes":671},"src/commands/moderation/softban.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n  const perms = await client.checkPerms({\n    flags: [Discord.PermissionsBitField.Flags.BanMembers],\n    perms: [Discord.PermissionsBitField.Flags.BanMembers]\n  }, interaction)\n\n  if (perms == false) return;\n\n  const member = await interaction.guild.members.fetch(interaction.options.getUser('user').id);\n  const reason = interaction.options.getString('reason') || 'Not given';\n\n  if (member.permissions.has(Discord.PermissionsBitField.Flags.BanMembers) || member.permissions.has(Discord.PermissionsBitField.Flags.BanMembers)) return client.errNormal({\n    error: \"You can't ban a moderator\",\n    type: 'editreply'\n  }, interaction);\n\n  client.embed({\n    title: `🔨・Ban`,\n    desc: `You've been banned in **${interaction.guild.name}**`,\n    fields: [\n      {\n        name: \"👤┆Banned by\",\n        value: interaction.user.tag,\n        inline: true\n      },\n      {\n        name: \"💬┆Reason\",\n        value: reason,\n        inline: true\n      }\n    ]\n  }, member).then(function () {\n    member.ban({ days: 7, reason: reason })\n    client.succNormal({\n      text: \"The specified user has been successfully banned and successfully received a notification!\",\n      fields: [\n        {\n          name: \"👤┆Banned user\",\n          value: member.user.tag,\n          inline: true\n        },\n        {\n          name: \"💬┆Reason\",\n          value: reason,\n          inline: true\n        }\n      ],\n      type: 'editreply'\n    }, interaction);\n  }).catch(function () {\n    member.ban({ days: 7, reason: reason })\n    client.succNormal({\n      text: \"The given user has been successfully banned, but has not received a notification!\",\n      type: 'editreply'\n    }, interaction);\n  });\n\n  setTimeout(() => {\n    interaction.guild.members.unban(member.id)\n  }, 2000)\n}\n\n ","size_bytes":1875},"src/commands/moderation/tempban.js":{"content":"const Discord = require('discord.js');\n\nconst TempSchema = require(\"../../database/models/tempban\");\n\nmodule.exports = async (client, interaction, args) => {\n  const perms = await client.checkPerms({\n    flags: [Discord.PermissionsBitField.Flags.BanMembers],\n    perms: [Discord.PermissionsBitField.Flags.BanMembers]\n  }, interaction)\n\n  if (perms == false) return;\n\n  const member = await interaction.guild.members.fetch(interaction.options.getUser('user').id);\n  const reason = interaction.options.getString('reason') || 'Not given';\n\n  if (member.permissions.has(Discord.PermissionsBitField.Flags.BanMembers) || member.permissions.has(Discord.PermissionsBitField.Flags.BanMembers)) return client.errNormal({\n    error: \"You can't ban a moderator\",\n    type: 'editreply'\n  }, interaction);\n\n  client.embed({\n    title: `🔨・Ban`,\n    desc: `You've been banned in **${interaction.guild.name}**`,\n    fields: [\n      {\n        name: \"👤┆Banned by\",\n        value: interaction.user.tag,\n        inline: true\n      },\n      {\n        name: \"💬┆Reason\",\n        value: reason,\n        inline: true\n      }\n    ]\n  }, member).then(async function () {\n    member.ban({ reason: reason })\n    client.succNormal({\n      text: \"The specified user has been successfully banned and successfully received a notification!\",\n      fields: [\n        {\n          name: \"👤┆Banned user\",\n          value: member.user.tag,\n          inline: true\n        },\n        {\n          name: \"💬┆Reason\",\n          value: reason,\n          inline: true\n        }\n      ],\n      type: 'editreply'\n    }, interaction);\n\n    const expires = new Date()\n    expires.setMinutes(expires.getMinutes() + parseInt(interaction.options.getNumber('time')))\n\n    await new TempSchema({\n      guildId: interaction.guild.id,\n      userId: member.id,\n      expires,\n    }).save();\n\n  }).catch(async function () {\n    member.ban({ reason: reason })\n    client.succNormal({\n      text: \"The given user has been successfully banned, but has not received a notification!\",\n      type: 'editreply'\n    }, interaction);\n\n    const expires = new Date()\n    expires.setMinutes(expires.getMinutes() + parseInt(interaction.options.getNumber('time')))\n\n    await new TempSchema({\n      guildId: interaction.guild.id,\n      userId: member.id,\n      expires,\n    }).save();\n  });\n}\n\n \n","size_bytes":2347},"src/commands/moderation/timeout.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    const perms = await client.checkPerms({\n        flags: [Discord.PermissionsBitField.Flags.ModerateMembers],\n        perms: [Discord.PermissionsBitField.Flags.ModerateMembers]\n    }, interaction);\n\n    if (perms == false) return;\n\n    const user = await interaction.guild.members.fetch(interaction.options.getUser('user').id);\n    const time = interaction.options.getNumber('time');\n    const reason = interaction.options.getString('reason');\n\n    if (user.isCommunicationDisabled()) return client.errNormal({\n        error: `${user} has already timed out!`,\n        type: 'editreply'\n    }, interaction);\n\n    user.timeout(time * 60 * 1000, reason).then(m => {\n        client.succNormal({\n            text: `${user} successfully timed out **${time} minutes**`,\n            fields: [\n                {\n                    name: `💬┆Reason`,\n                    value: `${reason}`\n                }\n            ],\n            type: 'editreply'\n        }, interaction)\n    }).catch(e => {\n        client.errNormal({\n            error: `I can't timeout ${user.tag}`,\n            type: 'editreply'\n        }, interaction);\n    })\n}\n\n ","size_bytes":1233},"src/commands/moderation/unban.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n  const perms = await client.checkPerms({\n    flags: [Discord.PermissionsBitField.Flags.BanMembers],\n    perms: [Discord.PermissionsBitField.Flags.BanMembers]\n  }, interaction)\n\n  if (perms == false) return;\n\n  interaction.guild.members.unban(interaction.options.getString('user')).then(async function () {\n    var member = await interaction.guild.members.cache.get(interaction.options.getString('user'));\n    client.succNormal({\n      text: \"The specified user has been successfully unbanned!\",\n      fields: [\n        {\n          name: \"👤┆User\",\n          value: member ? member.user.tag : interaction.options.getString('user'),\n          inline: true\n        }\n      ],\n      type: 'editreply'\n    }, interaction);\n  }).catch(function (e) {\n    return client.errNormal({\n      error: `I could not find the user!`,\n      type: 'editreply'\n    }, interaction);\n  });\n}\n\n ","size_bytes":973},"src/commands/moderation/unlock.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    const perms = await client.checkPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageChannels],\n        perms: [Discord.PermissionsBitField.Flags.ManageChannels]\n    }, interaction);\n\n    if (perms == false) return;\n\n    const channel = interaction.options.getChannel('channel') || interaction.channel;\n\n    await channel.permissionOverwrites.edit(interaction.guild.roles.cache.find(x => x.name === '@everyone'), {\n        SendMessages: true,\n    });\n\n    client.succNormal({\n        text: \"Channel unlocked successfully!\",\n        fields: [\n            {\n                name: `📘┆Channel`,\n                value: `${channel} (${channel.name})`\n            }\n        ],\n        type: 'editreply'\n    }, interaction);\n}\n\n ","size_bytes":837},"src/commands/moderation/unwarn.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/warnings\");\n\nmodule.exports = async (client, interaction, args) => {\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n        perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n    }, interaction);\n\n    if (perms == false) return;\n\n    var member = interaction.options.getUser('user');\n    var Case = interaction.options.getInteger('case');\n\n    Schema.findOne({ Guild: interaction.guild.id, User: member.id }, async (err, data) => {\n        if (data) {\n            var warn = data.Warnings.find(x => x.Case == Case);\n            if (!warn) {\n                client.errNormal({\n                    error: \"This user doesn't have a warning with this case number!\",\n                    type: 'editreply'\n                }, interaction);\n                return;\n            }\n            data.Warnings.splice(data.Warnings.indexOf(warn), 1);\n            data.save();\n        }\n        else {\n            client.errNormal({ \n                error: \"User has no warnings!\", \n                type: 'editreply'\n            }, interaction);\n        }\n    })\n\n    client.embed({\n        title: `🔨・Unwarn`,\n        desc: `You've been unwarned in **${interaction.guild.name}**`,\n        fields: [\n            {\n                name: \"👤┆Moderator\",\n                value: interaction.user.tag,\n                inline: true\n            },\n        ]\n    }, member).catch(() => {})\n\n    client.emit('warnRemove', member, interaction.user)\n    client.succNormal({\n        text: `The user's warning has been successfully removed`,\n        fields: [\n            {\n                name: \"👤┆User\",\n                value: `${member}`,\n                inline: true\n            }\n        ],\n        type: 'editreply'\n    }, interaction);\n}\n\n ","size_bytes":1893},"src/commands/moderation/warn.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/warnings\");\nconst Case = require(\"../../database/models/warnCase\");\nmodule.exports = async (client, interaction, args) => {\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n        perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n    }, interaction);\n\n    if (perms == false) {\n        client.errNormal({\n            error: \"You don't have the required permissions to use this command!\",\n            type: 'editreply'\n        }, interaction);\n        return;\n    }\n\n    var member = interaction.options.getUser('user');\n    var reason = interaction.options.getString('reason');\n    var caseNumber;\n    await Case.findOne({ Guild: interaction.guild.id }).then(async data => {\n        if (!data) {\n            new Case({\n                Guild: interaction.guild.id,\n                Case: 1\n            }).save();\n            caseNumber = 1;\n        }\n        else {\n            data.Case += 1;\n            data.save();\n            caseNumber = data.Case;\n        }\n    });\n\n    Schema.findOne({ Guild: interaction.guild.id, User: member.id }, async (err, data) => {\n        if (data) {\n            data.Warnings.push({\n                Moderator: interaction.user.id,\n                Reason: reason,\n                Date: Date.now(),\n                Case: caseNumber\n            });\n            data.save();\n        }\n        else {\n            new Schema({\n                Guild: interaction.guild.id,\n                User: member.id,\n                Warnings: [{\n                    Moderator: interaction.user.id,\n                    Reason: reason,\n                    Date: Date.now(),\n                    Case: caseNumber\n                }]\n            }).save();\n        }\n    })\n\n    client.embed({\n        title: `🔨・Warn`,\n        desc: `You've been warned in **${interaction.guild.name}**`,\n        fields: [\n            {\n                name: \"👤┆Moderator\",\n                value: interaction.user.tag,\n                inline: true\n            },\n            {\n                name: \"📄┆Reason\",\n                value: reason,\n                inline: true\n            }\n        ]\n    }, member).catch(() => { })\n\n    client.emit('warnAdd', member, interaction.user, reason)\n    client.succNormal({\n        text: `User has received a warning!`,\n        fields: [\n            {\n                name: \"👤┆User\",\n                value: `${member}`,\n                inline: true\n            },\n            {\n                name: \"👤┆Moderator\",\n                value: `${interaction.user}`,\n                inline: true\n            },\n            {\n                name: \"📄┆Reason\",\n                value: reason,\n                inline: false\n            }\n        ],\n        type: 'editreply'\n    }, interaction);\n}\n\n ","size_bytes":2913},"src/commands/moderation/warnings.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/warnings\");\n\nmodule.exports = async (client, interaction, args) => {\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n        perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n    }, interaction);\n\n    if (perms == false) {\n        client.errNormal({\n            error: \"You don't have the required permissions to use this command!\",\n            type: 'editreply'\n        }, interaction);\n        return;\n    }\n\n    const member = interaction.options.getUser('user');\n\n\n    Schema.findOne({ Guild: interaction.guild.id, User: member.id }, async (err, data) => {\n        if (data) {\n            var fields = [];\n            data.Warnings.forEach(element => {\n                fields.push({\n                    name: \"Warning **\" + element.Case + \"**\",\n                    value: \"Reason: \" + element.Reason + \"\\nModerator <@!\" + element.Moderator + \">\",\n                    inline: true\n                })\n            });\n            client.embed({\n                title: `${client.emotes.normal.error}・Warnings`,\n                desc: `The warnings of **${member.tag}**`,\n                fields: [\n                    {\n                        name: \"Total\",\n                        value: `${data.Warnings.length}`,\n                    },\n                    ...fields\n                ],\n                type: 'editreply'\n            }, interaction)\n        }\n        else {\n            client.embed({\n                title: `${client.emotes.normal.error}・Warnings`,\n                desc: `User ${member.user.tag} has no warnings!`,\n                type: 'editreply'\n            }, interaction)\n        }\n    })\n}\n\n","size_bytes":1779},"src/commands/music/bassboost.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    const player = client.player.players.get(interaction.guild.id);\n\n    const levels = {\n        0: 0.0,\n        1: 0.50,\n        2: 1.0,\n        3: 2.0,\n    };\n\n    const channel = interaction.member.voice.channel;\n    if (!channel) return client.errNormal({\n        error: `You're not in a voice channel!`,\n        type: 'editreply'\n    }, interaction);\n\n    if (player && (channel.id !== player?.voiceChannel)) return client.errNormal({\n        error: `You're not in the same voice channel!`,\n        type: 'editreply'\n    }, interaction);\n\n    if (!player || !player.queue.current) return client.errNormal({\n        error: \"There are no songs playing in this server\",\n        type: 'editreply'\n    }, interaction);\n\n    let level = interaction.options.getString('level');\n\n    const bands = new Array(3)\n        .fill(null)\n        .map((_, i) =>\n            ({ band: i, gain: levels[level] })\n        );\n\n    player.setEQ(...bands);\n\n    client.succNormal({\n        text: `Bass boost level adjusted to **level ${level}**`,\n        type: 'editreply'\n    }, interaction);\n}\n\n ","size_bytes":1176},"src/commands/music/clear.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    const player = client.player.players.get(interaction.guild.id);\n\n    const channel = interaction.member.voice.channel;\n    if (!channel) return client.errNormal({\n        error: `You're not in a voice channel!`,\n        type: 'editreply'\n    }, interaction);\n\n    if (player && (channel.id !== player?.voiceChannel)) return client.errNormal({\n        error: `You're not in the same voice channel!`,\n        type: 'editreply'\n    }, interaction);\n\n    if (!player || !player.queue.current) return client.errNormal({\n        error: \"There are no songs playing in this server\",\n        type: 'editreply'\n    }, interaction);\n\n    if (player.queue.size <= 1) return client.errNormal({\n        error: `There is only one song in the queue!`,\n        type: 'editreply'\n    }, interaction);\n\n    player.queue.clear()\n\n    client.succNormal({\n        text: \"The queue has just been **removed**!\",\n        type: 'editreply'\n    }, interaction);\n}\n\n ","size_bytes":1039},"src/commands/music/loop.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    const player = client.player.players.get(interaction.guild.id);\n\n    const channel = interaction.member.voice.channel;\n    if (!channel) return client.errNormal({\n        error: `You're not in a voice channel!`,\n        type: 'editreply'\n    }, interaction);\n\n    if (player && (channel.id !== player?.voiceChannel)) return client.errNormal({\n        error: `You're not in the same voice channel!`,\n        type: 'editreply'\n    }, interaction);\n\n    if (!player || !player.queue.current) return client.errNormal({\n        error: \"There are no songs playing in this server\",\n        type: 'editreply'\n    }, interaction);\n\n    player.setTrackRepeat(!player.trackRepeat);\n    const trackRepeat = player.trackRepeat ? \"enabled\" : \"disabled\";\n\n    client.succNormal({\n        text: `Loop is **${trackRepeat}** for the current song`,\n        type: 'editreply'\n    }, interaction);\n}\n\n ","size_bytes":981},"src/commands/music/lyrics.js":{"content":"const Discord = require('discord.js');\nconst lyricsFinder = require(\"lyrics-finder\");\n\nmodule.exports = async (client, interaction, args) => {\n    let search = \"\";\n\n        const player = client.player.players.get(interaction.guild.id);\n\n        const channel = interaction.member.voice.channel;\n        if (!channel) return client.errNormal({\n            error: `You're not in a voice channel!`,\n            type: 'editreply'\n        }, interaction);\n\n        if (player && (channel.id !== player?.voiceChannel)) return client.errNormal({\n            error: `You're not in the same voice channel!`,\n            type: 'editreply'\n        }, interaction);\n\n        if (!player || !player.queue.current) return client.errNormal({\n            error: \"There are no songs playing in this server\",\n            type: 'editreply'\n        }, interaction);\n\n        if (!interaction.options.getString('song')) {\n            search = player.queue.current.title;\n        }\n        else {\n            search = interaction.options.getString('song');\n        }\n\n        let lyrics = \"\";\n\n        try {\n            lyrics = await lyricsFinder(search, \"\");\n            if (!lyrics) lyrics = `No lyrics found for ${search} :x:`;\n        } catch (error) {\n            lyrics = `No lyrics found for ${search} :x:`;\n        }\n\n        client.embed({\n            title: `${client.emotes.normal.music}・Lyrics For ${search}`,\n            desc: lyrics,\n            type: 'editreply'\n        }, interaction)\n}\n\n ","size_bytes":1488},"src/commands/music/pause.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    const player = client.player.players.get(interaction.guild.id);\n\n    const channel = interaction.member.voice.channel;\n    if (!channel) return client.errNormal({\n        error: `You're not in a voice channel!`,\n        type: 'editreply'\n    }, interaction);\n\n    if (player && (channel.id !== player?.voiceChannel)) return client.errNormal({\n        error: `You're not in the same voice channel!`,\n        type: 'editreply'\n    }, interaction);\n\n    if (!player || !player.queue.current) return client.errNormal({\n        error: \"There are no songs playing in this server\",\n        type: 'editreply'\n    }, interaction);\n\n    player.pause(true)\n\n    client.succNormal({\n        text: `Paused the music!`,\n        type: 'editreply'\n    }, interaction);\n}\n\n ","size_bytes":857},"src/commands/music/play.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    if (!interaction.member.voice.channel) return client.errNormal({\n        error: `You're not in a voice channel!`,\n        type: 'editreply'\n    }, interaction);\n\n    let channel = interaction.member.voice ? interaction.member.voice.channel : null;\n    if (!channel) return client.errNormal({\n        error: `The channel does not exist!`,\n        type: 'editreply'\n    }, interaction);\n\n    let player = client.player.players.get(interaction.guild.id);\n\n    if (player && (channel.id !== player?.voiceChannel)) return client.errNormal({\n        error: `You are not in the same voice channel!`,\n        type: 'editreply'\n    }, interaction);\n\n    if (!player) {\n        player = client.player.create({\n            guild: interaction.guild.id,\n            voiceChannel: channel.id,\n            textChannel: interaction.channel.id,\n            selfDeafen: true\n        });\n\n        if (!channel.joinable) return client.errNormal({\n            error: `That channel isn\\'t joinable`,\n            type: 'editreply'\n        }, interaction);\n        player.connect()\n\n        setTimeout(() => {\n            if (channel.type == Discord.ChannelType.GuildStageVoice) {\n                interaction.guild.members.me.voice.setSuppressed(false);\n            }\n        }, 500)\n    }\n\n    player = client.player.players.get(interaction.guild.id);\n    if (player.state !== \"CONNECTED\") player.connect();\n\n    var query = interaction.options.getString('song');\n\n    client.simpleEmbed({\n        desc: `🔎┆Searching...`,\n        type: 'editreply'\n    }, interaction)\n\n    const res = await player.search(query, interaction.user);\n\n    if (res.loadType === 'LOAD_FAILED') {\n        if (!player.queue.current) player.destroy();\n        return client.errNormal({\n            error: `Error getting music. Please try again in a few minutes`,\n            type: 'editreply'\n        }, interaction);\n    }\n\n    switch (res.loadType) {\n        case 'NO_MATCHES': {\n            if (!player.queue.current) player.destroy()\n            await client.errNormal({\n                error: `No music was found`,\n                type: 'editreply'\n            }, interaction);\n            break;\n        }\n\n        case 'TRACK_LOADED': {\n            const track = res.tracks[0];\n            await player.queue.add(track);\n\n            if (!player.playing && !player.paused) {\n                player.play();\n            }\n            else {\n                client.embed({\n                    title: `${client.emotes.normal.music}・${track.title}`,\n                    url: track.uri,\n                    desc: `The song has been added to the queue!`,\n                    thumbnail: track.thumbnail,\n                    fields: [\n                        {\n                            name: `👤┆Requested By`,\n                            value: `${track.requester}`,\n                            inline: true\n                        },\n                        {\n                            name: `${client.emotes.normal.clock}┆Ends at`,\n                            value: `<t:${((Date.now() / 1000) + (track.duration / 1000)).toFixed(0)}:f>`,\n                            inline: true\n                        },\n                        {\n                            name: `🎬┆Author`,\n                            value: `${track.author}`,\n                            inline: true\n                        }\n                    ],\n                    type: 'editreply'\n                }, interaction)\n            }\n            break;\n        }\n\n        case 'PLAYLIST_LOADED': {\n            await player.queue.add(res.tracks);\n            if (!player.playing && !player.paused) player.play()\n            else {\n\n            }\n            break;\n        }\n\n        case 'SEARCH_RESULT': {\n            let max = 5, collected, filter = (i) => i.user.id === interaction.user.id;\n            if (res.tracks.length < max) max = res.tracks.length;\n\n            let row = new Discord.ActionRowBuilder()\n                .addComponents(\n                    new Discord.ButtonBuilder()\n                        .setEmoji(\"1️⃣\")\n                        .setCustomId(\"1\")\n                        .setStyle(Discord.ButtonStyle.Secondary),\n\n                    new Discord.ButtonBuilder()\n                        .setEmoji(\"2️⃣\")\n                        .setCustomId(\"2\")\n                        .setStyle(Discord.ButtonStyle.Secondary),\n\n                    new Discord.ButtonBuilder()\n                        .setEmoji(\"3️⃣\")\n                        .setCustomId(\"3\")\n                        .setStyle(Discord.ButtonStyle.Secondary),\n\n                    new Discord.ButtonBuilder()\n                        .setEmoji(\"4️⃣\")\n                        .setCustomId(\"4\")\n                        .setStyle(Discord.ButtonStyle.Secondary),\n\n                    new Discord.ButtonBuilder()\n                        .setEmoji(\"5️⃣\")\n                        .setCustomId(\"5\")\n                        .setStyle(Discord.ButtonStyle.Secondary),\n                );\n\n            let row2 = new Discord.ActionRowBuilder()\n                .addComponents(\n                    new Discord.ButtonBuilder()\n                        .setEmoji(\"🛑\")\n                        .setLabel(\"Cancel\")\n                        .setCustomId(\"cancel\")\n                        .setStyle(Discord.ButtonStyle.Danger),\n                );\n\n            const results = res.tracks\n                .slice(0, max)\n                .map((track, index) => `**[#${++index}]**┆${track.title.length >= 45 ? `${track.title.slice(0, 45)}...` : track.title}`)\n                .join('\\n');\n\n            client.embed({\n                title: `🔍・Search Results`,\n                desc: results,\n                fields: [\n                    {\n                        name: `❓┆Cancel search?`,\n                        value: `Press \\`cancel\\` to stop the search`,\n                        inline: true\n                    }\n                ],\n                components: [row, row2],\n                type: 'editreply'\n            }, interaction)\n\n            try {\n                i = await interaction.channel.awaitMessageComponent({ filter, max: 1, time: 30e3, componentType: Discord.ComponentType.Button, errors: ['time'] });\n            } catch (e) {\n                if (!player.queue.current) player.destroy();\n                row.components.forEach((button) => button.setDisabled(true));\n                row2.components.forEach((button) => button.setDisabled(true));\n                return client.errNormal({\n                    error: `You didn't provide a selection`,\n                    type: 'editreply',\n                    components: [row, row2]\n                }, interaction)\n            }\n\n            const first = i.customId;\n            i.message.delete();\n            i.deferUpdate();\n\n            if (first.toLowerCase() === 'cancel') {\n                if (!player.queue.current) player.destroy();\n                return interaction.channel.send('Cancelled selection.');\n            }\n\n            const index = Number(first) - 1;\n            if (index < 0 || index > max - 1) return client.errNormal({\n                error: `The number you provided too small or too big (1-${max})`,\n                type: 'editreply'\n            }, interaction)\n\n            const track = res.tracks[index];\n            player.queue.add(track);\n\n            if (!player.playing && !player.paused) {\n                player.play();\n            }\n            else {\n                client.embed({\n                    title: `${client.emotes.normal.music}・${track.title}`,\n                    url: track.uri,\n                    desc: `The song has been added to the queue!`,\n                    thumbnail: track.thumbnail,\n                    fields: [\n                        {\n                            name: `👤┆Requested By`,\n                            value: `${track.requester}`,\n                            inline: true\n                        },\n                        {\n                            name: `${client.emotes.normal.clock}┆Ends at`,\n                            value: `<t:${((Date.now() / 1000) + (track.duration / 1000)).toFixed(0)}:f>`,\n                            inline: true\n                        },\n                        {\n                            name: `🎬┆Author`,\n                            value: `${track.author}`,\n                            inline: true\n                        }\n                    ],\n                    type: 'editreply'\n                }, interaction)\n            }\n        }\n    }\n}\n\n ","size_bytes":8693},"src/commands/music/playing.js":{"content":"const Discord = require('discord.js');\n\nconst forHumans = require(\"../../assets/utils/forhumans.js\");\n\nmodule.exports = async (client, interaction, args) => {\n    const player = client.player.players.get(interaction.guild.id);\n\n    const channel = interaction.member.voice.channel;\n    if (!channel) return client.errNormal({\n        error: `You're not in a voice channel!`,\n        type: 'editreply'\n    }, interaction);\n\n    if (player && (channel.id !== player?.voiceChannel)) return client.errNormal({\n        error: `You're not in the same voice channel!`,\n        type: 'editreply'\n    }, interaction);\n\n    if (!player || !player.queue.current) return client.errNormal({\n        error: \"There are no songs playing in this server\",\n        type: 'editreply'\n    }, interaction);\n\n    const musicLength = (player.queue.current.isStream ? null : ((!player.queue.current || !player.queue.current.duration || isNaN(player.queue.current.duration)) ? null : player.queue.current.duration))\n    const nowTime = (!player.position || isNaN(player.position)) ? null : player.position;\n\n    const bar = await createProgressBar(musicLength, nowTime);\n\n    client.embed({\n        title: `${client.emotes.normal.music}・${player.queue.current.title}`,\n        url: player.queue.current.uri,\n        thumbnail: player.queue.current?.thumbnail ? player.queue.current?.thumbnail : '',\n        fields: [\n            {\n                name: `👤┆Requested By`,\n                value: `${player.queue.current.requester}`,\n                inline: true\n            },\n            {\n                name: `${client.emotes.normal.clock}┆Duration`,\n                value: `<t:${((Date.now() / 1000) + (player.queue.current.duration / 1000) - nowTime / 1000).toFixed(0)}:f>`,\n                inline: true\n            },\n            {\n                name: `${client.emotes.normal.volume}┆Volume`,\n                value: `${player.volume}%`,\n                inline: true\n            },\n            {\n                name: `${client.emotes.normal.music}┆Progress`,\n                value: `${new Date(player.position).toISOString().slice(11, 19)} ┃ ` +\n                    bar +\n                    ` ┃ ${new Date(player.queue.current.duration).toISOString().slice(11, 19)}`,\n                inline: false\n            }\n        ],\n        type: 'editreply'\n    }, interaction)\n}\n\nasync function createProgressBar(total, current, size = 10, line = '▬', slider = '🔘') {\n    if (current > total) {\n        const bar = line.repeat(size + 2);\n        const percentage = (current / total) * 100;\n        return [bar, percentage];\n    } else {\n        const percentage = current / total;\n        const progress = Math.round((size * percentage));\n\n        if (progress > 1 && progress < 10) {\n            const emptyProgress = size - progress;\n            const progressText = line.repeat(progress).replace(/.$/, slider);\n            const emptyProgressText = line.repeat(emptyProgress);\n            const bar = progressText + emptyProgressText;\n            return [bar];\n        }\n        else if (progress < 1 || progress == 1) {\n            const emptyProgressText = line.repeat(9);\n            const bar = \"🔘\" + emptyProgressText;\n            return [bar];\n        }\n\n        else if (progress > 10 || progress == 10) {\n            const emptyProgressText = line.repeat(9);\n            const bar = emptyProgressText + \"🔘\";\n            return [bar];\n        }\n    }\n}\n\n ","size_bytes":3467},"src/commands/music/previous.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    const player = client.player.players.get(interaction.guild.id);\n\n    const channel = interaction.member.voice.channel;\n    if (!channel) return client.errNormal({\n        error: `You're not in a voice channel!`,\n        type: 'editreply'\n    }, interaction);\n\n    if (player && (channel.id !== player?.voiceChannel)) return client.errNormal({\n        error: `You're not in the same voice channel!`,\n        type: 'editreply'\n    }, interaction);\n\n    if (!player || !player.queue.previous) return client.errNormal({\n        error: \"There are no songs was played previously\",\n        type: 'editreply'\n    }, interaction);\n\n    const track = player.queue.previous;\n\n    let row = new Discord.ActionRowBuilder()\n        .addComponents(\n            new Discord.ButtonBuilder()\n                .setEmoji(\"⏮️\")\n                .setCustomId(\"Bot-musicprev\")\n                .setStyle(Discord.ButtonStyle.Primary),\n\n            new Discord.ButtonBuilder()\n                .setEmoji(\"⏸️\")\n                .setCustomId(\"Bot-musicpause\")\n                .setStyle(Discord.ButtonStyle.Primary),\n\n            new Discord.ButtonBuilder()\n                .setEmoji(\"⏹️\")\n                .setCustomId(\"Bot-musicstop\")\n                .setStyle(Discord.ButtonStyle.Primary),\n\n            new Discord.ButtonBuilder()\n                .setEmoji(\"⏭️\")\n                .setCustomId(\"Bot-musicnext\")\n                .setStyle(Discord.ButtonStyle.Primary),\n        );\n\n    client.embed({\n        title: `${client.emotes.normal.music}・${track.title}`,\n        url: track.uri,\n        desc: `Music started in <#${player.voiceChannel}>!`,\n        thumbnail: track.thumbnail,\n        fields: [\n            {\n                name: `👤┆Requested By`,\n                value: `${track.requester}`,\n                inline: true\n            },\n            {\n                name: `${client.emotes.normal.clock}┆Ends at`,\n                value: `<t:${((Date.now() / 1000) + (track.duration / 1000)).toFixed(0)}:f>`,\n                inline: true\n            },\n            {\n                name: `🎬┆Author`,\n                value: `${track.author}`,\n                inline: true\n            }\n        ],\n        components: [row],\n        type: 'editreply'\n    }, interaction)\n\n    player.play(player.queue.previous)\n}\n\n ","size_bytes":2416},"src/commands/music/queue.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    const player = client.player.players.get(interaction.guild.id);\n\n    const channel = interaction.member.voice.channel;\n    if (!channel) return client.errNormal({\n        error: `You're not in a voice channel!`,\n        type: 'editreply'\n    }, interaction);\n\n    if (player && (channel.id !== player?.voiceChannel)) return client.errNormal({\n        error: `You're not in the same voice channel!`,\n        type: 'editreply'\n    }, interaction);\n\n    if (!player || !player.queue.current) return client.errNormal({\n        error: \"There are no songs playing in this server\",\n        type: 'editreply'\n    }, interaction);\n\n    let count = 0;\n    let status;\n\n    if (player.queue.length == 0) {\n        status = \"No more music in the queue\";\n    }\n    else {\n        status = player.queue.map((track) => {\n            count += 1;\n            return (`**[#${count}]**┆${track.title.length >= 45 ? `${track.title.slice(0, 45)}...` : track.title} (Requested by <@!${track.requester.id}>)`);\n        }).join(\"\\n\");\n    }\n\n    if (player.queue.current.thumbnail) thumbnail = player.queue.current.thumbnail;\n    else thumbnail = interaction.guild.iconURL({ size: 1024 });\n\n    client.embed({\n        title: `${client.emotes.normal.music}・Songs queue - ${interaction.guild.name}`,\n        desc: status,\n        thumbnail: thumbnail,\n        fields: [\n            {\n                name: `${client.emotes.normal.music} Current song:`,\n                value: `${player.queue.current.title} (Requested by <@!${player.queue.current.requester.id}>)`\n            }\n        ],\n        type: 'editreply'\n    }, interaction)\n}\n\n ","size_bytes":1717},"src/commands/music/remove.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    const player = client.player.players.get(interaction.guild.id);\n    \n    const channel = interaction.member.voice.channel;\n    if (!channel) return client.errNormal({\n        error: `You're not in a voice channel!`,\n        type: 'editreply'\n    }, interaction);\n\n    if (player && (channel.id !== player?.voiceChannel)) return client.errNormal({\n        error: `You're not in the same voice channel!`,\n        type: 'editreply'\n    }, interaction);\n\n    if (!player || !player.queue.current) return client.errNormal({\n        error: \"There are no songs playing in this server\",\n        type: 'editreply'\n    }, interaction);\n\n    let number = interaction.options.getNumber('number');\n\n    if (number > player.queue.size) return client.errNormal({\n        error: `The queue doesn't have that much songs`,\n        type: 'editreply'\n    }, interaction);\n\n    const targetSong = player.queue[parseInt(number - 1)]\n    player.queue.remove((parseInt(number)) - 1)\n\n    client.succNormal({ \n        text: `Removed **${targetSong.title}** from the queue`,\n        type: 'editreply'\n    }, interaction);\n}\n\n \n","size_bytes":1201},"src/commands/music/resume.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    const player = client.player.players.get(interaction.guild.id);\n    \n    const channel = interaction.member.voice.channel;\n    if (!channel) return client.errNormal({\n        error: `You're not in a voice channel!`,\n        type: 'editreply'\n    }, interaction);\n\n    if (player && (channel.id !== player?.voiceChannel)) return client.errNormal({\n        error: `You're not in the same voice channel!`,\n        type: 'editreply'\n    }, interaction);\n\n    if (!player || !player.queue.current) return client.errNormal({\n        error: \"There are no songs playing in this server\",\n        type: 'editreply'\n    }, interaction);\n\n    player.pause(false)\n\n    client.succNormal({\n        text: `Resumed the music!`,\n        type: 'editreply'\n    }, interaction);\n}\n\n ","size_bytes":863},"src/commands/music/seek.js":{"content":"const Discord = require('discord.js');\n\nconst forHumans = require(\"../../assets/utils/forhumans.js\");\n\nmodule.exports = async (client, interaction, args) => {\n    const player = client.player.players.get(interaction.guild.id);\n\n    const channel = interaction.member.voice.channel;\n    if (!channel) return client.errNormal({\n        error: `You're not in a voice channel!`,\n        type: 'editreply'\n    }, interaction);\n\n    if (player && (channel.id !== player?.voiceChannel)) return client.errNormal({\n        error: `You're not in the same voice channel!`,\n        type: 'editreply'\n    }, interaction);\n\n    if (!player || !player.queue.current) return client.errNormal({\n        error: \"There are no songs playing in this server\",\n        type: 'editreply'\n    }, interaction);\n\n    let number = interaction.options.getNumber('time');\n    player.seek(Number(number) * 1000);\n\n    const musicLength = (player.queue.current.isStream ? null : ((!player.queue.current || !player.queue.current.duration || isNaN(player.queue.current.duration)) ? null : player.queue.current.duration))\n    const nowTime = (!player.position || isNaN(player.position)) ? null : player.position;\n\n    const bar = await createProgressBar(musicLength, nowTime);\n\n    client.succNormal({\n        text: `Seeked song to: ${format(Number(number) * 1000)}`,\n        fields: [\n            {\n                name: `${client.emotes.normal.music}┆Progress`,\n                value: `${new Date(player.position).toISOString().slice(11, 19)} ┃ ` +\n                    bar +\n                    ` ┃ ${new Date(player.queue.current.duration).toISOString().slice(11, 19)}`,\n                inline: false\n            }\n        ],\n        type: 'editreply'\n    }, interaction)\n}\n\nasync function createProgressBar(total, current, size = 10, line = '▬', slider = '🔘') {\n    if (current > total) {\n        const bar = line.repeat(size + 2);\n        const percentage = (current / total) * 100;\n        return [bar, percentage];\n    } else {\n        const percentage = current / total;\n        const progress = Math.round((size * percentage));\n\n        if (progress > 1 && progress < 10) {\n            const emptyProgress = size - progress;\n            const progressText = line.repeat(progress).replace(/.$/, slider);\n            const emptyProgressText = line.repeat(emptyProgress);\n            const bar = progressText + emptyProgressText;\n            return [bar];\n        }\n        else if (progress < 1 || progress == 1) {\n            const emptyProgressText = line.repeat(9);\n            const bar = \"🔘\" + emptyProgressText;\n            return [bar];\n        }\n\n        else if (progress > 10 || progress == 10) {\n            const emptyProgressText = line.repeat(9);\n            const bar = emptyProgressText + \"🔘\";\n            return [bar];\n        }\n    }\n}\n\nfunction format(millis) {\n    try {\n        var h = Math.floor(millis / 3600000),\n            m = Math.floor(millis / 60000),\n            s = ((millis % 60000) / 1000).toFixed(0);\n        if (h < 1) return (m < 10 ? \"0\" : \"\") + m + \":\" + (s < 10 ? \"0\" : \"\") + s ;\n        else return (h < 10 ? \"0\" : \"\") + h + \":\" + (m < 10 ? \"0\" : \"\") + m + \":\" + (s < 10 ? \"0\" : \"\") + s;\n    } catch (e) {\n        console.log(String(e.stack).bgRed)\n    }\n}\n\n ","size_bytes":3288},"src/commands/music/shuffle.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    const player = client.player.players.get(interaction.guild.id);\n    \n    const channel = interaction.member.voice.channel;\n    if (!channel) return client.errNormal({\n        error: `You're not in a voice channel!`,\n        type: 'editreply'\n    }, interaction);\n\n    if (player && (channel.id !== player?.voiceChannel)) return client.errNormal({\n        error: `You're not in the same voice channel!`,\n        type: 'editreply'\n    }, interaction);\n\n    if (!player || !player.queue.current) return client.errNormal({\n        error: \"There are no songs playing in this server\",\n        type: 'editreply'\n    }, interaction);\n\n    if (player.queue.size === 0) return client.errNormal({\n        error: \"Not enough song to shuffle\",\n        type: 'editreply'\n    }, interaction);\n\n    player.queue.shuffle()\n\n    client.succNormal({\n        text: `Shuffled the queue!`,\n        type: 'editreply'\n    }, interaction);\n}\n\n ","size_bytes":1019},"src/commands/music/skip.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    const player = client.player.players.get(interaction.guild.id);\n\n    const channel = interaction.member.voice.channel;\n    if (!channel) return client.errNormal({\n        error: `You're not in a voice channel!`,\n        type: 'editreply'\n    }, interaction);\n\n    if (player && (channel.id !== player?.voiceChannel)) return client.errNormal({\n        error: `You're not in the same voice channel!`,\n        type: 'editreply'\n    }, interaction);\n\n    if (!player || !player.queue.current) return client.errNormal({\n        error: \"There are no songs playing in this server\",\n        type: 'editreply'\n    }, interaction);\n\n    player.stop();\n\n    client.succNormal({\n        text: `Skipped the music!`,\n        type: 'editreply'\n    }, interaction);\n}\n\n ","size_bytes":854},"src/commands/music/skipto.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    const player = client.player.players.get(interaction.guild.id);\n\n    const channel = interaction.member.voice.channel;\n    if (!channel) return client.errNormal({\n        error: `You're not in a voice channel!`,\n        type: 'editreply'\n    }, interaction);\n\n    if (player && (channel.id !== player?.voiceChannel)) return client.errNormal({\n        error: `You're not in the same voice channel!`,\n        type: 'editreply'\n    }, interaction);\n\n    if (!player || !player.queue.current) return client.errNormal({\n        error: \"There are no songs playing in this server\",\n        type: 'editreply'\n    }, interaction);\n\n    let number = interaction.options.getNumber('number');\n\n    player.skipto(parseInt(number))\n\n    client.succNormal({ \n        text: `Skipped the music to **${number}**`, \n        type: 'editreply'\n    }, interaction);\n}\n\n ","size_bytes":948},"src/commands/music/stop.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    const player = client.player.players.get(interaction.guild.id);\n\n    const channel = interaction.member.voice.channel;\n    if (!channel) return client.errNormal({\n        error: `You're not in a voice channel!`,\n        type: 'editreply'\n    }, interaction);\n\n    if (player && (channel.id !== player?.voiceChannel)) return client.errNormal({\n        error: `You're not in the same voice channel!`,\n        type: 'editreply'\n    }, interaction);\n\n    if (!player || !player.queue.current) return client.errNormal({\n        error: \"There are no songs playing in this server\",\n        type: 'editreply'\n    }, interaction);\n\n    player.destroy()\n\n    client.succNormal({ \n        text: `Stopped the music!`, \n        type: 'editreply'\n    }, interaction);\n}\n\n ","size_bytes":858},"src/commands/music/volume.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    const player = client.player.players.get(interaction.guild.id);\n\n    const channel = interaction.member.voice.channel;\n    if (!channel) return client.errNormal({\n        error: `You're not in a voice channel!`,\n        type: 'editreply'\n    }, interaction);\n\n    if (player && (channel.id !== player?.voiceChannel)) return client.errNormal({\n        error: `You're not in the same voice channel!`,\n        type: 'editreply'\n    }, interaction);\n\n    if (!player || !player.queue.current) return client.errNormal({\n        error: \"There are no songs playing in this server\",\n        type: 'editreply'\n    }, interaction);\n\n    let amount = interaction.options.getNumber('amount');\n\n    if (!amount) return client.simpleEmbed({\n        desc: `${client.emotes.normal.volume}┆Current volume is **${player.volume}%**`,\n        type: 'editreply'\n    }, interaction);\n\n    if (isNaN(amount) || amount === 'Infinity') return client.errNormal({\n        text: `Please enter a valid number!`,\n        type: 'editreply'\n    }, interaction);\n\n    if (Math.round(parseInt(amount)) < 1 || Math.round(parseInt(amount)) > 1000) return client.errNormal({\n        text: \"Volume cannot exceed 1000%\",\n        type: 'editreply'\n    }, interaction);\n\n    player.setVolume(parseInt(amount))\n\n    client.succNormal({\n        text: `Volume set to **${amount}%**`,\n        type: 'editreply'\n    }, interaction);\n}\n\n ","size_bytes":1493},"src/commands/notepad/add.js":{"content":"const Discord = require('discord.js');\nconst generator = require('generate-password');\n\nconst Schema = require(\"../../database/models/notes\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    const code = generator.generate({\n        length: 4,\n        lowercase: false,\n        uppercase: false,\n        numbers: true\n    });\n\n    let note = interaction.options.getString('note');\n\n    Schema.findOne({ Guild: interaction.guild.id, Code: code }, async (err, data) => {\n        if (!data) {\n            new Schema({\n                Guild: interaction.guild.id,\n                User: interaction.user.id,\n                Code: code,\n                Note: note\n            }).save();\n\n            client.succNormal({ text: \"Note has been added! \\`/notepad notes\\` to see all your notes\", type: 'editreply' }, interaction);\n        }\n    })\n}\n\n ","size_bytes":855},"src/commands/notepad/delete.js":{"content":"const Discord = require('discord.js');\nconst generator = require('generate-password');\n\nconst Schema = require(\"../../database/models/notes\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    let id = interaction.options.getString('id');\n\n    Schema.findOne({ Guild: interaction.guild.id, Code: id }, async (err, data) => {\n        if (data) {\n            Schema.findOneAndDelete({ Guild: interaction.guild.id, Code: id }).then(() => {\n                client.succNormal({ text: `Note **#${id}** has been deleted!`, type: 'editreply' }, interaction);\n            })\n        }\n        else {\n            client.errNormal({ error: `No note found with the id **#${id}**`, type: 'editreply' }, interaction);\n        }\n    })\n}\n\n ","size_bytes":737},"src/commands/notepad/edit.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/notes\");\n\nmodule.exports = async (client, interaction, args) => {\n    let id = interaction.options.getString('id');\n    let note = interaction.options.getString('note');\n\n    Schema.findOne({ Guild: interaction.guild.id, Code: id }, async (err, data) => {\n        if (data) {\n            data.Note = note\n            data.save();\n\n            client.succNormal({ text: \"Note has been edited!\", type: 'editreply' }, interaction);\n        }\n        else {\n            client.errNormal({ error: `No note found!`, type: 'editreply' }, interaction);\n        }\n    })\n}\n\n ","size_bytes":652},"src/commands/notepad/notes.js":{"content":"const Discord = require('discord.js');\nconst generator = require('generate-password');\n\nconst Schema = require(\"../../database/models/notes\");\n\nmodule.exports = async (client, interaction, args) => {\n    const rawboard = await Schema.find({ Guild: interaction.guild.id, User: interaction.user.id })\n\n    if (rawboard.length < 1) return client.errNormal({ error: \"No notes found!\", type: 'editreply' }, interaction);\n\n    const lb = rawboard.map(e => `**Note ID: ${e.Code}** \\n${e.Note} \\n`);\n\n    await client.createLeaderboard(`📓・Notes - ${interaction.user.username}`, lb, interaction);\n}\n\n ","size_bytes":597},"src/commands/profile/aboutme.js":{"content":"const Schema = require('../../database/models/profile');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const aboutme = interaction.options.getString('text');\n\n    if (aboutme.length > 1024) return client.errNormal({ error: \"Your about me cannot be longer than 1024 characters\", type: 'editreply' }, interaction);\n\n    Schema.findOne({ User: interaction.user.id }, async (err, data) => {\n        if (data) {\n            data.Aboutme = aboutme;\n            data.save();\n\n            client.succNormal({\n                text: \"Your about me is set\",\n                fields: [{\n                    name: \"📘┆About Me\",\n                    value: `\\`\\`\\`${aboutme}\\`\\`\\``,\n                    inline: true,\n                }],\n                type: 'editreply'\n            }, interaction);\n        }\n        else {\n            return client.errNormal({ error: \"No profile found! Open a profile with createprofile\", type:'editreply' }, interaction);\n        }\n    })\n}\n\n ","size_bytes":985},"src/commands/profile/addactor.js":{"content":"const Schema = require('../../database/models/profile');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const actor = interaction.options.getString('actor');\n\n    Schema.findOne({ User: interaction.user.id }, async (err, data) => {\n        if (data) {\n\n            if (data && data.Actors) {\n                if (data.Actors.includes(actor)) {\n                    return client.errNormal({ error: `That actor is already exists in your database!`, type: 'editreply' }, interaction);\n                }\n                data.Actors.push(actor);\n                data.save();\n            }\n            else {\n                data.Actors = actor;\n                data.save();\n            }\n            client.succNormal({\n                text: \"Added your actor\",\n                fields: [{\n                    name: \"👨‍🎤┆Actor\",\n                    value: `\\`\\`\\`${actor}\\`\\`\\``,\n                    inline: true,\n                }],\n                type: 'editreply'\n            }, interaction);\n        }\n        else {\n            return client.errNormal({ error: \"No profile found! Open a profile with createprofile\", type:'editreply' }, interaction);\n        }\n    })\n\n}\n\n ","size_bytes":1196},"src/commands/profile/addartist.js":{"content":"const Schema = require('../../database/models/profile');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const artist = interaction.options.getString('artist');\n\n    Schema.findOne({ User: interaction.user.id }, async (err, data) => {\n        if (data) {\n\n            if (data && data.Artists) {\n                if (data.Artists.includes(artist)) {\n                    return client.errNormal({ error: `That artist is already exists in your database!`, type: 'editreply' }, interaction);\n                }\n                data.Artists.push(artist);\n                data.save();\n            }\n            else {\n                data.Artists = artist;\n                data.save();\n            }\n            client.succNormal({\n                text: \"Added your artist\",\n                fields: [{\n                    name: \"🎤┆Artist\",\n                    value: `\\`\\`\\`${artist}\\`\\`\\``,\n                    inline: true,\n                }],\n                type: 'editreply'\n            }, interaction);\n        }\n        else {\n            return client.errNormal({ error: \"No profile found! Open a profile with createprofile\", type:'editreply' }, interaction);\n        }\n    })\n\n}\n\n ","size_bytes":1202},"src/commands/profile/addfood.js":{"content":"const Schema = require('../../database/models/profile');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const food = interaction.options.getString('food');\n\n    Schema.findOne({ User: interaction.user.id }, async (err, data) => {\n        if (data) {\n\n            if (data && data.Food) {\n                if (data.Food.includes(food)) {\n                    return client.errNormal({ error: `That food is already exists in your database!`, type: 'editreply' }, interaction);\n                }\n                data.Food.push(food);\n                data.save();\n            }\n            else {\n                data.Food = food;\n                data.save();\n            }\n            client.succNormal({\n                text: \"Added your food\",\n                fields: [{\n                    name: \"🥐┆Food\",\n                    value: `\\`\\`\\`${food}\\`\\`\\``,\n                    inline: true,\n                }],\n                type: 'editreply'\n            }, interaction);\n        }\n        else {\n            return client.errNormal({ error: \"No profile found! Open a profile with createprofile\", type:'editreply' }, interaction);\n        }\n    })\n\n}\n\n ","size_bytes":1172},"src/commands/profile/addhobby.js":{"content":"const Schema = require('../../database/models/profile');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const hobby = interaction.options.getString('hobby');\n\n    Schema.findOne({ User: interaction.user.id }, async (err, data) => {\n        if (data) {\n\n            if (data && data.Hobbys) {\n                if (data.Hobbys.includes(hobby)) {\n                    return client.errNormal({ error: `That hobby is already exists in your database!`, type: 'editreply' }, interaction);\n                }\n                data.Hobbys.push(hobby);\n                data.save();\n            }\n            else {\n                data.Hobbys = hobby;\n                data.save();\n            }\n            client.succNormal({\n                text: \"Added your hobby\",\n                fields: [{\n                    name: \"⚽┆Hobby\",\n                    value: `\\`\\`\\`${hobby}\\`\\`\\``,\n                    inline: true,\n                }],\n                type: 'editreply'\n            }, interaction);\n        }\n        else {\n            return client.errNormal({ error: \"No profile found! Open a profile with createprofile\", type:'editreply' }, interaction);\n        }\n    })\n\n}\n\n ","size_bytes":1188},"src/commands/profile/addmovie.js":{"content":"const Schema = require('../../database/models/profile');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const movie = interaction.options.getString('movie');\n\n    Schema.findOne({ User: interaction.user.id }, async (err, data) => {\n        if (data) {\n\n            if (data && data.Movies) {\n                if (data.Movies.includes(movie)) {\n                    return client.errNormal({ error: `That movie is already exists in your database!`, type: 'editreply' }, interaction);\n                }\n                data.Movies.push(movie);\n                data.save();\n            }\n            else {\n                data.Movies = movie;\n                data.save();\n            }\n            client.succNormal({\n                text: \"Added your movie\",\n                fields: [{\n                    name: \"🎬┆Movies\",\n                    value: `\\`\\`\\`${movie}\\`\\`\\``,\n                    inline: true,\n                }],\n                type: 'editreply'\n            }, interaction);\n        }\n        else {\n            return client.errNormal({ error: \"No profile found! Open a profile with createprofile\", type:'editreply' }, interaction);\n        }\n    })\n\n}\n\n ","size_bytes":1190},"src/commands/profile/addpet.js":{"content":"const Schema = require('../../database/models/profile');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const pet = interaction.options.getString('pet');\n\n    Schema.findOne({ User: interaction.user.id }, async (err, data) => {\n        if (data) {\n\n            if (data && data.Pets) {\n                if (data.Pets.includes(pet)) {\n                    return client.errNormal({ error: `That pet is already exists in your database!`, type: 'editreply' }, interaction);\n                }\n                data.Pets.push(pet);\n                data.save();\n            }\n            else {\n                data.Pets = pet;\n                data.save();\n            }\n            client.succNormal({\n                text: \"Added your pet\",\n                fields: [{\n                    name: \"🐶┆Pet\",\n                    value: `\\`\\`\\`${pet}\\`\\`\\``,\n                    inline: true,\n                }],\n                type: 'editreply'\n            }, interaction);\n        }\n        else {\n            return client.errNormal({ error: \"No profile found! Open a profile with createprofile\", type:'editreply' }, interaction);\n        }\n    })\n\n}\n\n ","size_bytes":1163},"src/commands/profile/addsong.js":{"content":"const Schema = require('../../database/models/profile');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const song = interaction.options.getString('song');\n\n    Schema.findOne({ User: interaction.user.id }, async (err, data) => {\n        if (data) {\n\n            if (data && data.Songs) {\n                if (data.Songs.includes(song)) {\n                    return client.errNormal({ error: `That song is already exists in your database!`, type: 'editreply' }, interaction);\n                }\n                data.Songs.push(song);\n                data.save();\n            }\n            else {\n                data.Songs = song;\n                data.save();\n            }\n            client.succNormal({\n                text: \"Added your song\",\n                fields: [{\n                    name: \"🎶┆Song\",\n                    value: `\\`\\`\\`${song}\\`\\`\\``,\n                    inline: true,\n                }],\n                type: 'editreply'\n            }, interaction);\n        }\n        else {\n            return client.errNormal({ error: \"No profile found! Open a profile with createprofile\", type:'editreply' }, interaction);\n        }\n    })\n\n}\n\n ","size_bytes":1176},"src/commands/profile/age.js":{"content":"const Schema = require('../../database/models/profile');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const age = interaction.options.getNumber('number');\n\n    Schema.findOne({ User: interaction.user.id }, async (err, data) => {\n        if (data) {\n            if (isNaN(age)) return client.errNormal({ error: \"No valid number provided\", type: 'editreply' }, interaction)\n\n            data.Age = age;\n            data.save();\n\n            client.succNormal({\n                text: \"Your age is set\",\n                fields: [{\n                    name: \"📆┆Age\",\n                    value: `\\`\\`\\`${age}\\`\\`\\``,\n                    inline: true,\n                }],\n                type: 'editreply'\n            }, interaction);\n        }\n        else {\n            return client.errNormal({ error: \"No profile found! Open a profile with createprofile\", type:'editreply' }, interaction);\n        }\n    })\n}\n\n ","size_bytes":930},"src/commands/profile/bday.js":{"content":"const Schema = require('../../database/models/profile');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const joined = interaction.options.getString('bday');\n    const split = joined.trim().split(\"/\");\n\n    let [day, month] = split;\n\n    if (!day || !month) return client.errUsage({ usage: \"setbday [day]/[month]\", type: 'editreply' }, interaction);\n\n    if (isNaN(day) || isNaN(month)) {\n        return client.errNormal({ error: \"The date you gave is not a valid number\", type: 'editreply' }, interaction);\n    }\n\n    day = parseInt(day);\n    month = parseInt(month);\n\n    if (!day || day > 31) return client.errNormal({ error: \"Wrong day format!\", type: 'editreply' }, interaction);\n    if (!month || month > 12) return client.errNormal({ error: \"Wrong month format!\", type: 'editreply' }, interaction);\n\n    const bday = `${day}/${month}`;\n\n    Schema.findOne({ User: interaction.user.id }, async (err, data) => {\n        if (data) {\n            data.Birthday = bday;\n            data.save();\n\n            client.succNormal({\n                text: \"Your birthday is set\",\n                fields: [{\n                    name: \"🎂┆Bday\",\n                    value: `\\`\\`\\`${bday}\\`\\`\\``,\n                    inline: true,\n                }],\n                type: 'editreply'\n            }, interaction);\n        }\n        else {\n            return client.errNormal({ error: \"No profile found! Open a profile with createprofile\", type:'editreply' }, interaction);\n        }\n    })\n}\n\n ","size_bytes":1505},"src/commands/profile/color.js":{"content":"const Schema = require('../../database/models/profile');\nconst isHexcolor = require('is-hexcolor');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const color = interaction.options.getString('color');\n\n    Schema.findOne({ User: interaction.user.id }, async (err, data) => {\n        if (data) {\n            if (!isHexcolor(color)) return client.errNormal({ error: \"You did not specify an hex color! Example: #ff0000\", type: 'editreply' }, interaction);\n\n            data.Color = color;\n            data.save();\n\n            client.succNormal({\n                text: \"Your favorite color is set\",\n                fields: [{\n                    name: \"🎨┆Color\",\n                    value: `\\`\\`\\`${color}\\`\\`\\``,\n                    inline: true,\n                }],\n                type: 'editreply'\n            }, interaction);\n        }\n        else {\n            return client.errNormal({ error: \"No profile found! Open a profile with createprofile\", type:'editreply' }, interaction);\n        }\n    })\n}\n\n ","size_bytes":1028},"src/commands/profile/create.js":{"content":"const Schema = require('../../database/models/profile');\n\nmodule.exports = async (client, interaction, args) => {\n    Schema.findOne({ User: interaction.user.id }, async (err, data) => {\n        if (data) {\n            return client.errNormal({ error: \"You already have a Bot profile\", type: \"editreply\" }, interaction);\n        }\n        else {\n            new Schema({\n                User: interaction.user.id\n            }).save();\n\n            client.succNormal({ text: \"Profile created! View your profile by running \\`profile\\`\", type: \"editreply\" }, interaction);\n        }\n    })\n}\n\n ","size_bytes":592},"src/commands/profile/delactor.js":{"content":"const Schema = require('../../database/models/profile');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const actor = interaction.options.getString('actor');\n    const user = { User: interaction.user.id }\n\n    Schema.findOne({ User: interaction.user.id }, async (err, data) => {\n        if (data) {\n\n            if (data && data.Actors) {\n                if (!data.Actors.includes(actor)) {\n                    return client.errNormal({ error: `That actor doesn't exist in the database!`, type: 'editreply' }, interaction);\n                }\n\n                const filtered = data.Actors.filter((target) => target !== actor);\n\n                await Schema.findOneAndUpdate(user, {\n                    Actors: filtered\n                });\n            }\n            client.succNormal({\n                text: \"Removed your actor\",\n                fields: [{\n                    name: \"👨‍🎤┆Actor\",\n                    value: `\\`\\`\\`${actor}\\`\\`\\``,\n                    inline: true,\n                }],\n                type: 'editreply'\n            }, interaction);\n        }\n        else {\n            return client.errNormal({ error: \"No profile found! Open a profile with createprofile\", type:'editreply' }, interaction);\n        }\n    })\n\n}\n\n ","size_bytes":1268},"src/commands/profile/delartist.js":{"content":"const Schema = require('../../database/models/profile');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const artist = interaction.options.getString('artist');\n    const user = { User: interaction.user.id }\n\n    Schema.findOne({ User: interaction.user.id }, async (err, data) => {\n        if (data) {\n\n            if (data && data.Artists) {\n                if (!data.Artists.includes(artist)) {\n                    return client.errNormal({ error: `That artist doesn't exist in the database!`, type: 'editreply' }, interaction);\n                }\n\n                const filtered = data.Artists.filter((target) => target !== artist);\n\n                await Schema.findOneAndUpdate(user, {\n                    Artists: filtered\n                });\n            }\n            client.succNormal({\n                text: \"Removed your artist\",\n                fields: [{\n                    name: \"🎤┆Artist\",\n                    value: `\\`\\`\\`${artist}\\`\\`\\``,\n                    inline: true,\n                }],\n                type: 'editreply'\n            }, interaction);\n        }\n        else {\n            return client.errNormal({ error: \"No profile found! Open a profile with createprofile\", type:'editreply' }, interaction);\n        }\n    })\n\n}\n\n ","size_bytes":1273},"src/commands/profile/delete.js":{"content":"const Schema = require('../../database/models/profile');\n\nmodule.exports = async (client, interaction, args) => {\n\n    Schema.findOne({ User: interaction.user.id }, async (err, data) => {\n\n        if (data) {\n            Schema.findOneAndDelete({ Guild: interaction.guild.id, User: interaction.user.id }).then(() => {\n                client.succNormal({\n                    text: \"Your profile was deleted!\",\n                    type: 'editreply'\n                }, interaction);\n            })\n        }\n        else {\n            client.errNormal({\n                error: 'No profile found!',\n                type: 'editreply'\n            }, interaction)\n        }\n    })\n}\n\n ","size_bytes":678},"src/commands/profile/delfood.js":{"content":"const Schema = require('../../database/models/profile');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const food = interaction.options.getString('food');\n    const user = { User: interaction.user.id }\n\n    Schema.findOne({ User: interaction.user.id }, async (err, data) => {\n        if (data) {\n\n            if (data && data.Food) {\n                if (!data.Food.includes(food)) {\n                    return client.errNormal({ error: `That food doesn't exist in the database!`, type: 'editreply' }, interaction);\n                }\n\n                const filtered = data.Food.filter((target) => target !== food);\n\n                await Schema.findOneAndUpdate(user, {\n                    Food: filtered\n                });\n            }\n            client.succNormal({\n                text: \"Removed your food\",\n                fields: [{\n                    name: \"🥐┆Food\",\n                    value: `\\`\\`\\`${food}\\`\\`\\``,\n                    inline: true,\n                }],\n                type: 'editreply'\n            }, interaction);\n        }\n        else {\n            return client.errNormal({ error: \"No profile found! Open a profile with createprofile\", type:'editreply' }, interaction);\n        }\n    })\n\n}\n\n ","size_bytes":1245},"src/commands/profile/delhobby.js":{"content":"const Schema = require('../../database/models/profile');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const hobby = interaction.options.getString('hobby');\n    const user = { User: interaction.user.id }\n\n    Schema.findOne({ User: interaction.user.id }, async (err, data) => {\n        if (data) {\n\n            if (data && data.Hobbys) {\n                if (!data.Hobbys.includes(hobby)) {\n                    return client.errNormal({ error: `That hobby doesn't exist in the database!`, type: 'editreply' }, interaction);\n                }\n\n                const filtered = data.Hobbys.filter((target) => target !== hobby);\n\n                await Schema.findOneAndUpdate(user, {\n                    Hobbys: filtered\n                });\n            }\n            client.succNormal({\n                text: \"Removed your hobby\",\n                fields: [{\n                    name: \"⚽┆Hobby\",\n                    value: `\\`\\`\\`${hobby}\\`\\`\\``,\n                    inline: true,\n                }],\n                type: 'editreply'\n            }, interaction);\n        }\n        else {\n            return client.errNormal({ error: \"No profile found! Open a profile with createprofile\", type:'editreply' }, interaction);\n        }\n    })\n\n}\n\n ","size_bytes":1260},"src/commands/profile/delmovie.js":{"content":"const Schema = require('../../database/models/profile');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const movie = interaction.options.getString('movie');\n    const user = { User: interaction.user.id }\n\n    Schema.findOne({ User: interaction.user.id }, async (err, data) => {\n        if (data) {\n\n            if (data && data.Movies) {\n                if (!data.Movies.includes(movie)) {\n                    return client.errNormal({ error: `That movie doesn't exist in the database!`, type: 'editreply' }, interaction);\n                }\n\n                const filtered = data.Movies.filter((target) => target !== movie);\n\n                await Schema.findOneAndUpdate(user, {\n                    Movies: filtered\n                });\n            }\n            client.succNormal({\n                text: \"Removed your movie\",\n                fields: [{\n                    name: \"🎬┆Movies\",\n                    value: `\\`\\`\\`${movie}\\`\\`\\``,\n                    inline: true,\n                }],\n                type: 'editreply'\n            }, interaction);\n        }\n        else {\n            return client.errNormal({ error: \"No profile found! Open a profile with createprofile\", type:'editreply' }, interaction);\n        }\n    })\n\n}\n\n ","size_bytes":1262},"src/commands/profile/delpet.js":{"content":"const Schema = require('../../database/models/profile');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const pet = interaction.options.getString('pet');\n    const user = { User: interaction.user.id }\n\n    Schema.findOne({ User: interaction.user.id }, async (err, data) => {\n        if (data) {\n\n            if (data && data.Pets) {\n                if (!data.Pets.includes(pet)) {\n                    return client.errNormal({ error: `That pet doesn't exist in the database!`, type: 'editreply' }, interaction);\n                }\n\n                const filtered = data.Pets.filter((target) => target !== pet);\n\n                await Schema.findOneAndUpdate(user, {\n                    Pets: filtered\n                });\n            }\n            client.succNormal({\n                text: \"Removed your pet\",\n                fields: [{\n                    name: \"🐶┆Pet\",\n                    value: `\\`\\`\\`${pet}\\`\\`\\``,\n                    inline: true,\n                }],\n                type: 'editreply'\n            }, interaction);\n        }\n        else {\n            return client.errNormal({ error: \"No profile found! Open a profile with createprofile\", type:'editreply' }, interaction);\n        }\n    })\n\n}\n\n ","size_bytes":1237},"src/commands/profile/delsong.js":{"content":"const Schema = require('../../database/models/profile');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const song = interaction.options.getString('song');\n    const user = { User: interaction.user.id }\n\n    Schema.findOne({ User: interaction.user.id }, async (err, data) => {\n        if (data) {\n\n            if (data && data.Songs) {\n                if (!data.Songs.includes(song)) {\n                    return client.errNormal({ error: `That song doesn't exist in the database!`, type: 'editreply' }, interaction);\n                }\n\n                const filtered = data.Songs.filter((target) => target !== song);\n\n                await Schema.findOneAndUpdate(user, {\n                    Songs: filtered\n                });\n            }\n            client.succNormal({\n                text: \"Removed your song\",\n                fields: [{\n                    name: \"🎶┆Song\",\n                    value: `\\`\\`\\`${song}\\`\\`\\``,\n                    inline: true,\n                }],\n                type: 'editreply'\n            }, interaction);\n        }\n        else {\n            return client.errNormal({ error: \"No profile found! Open a profile with createprofile\", type:'editreply' }, interaction);\n        }\n    })\n\n}\n\n ","size_bytes":1249},"src/commands/profile/gender.js":{"content":"const Schema = require('../../database/models/profile');\nconst Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n\n    Schema.findOne({ User: interaction.user.id }, async (err, data) => {\n        if (data) {\n            const menu = new Discord.StringSelectMenuBuilder()\n                .setCustomId('gender-setup')\n                .setPlaceholder('❌┆Nothing selected')\n                .addOptions(\n                    {\n                        emoji: \"👨\",\n                        label: `Male`,\n                        value: `Male`,\n                    },\n                    {\n                        emoji: \"👩\",\n                        label: `Female`,\n                        value: `Female`,\n                    },\n                    {\n                        emoji: \"👪\",\n                        label: `Other`,\n                        value: `Other`,\n                    }\n                );\n\n            const row = new Discord.ActionRowBuilder()\n                .addComponents(menu)\n\n            client.embed({\n                desc: `Select a gender`,\n                type: 'editreply',\n                components: [row],\n            }, interaction).then(msg => {\n                const filter = i => i.user.id === interaction.user.id;\n\n                interaction.channel.awaitMessageComponent({ filter, max: 1, componentType: Discord.ComponentType.StringSelect }).then(i => {\n                    if (i.customId == 'gender-setup') {\n                        data.Gender = i.values[0];\n                        data.save();\n\n                        client.succNormal({\n                            text: \"Set your gender to \" + i.values[0],\n                            type: 'editreply',\n                            components: [],\n                        }, interaction);\n                    }\n                })\n            })\n        }\n        else {\n            return client.errNormal({ error: \"No profile found! Open a profile with createprofile\", type: 'editreply' }, interaction);\n        }\n    })\n}\n\n ","size_bytes":2068},"src/commands/profile/origin.js":{"content":"const Schema = require('../../database/models/profile');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const country = interaction.options.getString('country');\n\n    if (country.length > 50) return client.errNormal({ error: \"Your origin cannot be longer than 50 characters\", type: 'editreply' }, interaction);\n\n    Schema.findOne({ User: interaction.user.id }, async (err, data) => {\n        if (data) {\n            data.Orgin = country;\n            data.save();\n\n            client.succNormal({\n                text: \"Your origin is set\",\n                fields: [{\n                    name: \"🌍┆Country\",\n                    value: `\\`\\`\\`${country}\\`\\`\\``,\n                    inline: true,\n                }],\n                type: 'editreply'\n            }, interaction);\n        }\n        else {\n            return client.errNormal({ error: \"No profile found! Open a profile with createprofile\", type:'editreply' }, interaction);\n        }\n    })\n}\n\n ","size_bytes":977},"src/commands/profile/profile.js":{"content":"const model = require('../../database/models/badge');\nconst Schema = require('../../database/models/profile');\nconst CreditsSchema = require(\"../../database/models/votecredits\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    const badgeFlags = {\n        DEVELOPER: client.emotes.badges.developer,\n        EVENT: client.emotes.badges.event,\n        BOOSTER: client.emotes.badges.booster,\n        BUGS: client.emotes.badges.bug,\n        MANAGEMENT: client.emotes.badges.management,\n        PREMIUM: client.emotes.badges.premium,\n        SUPPORTER: client.emotes.badges.supporter,\n        TEAM: client.emotes.badges.team,\n        BOOSTER: client.emotes.badges.booster,\n        PARTNER: client.emotes.badges.partner,\n        VOTER: client.emotes.badges.voter,\n        SUPPORT: client.emotes.badges.support,\n        MODERATOR: client.emotes.badges.moderator,\n        DESIGNER: client.emotes.badges.designer,\n        MARKETING: client.emotes.badges.marketing,\n        ACTIVE: client.emotes.badges.active,\n        VIP: client.emotes.badges.vip\n    }\n\n    const flags = {\n        ActiveDeveloper: \"👨‍💻・Active Developer\",\n        BugHunterLevel1: \"🐛・Discord Bug Hunter\",\n        BugHunterLevel2: \"🐛・Discord Bug Hunter\",\n        CertifiedModerator: \"👮‍♂️・Certified Moderator\",\n        HypeSquadOnlineHouse1: \"🏠・House Bravery Member\",\n        HypeSquadOnlineHouse2: \"🏠・House Brilliance Member\",\n        HypeSquadOnlineHouse3: \"🏠・House Balance Member\",\n        HypeSquadEvents: \"🏠・HypeSquad Events\",\n        PremiumEarlySupporter: \"👑・Early Supporter\",\n        Partner: \"👑・Partner\",\n        Quarantined: \"🔒・Quarantined\", // Not sure if this is still a thing\n        Spammer: \"🔒・Spammer\", // Not sure if this one works\n        Staff: \"👨‍💼・Discord Staff\",\n        TeamPseudoUser: \"👨‍💼・Discord Team\",\n        VerifiedBot: \"🤖・Verified Bot\",\n        VerifiedDeveloper: \"👨‍💻・(early)Verified Bot Developer\",\n    }\n\n    const user = interaction.options.getUser('user') || interaction.user;\n\n    Schema.findOne({ User: user.id }, async (err, data) => {\n        if (data) {\n            let Badges = await model.findOne({ User: user.id });\n\n            let credits = 0;\n            const creditData = await CreditsSchema.findOne({ User: user.id });\n\n            if (Badges && Badges.FLAGS.includes(\"DEVELOPER\")) {\n                credits = \"∞\";\n            }\n            else if (creditData) {\n                credits = creditData.Credits;\n            }\n\n            if (!Badges) Badges = { User: user.id };\n\n            const userFlags = user.flags ? user.flags.toArray() : [];\n\n            client.embed({\n                title: `${client.user.username}・Profile`,\n                desc: '_____',\n                thumbnail: user.avatarURL({ dynamic: true }),\n                fields: [{\n                    name: \"👤┆User\",\n                    value: user.username,\n                    inline: true\n                },\n                {\n                    name: \"📘┆Discriminator\",\n                    value: user.discriminator,\n                    inline: true\n                },\n                {\n                    name: \"🆔┆ID\",\n                    value: user.id,\n                    inline: true\n                },\n                {\n                    name: \"👨‍👩‍👦┆Gender\",\n                    value: `${data.Gender || 'Not set'}`,\n                    inline: true\n                },\n                {\n                    name: \"🔢┆Age\",\n                    value: `${data.Age || 'Not set'}`,\n                    inline: true\n                },\n                {\n                    name: \"🎂┆Birthday\",\n                    value: `${data.Birthday || 'Not set'}`,\n                    inline: true\n                },\n                {\n                    name: \"🎨┆Favorite color\",\n                    value: `${data.Color || 'Not set'}`,\n                    inline: true\n                },\n                {\n                    name: \"🐶┆Favorite pets\",\n                    value: `${data.Pets.join(', ') || 'Not set'}`,\n                    inline: true\n                },\n                {\n                    name: \"🍕┆Favorite food\",\n                    value: `${data.Food.join(', ') || 'Not set'}`,\n                    inline: true\n                },\n                {\n                    name: \"🎶┆Favorite songs\",\n                    value: `${data.Songs.join(', ') || 'Not set'}`,\n                    inline: true\n                },\n                {\n                    name: \"🎤┆Favorite artists\",\n                    value: `${data.Artists.join(', ') || 'Not set'}`,\n                    inline: true\n                },\n                {\n                    name: \"🎬┆Favorite movies\",\n                    value: `${data.Movies.join(', ') || 'Not set'}`,\n                    inline: true\n                },\n                {\n                    name: \"👨‍🎤┆Favorite actors\",\n                    value: `${data.Actors.join(', ') || 'Not set'}`,\n                    inline: true\n                },\n                {\n                    name: \"🏴┆Origin\",\n                    value: `${data.Orgin || 'Not set'}`,\n                    inline: true\n                },\n                {\n                    name: \"🎮┆Hobby's\",\n                    value: `${data.Hobbys.join(', ') || 'Not set'}`,\n                    inline: true\n                },\n                {\n                    name: \"😛┆Status\",\n                    value: `${data.Status || 'Not set'}`,\n                    inline: true\n                },\n                {\n                    name: \"📛┆Bot Badges\",\n                    value: `${Badges.FLAGS ? Badges.FLAGS.map(flag => badgeFlags[flag]).join(' ') : 'None'}`,\n                    inline: true\n                },\n                {\n                    name: \"🏷️┆Discord Badges\",\n                    value: `${userFlags.length ? userFlags.map(flag => flags[flag]).join(', ') : 'None' || 'None'}`,\n                    inline: true\n                },\n                {\n                    name: \"💳┆Dcredits\",\n                    value: `${credits || 'None'}`,\n                    inline: true\n                },\n                {\n                    name: \"ℹ️┆About me\",\n                    value: `${data.Aboutme || 'Not set'}`,\n                    inline: false\n                },], type: 'editreply'\n            }, interaction);\n        }\n        else {\n            return client.errNormal({ error: \"No profile found! Open a profile with /profile create\", type:'editreply' }, interaction);\n        }\n    })\n}\n\n ","size_bytes":6748},"src/commands/profile/status.js":{"content":"const Schema = require('../../database/models/profile');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const status = interaction.options.getString('text');\n\n    if (status.length > 30) return client.errNormal({ error: \"Your status cannot be longer than 30 characters\", type: 'editreply' }, interaction);\n\n    Schema.findOne({ User: interaction.user.id }, async (err, data) => {\n        if (data) {\n            data.Status = status;\n            data.save();\n\n            client.succNormal({\n                text: \"Your status is set\",\n                fields: [{\n                    name: \"😎┆Status\",\n                    value: `\\`\\`\\`${status}\\`\\`\\``,\n                    inline: true,\n                }],\n                type: 'editreply'\n            }, interaction);\n        }\n        else {\n            return client.errNormal({ error: \"No profile found! Open a profile with createprofile\", type:'editreply' }, interaction);\n        }\n    })\n}\n\n ","size_bytes":970},"src/commands/radio/play.js":{"content":"const Discord = require('discord.js');\nconst Schema = require(\"../../database/models/music\");\n\nmodule.exports = async (client, interaction, args) => {\n    const webhookClientLogs = new Discord.WebhookClient({\n        id: client.webhooks.voiceLogs.id,\n        token: client.webhooks.voiceLogs.token,\n    });\n\n    let channel = interaction.member.voice ? interaction.member.voice.channel : null;\n    if (!channel) return client.errNormal({ text: `The channel does not exist!`, type: 'editreply' }, interaction);\n\n    client.radioStart(channel);\n\n    Schema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n        if (data) {\n            data.Channel = channel.id;\n            data.save();\n        }\n        else {\n            new Schema({\n                Guild: interaction.guild.id,\n                Channel: channel.id,\n            }).save();\n        }\n    })\n\n    client.embed({\n        title: `📻・Started radio`,\n        desc: `Radio has started successfully \\nTo make the bot leave do: \\`rleave\\``,\n        fields: [{\n            name: \"👤┆Started By\",\n            value: `${interaction.user} (${interaction.user.tag})`,\n            inline: true\n        },\n        {\n            name: \"📺┆Channel\",\n            value: `${channel} (${channel.name})`,\n            inline: true\n        },\n        {\n            name: \"🎶┆Radio Station\",\n            value: `[Radio 538](https://www.538.nl/)`,\n            inline: true\n        },\n        ],\n        type: 'editreply'\n    }, interaction)\n\n    let embed = new Discord.EmbedBuilder()\n        .setTitle(`📻・Started radio`)\n        .setDescription(`_______________ \\n\\nRadio has started successfully`)\n        .addFields(\n            { name: \"👤┆Started By\", value: `${interaction.user} (${interaction.user.tag})`, inline: true },\n            { name: \"📺┆Channel\", value: `${channel} (${channel.name})`, inline: true },\n            { name: \"⚙️┆Guild\", value: `${interaction.guild.name} (${interaction.guild.id})`, inline: true },\n        )\n        .setColor(client.config.colors.normal)\n        .setTimestamp();\n    webhookClientLogs.send({\n        username: 'Bot Logs',\n        embeds: [embed],\n    });\n}\n\n ","size_bytes":2200},"src/commands/radio/playing.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    client.embed({\n        title: `📻・Radio information`,\n        desc: `All info about the radio in this guild`,\n        fields: [{\n            name: \"👤┆Channel Listeners\",\n            value: `${interaction.member.voice.channel.members.size} listeners`,\n            inline: true\n        },\n        {\n            name: \"📺┆Connected channel\",\n            value: `${interaction.member.voice.channel} (${interaction.member.voice.channel.name})`,\n            inline: true\n        },\n        {\n            name: \"🎶┆Radio Station\",\n            value: `[Radio 538](https://www.538.nl/)`,\n            inline: true\n        },\n        ],\n       type: 'editreply'\n    }, interaction)\n}\n\n ","size_bytes":792},"src/commands/radio/stop.js":{"content":"const Discord = require('discord.js');\nconst Schema = require(\"../../database/models/music\");\n\nmodule.exports = async (client, interaction, args) => {\n    const webhookClientLogs = new Discord.WebhookClient({\n        id: client.webhooks.voiceLogs.id,\n        token: client.webhooks.voiceLogs.token,\n    });\n\n    let channel = interaction.member.voice ? interaction.member.voice.channel : null;\n    if (!channel) return client.errNormal({ error: `The channel does not exist!`, type: 'editreply' }, interaction);\n\n    client.radioStop(channel);\n\n    var remove = await Schema.deleteOne({ Guild: interaction.guild.id });\n\n    client.embed({\n        title: `📻・Radio stopped`,\n        desc: `Radio has stopped successfully \\nTo make the bot join do: \\`rplay\\``,\n        fields: [{\n            name: \"👤┆Stopped By\",\n            value: `${interaction.user} (${interaction.user.tag})`,\n            inline: true\n        },\n        {\n            name: \"📺┆Channel\",\n            value: `${channel} (${channel.name})`,\n            inline: true\n        }\n        ],\n        type: 'editreply'\n    }, interaction)\n\n    let embed = new Discord.EmbedBuilder()\n        .setTitle(`📻・Radio stopped`)\n        .setDescription(`_______________ \\n\\nRadio has stopped successfully`)\n        .addFields(\n            { name: \"👤┆Stopped By\", value: `${interaction.user} (${interaction.user.tag})`, inline: true },\n            { name: \"📺┆Channel\", value: `${channel} (${channel.name})`, inline: true },\n            { name: \"⚙️┆Guild\", value: `${interaction.guild.name} (${interaction.guild.id})`, inline: true },\n        )\n        .setColor(client.config.colors.normal)\n        .setTimestamp();\n    webhookClientLogs.send({\n        username: 'Bot Logs',\n        embeds: [embed],\n    });\n}\n\n ","size_bytes":1797},"src/commands/reactionroles/add.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/reactionRoles\");\n\nmodule.exports = async (client, interaction, args) => {\n    const category = interaction.options.getString('category');\n    const role = interaction.options.getRole('role');\n    const emoji = interaction.options.getString('emoji');\n\n    const parsedEmoji = Discord.parseEmoji(emoji);\n    if (!parsedEmoji) return client.errNormal({\n        error: `Emoji not found in this server!`,\n        type: 'editreply'\n    }, interaction)\n\n    Schema.findOne({ Guild: interaction.guild.id, Category: category }, async (err, data) => {\n        if (data) {\n            data.Roles[emoji] = [\n                role.id,\n                {\n                    id: parsedEmoji.id,\n                    raw: emoji\n                }\n            ]\n\n            await Schema.findOneAndUpdate({ Guild: interaction.guild.id, Category: category }, data)\n        }\n        else {\n            new Schema({\n                Guild: interaction.guild.id,\n                Message: 0,\n                Category: category,\n                Roles: {\n                    [emoji]: [\n                        role.id,\n                        {\n                            id: parsedEmoji.id,\n                            raw: emoji\n                        }\n                    ]\n                }\n            }).save();\n        }\n\n        client.succNormal({ \n            text: \"Reaction role successfully created! Create a panel in the following way\",\n            fields: [\n                {\n                    name: `📘┆Menu panel`,\n                    value: `\\`/reactionroles menu [category name]\\``,\n                    inline: true\n                },\n                {\n                    name: `📘┆Button panel`,\n                    value: `\\`/reactionroles button [category name]\\``,\n                    inline: true\n                }\n            ],\n            type: 'editreply'\n        }, interaction);\n    })\n}\n\n ","size_bytes":1993},"src/commands/reactionroles/button.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/reactionRoles\");\n\nmodule.exports = async (client, interaction, args) => {\n    const category = interaction.options.getString('category');\n    const channel = interaction.options.getChannel('channel') || interaction.channel;\n\n    const lower = category.toLowerCase();\n    const upper = lower.charAt(0).toUpperCase() + lower.substring(1);\n\n    Schema.findOne({ Guild: interaction.guild.id, Category: category }, async (err, data) => {\n        if (!data) return client.errNormal({ \n            error: `No data found!`,\n            type: 'editreply'\n        }, interaction);\n\n        const mapped = Object.keys(data.Roles)\n            .map((value, index) => {\n                const role = interaction.guild.roles.cache.get(data.Roles[value][0]);\n\n                return `${data.Roles[value][1].raw} | ${role}`;\n            }).join(\"\\n\");\n\n        const reactions = Object.values(data.Roles).map((val) => val[1].raw);\n        var sendComponents = await client.buttonReactions(\"id\", reactions)\n\n        client.embed({\n            title: `${upper}・Roles`,\n            desc: `_____ \\n\\nChoose your roles by pressing the button! \\n\\n${mapped}`,\n            components: sendComponents\n        }, channel).then((msg) => {\n            data.Message = msg.id;\n            data.save();\n        })\n\n        client.succNormal({ \n            text: \"Reaction panel successfully created!\",\n            type: 'ephemeraledit'\n        }, interaction);\n    })\n}\n\n ","size_bytes":1528},"src/commands/reactionroles/delete.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/reactionRoles\");\n\nmodule.exports = async (client, interaction, args) => {\n    const category = interaction.options.getString('category');\n\n    Schema.findOne({ Guild: interaction.guild.id, Category: category }, async (err, data) => {\n        if (!data) return client.errNormal({ \n            error: `No data found!`,\n            type: 'editreply'\n        }, interaction);\n\n        var remove = await Schema.deleteOne({ Guild: interaction.guild.id, Category: category });\n\n        client.succNormal({ \n            text: `**${category}** successfully deleted!`,\n            type: 'editreply'\n        }, interaction);\n    })\n}\n\n ","size_bytes":712},"src/commands/reactionroles/list.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/reactionRoles\");\n\nmodule.exports = async (client, interaction, args) => {\n    const reactions = await Schema.find({ Guild: interaction.guild.id });\n    if (!reactions) return client.errNormal({ \n        error: `No data found!`,\n        type: 'editreply'\n    }, interaction);\n    \n    let list = ``;\n\n    for (var i = 0; i < reactions.length; i++) {\n        list += `**${i + 1}** - Category: ${reactions[i].Category} \\n`;\n    }\n\n    await client.embed({\n        title: \"📃・Reaction roles\",\n        desc: list,\n        type: 'editreply'\n    }, interaction)\n}\n\n ","size_bytes":649},"src/commands/reactionroles/menu.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/reactionRoles\");\n\nmodule.exports = async (client, interaction, args) => {\n    const category = interaction.options.getString('category');\n    const channel = interaction.options.getChannel('channel') || interaction.channel;\n\n    const lower = category.toLowerCase();\n    const upper = lower.charAt(0).toUpperCase() + lower.substring(1);\n\n    Schema.findOne({ Guild: interaction.guild.id, Category: category }, async (err, data) => {\n        if (!data) return client.errNormal({ \n            error: `No data found!`,\n            type: 'editreply'\n        }, interaction);\n\n        const map = Object.keys(data.Roles)\n            .map((value, index) => {\n                const role = interaction.guild.roles.cache.get(data.Roles[value][0]);\n                if(!role) return;\n\n                return `${data.Roles[value][1].raw} | ${role}`;\n            }).join(\"\\n\");\n\n        const menu = new Discord.StringSelectMenuBuilder()\n            .setCustomId('reaction_select')\n            .setPlaceholder('❌┇Nothing selected')\n            .setMinValues(1)\n\n        var labels = [];\n\n        const mapped = Object.keys(data.Roles).map((value, index) => {\n            const role = interaction.guild.roles.cache.get(data.Roles[value][0]);\n            if(!role) return;\n\n            const generated = {\n                label: `${role.name}`,\n                description: `Add or remove the role ${role.name}`,\n                emoji: data.Roles[value][1].raw,\n                value: data.Roles[value][1].raw,\n            }\n\n            return labels.push(generated);\n        }).join(\"\\n\");\n\n        await menu.addOptions(labels);\n\n        const row = new Discord.ActionRowBuilder()\n            .addComponents(menu)\n\n        client.embed({\n            title: `${upper}・Roles`,\n            desc: `_____ \\n\\nChoose your roles in the menu! \\n\\n${map}`,\n            components: [row]\n        }, channel).then(async(msg) => {\n            if(!msg){\n                client.errNormal({\n                    error: \"I couldn't send the message!\\nMake sure I have the correct permissions!\",\n                    type: 'editreply'\n                }, interaction);\n                return;\n            }\n            data.Message = msg.id;\n            data.save();\n        })\n\n        client.succNormal({ \n            text: \"Reaction panel successfully created!\",\n            type: 'ephemeraledit'\n        }, interaction);\n    })\n}\n\n ","size_bytes":2496},"src/commands/search/bing.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n\n    let name = encodeURIComponent(interaction.options.getString('name'));\n    let link = `https://www.bing.com/search?q=${name}`;\n\n    client.succNormal({\n        text: `I have found the following for: \\`${name}\\``,\n        fields: [\n            {\n                name: `🔗┇Link`,\n                value: `[Click here to see the link](${link})`,\n                inline: true,\n            }\n        ], type: 'editreply'\n    }, interaction);\n\n}\n\n ","size_bytes":545},"src/commands/search/corona.js":{"content":"const Discord = require('discord.js');\nconst fetch = require('node-fetch');\n\nmodule.exports = async (client, interaction, args) => {\n\n    let countries = interaction.options.getString('country');\n\n    fetch(`https://covid19.mathdro.id/api/countries/${countries}`)\n        .then(response => response.json())\n        .then(data => {\n            let confirmed = data.confirmed.value.toLocaleString()\n            let recovered = data.recovered.value.toLocaleString()\n            let deaths = data.deaths.value.toLocaleString()\n\n\n            return client.embed({\n                title: `💉・COVID-19 - ${countries}`,\n                fields: [{\n                    name: \"✅┇Confirmed Cases\",\n                    value: `${confirmed}`,\n                    inline: true,\n                },\n                {\n                    name: \"🤗┇Recovered\",\n                    value: `${recovered}`,\n                    inline: true,\n                },\n                {\n                    name: \"💀┇Deaths\",\n                    value: `${deaths}`,\n                    inline: true,\n                },\n                ], type: 'editreply'\n            }, interaction);\n\n        }).catch(e => {\n            return client.errNormal({ error: `Invalid country provided!`, type: 'editreply' }, interaction);\n        })\n}\n\n ","size_bytes":1319},"src/commands/search/crypto.js":{"content":"const Discord = require('discord.js');\nconst axios = require('axios');\n\nmodule.exports = async (client, interaction, args) => {\n\n    let coin = interaction.options.getString('coin');\n    let currency = interaction.options.getString('currency');\n\n    try {\n        const { data } = await axios.get(\n            `https://api.coingecko.com/api/v3/simple/price?ids=${coin}&vs_currencies=${currency}`\n        );\n\n        if (!data[coin][currency]) return;\n\n        client.embed({ \n            title: `💹・Crypto stats`, \n            desc: `The current price of **1 ${coin}** = **${data[coin][currency]} ${currency}**`, \n            type: 'editreply' \n        }, interaction);\n    }\n    catch {\n        client.errNormal({ \n            error: \"Please check your inputs!\", \n            type: 'editreply' \n        }, interaction);\n    }\n}\n\n ","size_bytes":835},"src/commands/search/ddg.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n\n    let name = encodeURIComponent(interaction.options.getString('name'));\n    let link = `https://duckduckgo.com/?q=${name}`;\n\n    client.succNormal({\n        text: `I have found the following for: \\`${name}\\``,\n        fields: [\n            {\n                name: `🔗┇Link`,\n                value: `[Click here to see the link](${link})`,\n                inline: true,\n            }\n        ], type: 'editreply'\n    }, interaction);\n\n}\n\n ","size_bytes":541},"src/commands/search/docs.js":{"content":"const Discord = require('discord.js');\nconst axios = require('axios');\n\nmodule.exports = async (client, interaction, args) => {\n\n    let name = interaction.options.getString('name');\n\n    const uri = `https://djsdocs.sorta.moe/v2/embed?src=stable&q=${encodeURIComponent(\n        name\n    )}`;\n\n    axios.get(uri).then((embed) => {\n        const { data } = embed\n\n        if (data && !data.error) {\n            interaction.editreply({ embeds: [data] })\n        } else {\n            client.errNormal({ \n                error: \"Could not find that documentation!\", \n                type: 'editreply' \n            }, interaction)\n        }\n    }).catch((err) => {\n    })\n}\n\n ","size_bytes":671},"src/commands/search/github.js":{"content":"const Discord = require('discord.js');\nconst pop = require(\"popcat-wrapper\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    let name = interaction.options.getString('name');\n\n    const r = await pop.github(name).catch(() => {\n        return client.errNormal({\n            error: `No account found with the username: ${name}`,\n            type: 'editreply'\n        }, interaction)\n    \n    })\n\n    client.embed({\n        title: `🏷️・${r.name}`,\n        thumbnail: r.avatar,\n        url: r.url,\n        fields: [\n            {\n                name: \"💬┇Name\",\n                value: `${r.name}`,\n                inline: true,\n            },\n            {\n                name: \"🧑‍💼┇Company\",\n                value: `${r.company}`,\n                inline: true,\n            },\n            {\n                name: \"💬┇Bio\",\n                value: `${r.bio}`,\n                inline: true,\n            },\n            {\n                name: \"📁┇Public Repositories\",\n                value: `${r.public_repos}`,\n                inline: true,\n            },\n            {\n                name: \"⏰┇Created At\",\n                value: `<t:${Math.round(new Date(r.created_at).getTime() / 1000)}>`,\n                inline: true,\n            },\n        ], type: 'editreply'\n    }, interaction)\n}\n\n ","size_bytes":1334},"src/commands/search/google.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n\n    let name = encodeURIComponent(interaction.options.getString('name'));\n    let link = `https://www.google.com/search?q=${name}`;\n\n    client.succNormal({\n        text: `I have found the following for: \\`${name}\\``,\n        fields: [\n            {\n                name: `🔗┇Link`,\n                value: `[Click here to see the link](${link})`,\n                inline: true,\n            }\n        ], type: 'editreply'\n    }, interaction);\n\n}\n\n ","size_bytes":547},"src/commands/search/hexcolour.js":{"content":"const Discord = require('discord.js');\nconst axios = require('axios');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const color = interaction.options.getString('color');\n\n    const { data } = await axios.get(\n        `https://some-random-api.ml/canvas/rgb?hex=${color}`\n    ).catch(e => {\n        return client.errNormal({ \n            error: \"Color not found!\",\n            type: 'editreply'\n        }, interaction)\n    });\n\n    client.embed({\n        title: `🎨・Color info`,\n        image: `https://some-random-api.ml/canvas/colorviewer?hex=${color}`,\n        color: `#${color}`,\n        fields: [\n            {\n                name: \"Hex\",\n                value: `#${color}`,\n                inline: true,\n            },\n            {\n                name: \"RGB\",\n                value: `${data.r}, ${data.g}, ${data.b}`,\n                inline: true,\n            }\n        ],\n        type: 'editreply'\n    }, interaction)\n}\n\n ","size_bytes":951},"src/commands/search/itunes.js":{"content":"const Discord = require('discord.js');\nconst pop = require(\"popcat-wrapper\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    const song = interaction.options.getString('song');\n\n    const r = await pop.itunes(song).catch(e => {\n        return client.errNormal({ \n            error: \"Song not found!\",\n            type: 'editreply'\n        }, interaction)\n    });\n\n    client.embed({\n        title: `🎶・${r.name}`,\n        thumbnail: r.thumbnail,\n        url: r.url,\n        fields: [\n            {\n                name: \"💬┇Name\",\n                value: `${r.name}`,\n                inline: true,\n            },\n            {\n                name: \"🎤┇Artist\",\n                value: `${r.artist}`,\n                inline: true,\n            },\n            {\n                name: \"📁┇Album\",\n                value: `${r.album}`,\n                inline: true,\n            },\n            {\n                name: \"🎼┇Length\",\n                value: `${r.length}`,\n                inline: true,\n            },\n            {\n                name: \"🏷️┇Genre\",\n                value: `${r.genre}`,\n                inline: true,\n            },\n            {\n                name: \"💵┇Price\",\n                value: `${r.price}`,\n                inline: true,\n            },\n            {\n                name: \"⏰┇Release Date\",\n                value: `<t:${Math.round(new Date(r.release_date).getTime() / 1000)}>`,\n                inline: true,\n            },\n        ],\n        type: 'editreply'\n    }, interaction)\n}\n\n ","size_bytes":1563},"src/commands/search/npm.js":{"content":"const Discord = require('discord.js');\nconst pop = require(\"popcat-wrapper\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    const name = interaction.options.getString('name');\n\n    const r = await pop.npm(name).catch(e => {\n        return client.errNormal({ \n            error: \"Package not found!\",\n            type: 'editreply'\n        }, interaction)\n    });\n\n    client.embed({\n        title: `📁・${r.name}`,\n        fields: [\n            {\n                name: \"💬┇Name\",\n                value: `${r.name}`,\n                inline: true,\n            },\n            {\n                name: \"🏷️┇Version\",\n                value: `${r.version}`,\n                inline: true,\n            },\n            {\n                name: \"📃┇Description\",\n                value: `${r.description}`,\n                inline: true,\n            },\n            {\n                name: \"⌨️┇Keywords\",\n                value: `${r.keywords}`,\n                inline: true,\n            },\n            {\n                name: \"💻┇Author\",\n                value: `${r.author}`,\n                inline: true,\n            },\n            {\n                name: \"📁┇Downloads\",\n                value: `${r.downloads_this_year}`,\n                inline: true,\n            },\n            {\n                name: \"⏰┇Last publish\",\n                value: `<t:${Math.round(new Date(r.last_published).getTime() / 1000)}>`,\n                inline: true,\n            },\n        ],\n        type: 'editreply'\n    }, interaction)\n}\n\n ","size_bytes":1553},"src/commands/search/steam.js":{"content":"const Discord = require('discord.js');\nconst pop = require(\"popcat-wrapper\");\n\nmodule.exports = async (client, interaction, args) => {\n    await interaction.deferReply({ fetchReply: true });\n\n    const name = interaction.options.getString('name');\n\n    const s = await pop.steam(name).catch(e => {\n        return client.errNormal({\n            error: \"Application not found!\",\n            type: 'editreply'\n        }, interaction)\n    });\n\n    await client.embed({\n        title: `🎮・${s.name}`,\n        thumbnail: s.thumbnail,\n        fields: [\n            {\n                name: `💬┇Name`,\n                value: `${s.name}`,\n                inline: true,\n            },\n            {\n                name: `📃┇Capital`,\n                value: `${s.description}`,\n                inline: false,\n            },\n            {\n                name: \"💻┇Developers\",\n                value: `${s.developers.join(\", \")}`,\n                inline: true,\n            },\n            {\n                name: \"☁┇Publishers\",\n                value: `${s.publishers.join(\", \")}`,\n                inline: true,\n            },\n            {\n                name: \"🪙┇Price\",\n                value: `${s.price}`,\n                inline: true,\n            }\n        ],\n        type: 'editreply'\n    }, interaction)\n}\n\n ","size_bytes":1328},"src/commands/search/translate.js":{"content":"const Discord = require('discord.js');\nconst translate = require('@iamtraction/google-translate');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const language = interaction.options.getString('language');\n    const text = interaction.options.getString('text');\n\n    translate(text, { to: language }).then(res => {\n        client.embed({\n            title: `${client.emotes.normal.check}・Success!`,\n            desc: `I have translated the following`,\n            fields: [\n                {\n                    name: \"📥 - Input\",\n                    value: `${text}`,\n                    inline: false,\n                },\n                {\n                    name: \"📤 - Output\",\n                    value: `${res.text}`,\n                    inline: false,\n                },\n            ],\n            type: 'editreply'\n        }, interaction);\n\n    }).catch(err => {\n        console.log(err)\n        client.errNormal({\n            error: \"Please provide a valid ISO language code!\",\n            type: 'editreply'\n        }, interaction);\n    })\n}\n\n ","size_bytes":1075},"src/commands/search/weather.js":{"content":"const Discord = require('discord.js');\nconst weather = require('weather-js');\n\nmodule.exports = async (client, interaction, args) => {\n    const country = interaction.options.getString('location');\n\n    weather.find({ search: country, degreeType: 'C' }, function (error, result) {\n        if (result === undefined || result.length === 0) return client.errNormal({\n            error: \"**Invalid** location\",\n            type: 'editreply'\n        }, interaction);\n\n        var current = result[0].current;\n        var location = result[0].location;\n\n        client.embed({\n            title: `☀️・Weather - ${current.skytext}`,\n            desc: `Weather forecast for ${current.observationpoint}`,\n            thumbnail: current.imageUrl,\n            fields: [\n                {\n                    name: \"Timezone\",\n                    value: `UTC${location.timezone}`,\n                    inline: true,\n                },\n                {\n                    name: \"Degree Type\",\n                    value: `Celsius`,\n                    inline: true,\n                },\n                {\n                    name: \"Temperature\",\n                    value: `${current.temperature}°`,\n                    inline: true,\n                },\n                {\n                    name: \"Wind\",\n                    value: `${current.winddisplay}`,\n                    inline: true,\n                },\n                {\n                    name: \"Feels like\",\n                    value: `${current.feelslike}°`,\n                    inline: true,\n                },\n                {\n                    name: \"Humidity\",\n                    value: `${current.humidity}%`,\n                    inline: true,\n                }\n            ],\n            type: 'editreply'\n        }, interaction)\n    })\n}\n\n ","size_bytes":1805},"src/commands/search/youtube.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n\n    let name = encodeURIComponent(interaction.options.getString('name'));\n    let link = `https://www.youtube.com/results?search_query=${name}`;\n\n    client.succNormal({\n        text: `I have found the following for: \\`${name}\\``,\n        fields: [\n            {\n                name: `🔗┇Link`,\n                value: `[Click here to see the link](${link})`,\n                inline: true,\n            }\n        ], type: 'editreply'\n    }, interaction);\n\n}\n\n ","size_bytes":560},"src/commands/serverstats/animated-emoji.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/stats\");\n\nmodule.exports = async (client, interaction, args) => {\n    let EmojiCount = 0;\n    let Animated = 0;\n    let OverallEmojis = 0;\n\n    interaction.guild.emojis.cache.forEach((emoji) => {\n        OverallEmojis++;\n        if (emoji.animated) {\n            Animated++;\n        } else {\n            EmojiCount++;\n        }\n    });\n\n    var channelName = await client.getTemplate(interaction.guild);\n    channelName = channelName.replace(`{emoji}`, \"🤡\")\n    channelName = channelName.replace(`{name}`, `Animated Emojis: ${Animated || '0'}`)\n\n    await interaction.guild.channels.create({\n        name: channelName,\n        type:  Discord.ChannelType.GuildVoice, permissionOverwrites: [\n            {\n                deny: [Discord.PermissionsBitField.Flags.Connect],\n                id: interaction.guild.id\n            },\n        ],\n    }).then(async (channel) => {\n        Schema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n            if (data) {\n                data.AnimatedEmojis = channel.id;\n                data.save();\n            }\n            else {\n                new Schema({\n                    Guild: interaction.guild.id,\n                    AnimatedEmojis: channel.id\n                }).save();\n            }\n        })\n\n        client.succNormal({\n            text: `Animated emoji's count created!`,\n            fields: [\n                {\n                    name: `📘┆Channel`,\n                    value: `${channel}`\n                }\n            ],\n            type: 'editreply'\n        }, interaction);\n    })\n\n}\n\n ","size_bytes":1658},"src/commands/serverstats/boosts.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/stats\");\n\nmodule.exports = async (client, interaction, args) => {\n    var channelName = await client.getTemplate(interaction.guild);\n    channelName = channelName.replace(`{emoji}`, \"💎\")\n    channelName = channelName.replace(`{name}`, `Boosts: ${interaction.guild.premiumSubscriptionCount || '0'}`)\n\n    interaction.guild.channels.create({\n        name: channelName,\n        type:  Discord.ChannelType.GuildVoice, permissionOverwrites: [\n            {\n                deny: [Discord.PermissionsBitField.Flags.Connect],\n                id: interaction.guild.id\n            },\n        ],\n    }).then(async (channel) => {\n        Schema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n            if (data) {\n                data.Boost = channel.id;\n                data.save();\n            }\n            else {\n                new Schema({\n                    Guild: interaction.guild.id,\n                    Boost: channel.id\n                }).save();\n            }\n        })\n\n        client.succNormal({\n            text: `Boost count created!`,\n            fields: [\n                {\n                    name: `📘┆Channel`,\n                    value: `${channel}`\n                }\n            ],\n            type: 'editreply'\n        }, interaction);\n    })\n\n}\n\n","size_bytes":1376},"src/commands/serverstats/bots.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/stats\");\n\nmodule.exports = async (client, interaction, args) => {\n    const members = await interaction.guild.members.fetch();\n\n    var channelName = await client.getTemplate(interaction.guild);\n    channelName = channelName.replace(`{emoji}`, \"🤖\")\n    channelName = channelName.replace(`{name}`, `Bots: ${members.filter(member => member.user.bot).size || 0}`)\n\n    await interaction.guild.channels.create({\n        name: channelName,\n        type:  Discord.ChannelType.GuildVoice, permissionOverwrites: [\n            {\n                deny: [Discord.PermissionsBitField.Flags.Connect],\n                id: interaction.guild.id\n            },\n        ],\n    }).then(async (channel) => {\n        Schema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n            if (data) {\n                data.Bots = channel.id;\n                data.save();\n            }\n            else {\n                new Schema({\n                    Guild: interaction.guild.id,\n                    Bots: channel.id\n                }).save();\n            }\n        })\n\n        client.succNormal({\n            text: `Bots count created!`,\n            fields: [\n                {\n                    name: `📘┆Channel`,\n                    value: `${channel}`\n                }\n            ],\n            type: 'editreply'\n        }, interaction);\n    })\n\n}\n\n ","size_bytes":1442},"src/commands/serverstats/channels.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/stats\");\n\nmodule.exports = async (client, interaction, args) => {\n    var channelName = await client.getTemplate(interaction.guild);\n    channelName = channelName.replace(`{emoji}`, \"🔧\")\n    channelName = channelName.replace(`{name}`, `Channels: ${interaction.guild.channels.cache.size.toLocaleString()}`)\n\n    await interaction.guild.channels.create({\n        name: channelName,\n        type:  Discord.ChannelType.GuildVoice, permissionOverwrites: [\n            {\n                deny: [Discord.PermissionsBitField.Flags.Connect],\n                id: interaction.guild.id\n            },\n        ],\n    }).then(async (channel) => {\n        Schema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n            if (data) {\n                data.Channels = channel.id;\n                data.save();\n            }\n            else {\n                new Schema({\n                    Guild: interaction.guild.id,\n                    Channels: channel.id\n                }).save();\n            }\n        })\n\n        client.succNormal({\n            text: `Channel count created!`,\n            fields: [\n                {\n                    name: `📘┆Channel`,\n                    value: `${channel}`\n                }\n            ],\n            type: 'editreply'\n        }, interaction);\n    })\n\n}\n\n ","size_bytes":1398},"src/commands/serverstats/emoji.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/stats\");\n\nmodule.exports = async (client, interaction, args) => {\n    var channelName = await client.getTemplate(interaction.guild);\n    channelName = channelName.replace(`{emoji}`, \"😛\")\n    channelName = channelName.replace(`{name}`, `Emojis: ${interaction.guild.emojis.cache.size || '0'}`)\n\n    await interaction.guild.channels.create({\n        name: channelName,\n        type:  Discord.ChannelType.GuildVoice, permissionOverwrites: [\n            {\n                deny: [Discord.PermissionsBitField.Flags.Connect],\n                id: interaction.guild.id\n            },\n        ],\n    }).then(async (channel) => {\n        Schema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n            if (data) {\n                data.Emojis = channel.id;\n                data.save();\n            }\n            else {\n                new Schema({\n                    Guild: interaction.guild.id,\n                    Emojis: channel.id\n                }).save();\n            }\n        })\n\n        client.succNormal({\n            text: `Emoji's count created!`,\n            fields: [\n                {\n                    name: `📘┆Channel`,\n                    value: `${channel}`\n                }\n            ],\n            type: 'editreply'\n        }, interaction);\n    })\n\n}\n\n ","size_bytes":1380},"src/commands/serverstats/members.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/stats\");\n\nmodule.exports = async (client, interaction, args) => {\n    var channelName = await client.getTemplate(interaction.guild);\n    channelName = channelName.replace(`{emoji}`, \"👤\")\n    channelName = channelName.replace(`{name}`, `Members: ${interaction.guild.memberCount.toLocaleString()}`)\n\n    await interaction.guild.channels.create({\n        name: channelName,\n        type:  Discord.ChannelType.GuildVoice, permissionOverwrites: [\n            {\n                deny: [Discord.PermissionsBitField.Flags.Connect],\n                id: interaction.guild.id\n            },\n        ],\n    }).then(async (channel) => {\n        Schema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n            if (data) {\n                data.Members = channel.id;\n                data.save();\n            }\n            else {\n                new Schema({\n                    Guild: interaction.guild.id,\n                    Members: channel.id\n                }).save();\n            }\n        })\n\n        client.succNormal({\n            text: `Member count created!`,\n            fields: [\n                {\n                    name: `📘┆Channel`,\n                    value: `${channel}`\n                }\n            ],\n            type: 'editreply'\n        }, interaction);\n    })\n\n}\n\n ","size_bytes":1386},"src/commands/serverstats/news-channels.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/stats\");\n\nmodule.exports = async (client, interaction, args) => {\n    var channelName = await client.getTemplate(interaction.guild);\n    channelName = channelName.replace(`{emoji}`, \"📢\")\n    channelName = channelName.replace(`{name}`, `News Channels: ${interaction.guild.channels.cache.filter(channel => channel.type ===  Discord.ChannelType.GuildAnnouncement).size || 0}`)\n\n    await interaction.guild.channels.create({\n        name: channelName,\n        type:  Discord.ChannelType.GuildVoice, permissionOverwrites: [\n            {\n                deny: [Discord.PermissionsBitField.Flags.Connect],\n                id: interaction.guild.id\n            },\n        ],\n    }).then(async (channel) => {\n        Schema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n            if (data) {\n                data.NewsChannels = channel.id;\n                data.save();\n            }\n            else {\n                new Schema({\n                    Guild: interaction.guild.id,\n                    NewsChannels: channel.id\n                }).save();\n            }\n        })\n        \n        client.succNormal({\n            text: `News channel count created!`,\n            fields: [\n                {\n                    name: `📘┆Channel`,\n                    value: `${channel}`\n                }\n            ],\n            type: 'editreply'\n        }, interaction);\n    })\n\n}\n\n ","size_bytes":1487},"src/commands/serverstats/roles.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/stats\");\n\nmodule.exports = async (client, interaction, args) => {\n    var channelName = await client.getTemplate(interaction.guild);\n    channelName = channelName.replace(`{emoji}`, \"👔\")\n    channelName = channelName.replace(`{name}`, `Roles: ${interaction.guild.roles.cache.size.toLocaleString()}`)\n\n    await interaction.guild.channels.create({\n        name: channelName,\n        type:  Discord.ChannelType.GuildVoice, permissionOverwrites: [\n            {\n                deny: [Discord.PermissionsBitField.Flags.Connect],\n                id: interaction.guild.id\n            },\n        ],\n    }).then(async (channel) => {\n        Schema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n            if (data) {\n                data.Roles = channel.id;\n                data.save();\n            }\n            else {\n                new Schema({\n                    Guild: interaction.guild.id,\n                    Roles: channel.id\n                }).save();\n            }\n        })\n\n        client.succNormal({\n            text: `Roles count created!`,\n            fields: [\n                {\n                    name: `📘┆Channel`,\n                    value: `${channel}`\n                }\n            ],\n            type: 'editreply'\n        }, interaction);\n    })\n\n}\n\n ","size_bytes":1384},"src/commands/serverstats/stage-channels.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/stats\");\n\nmodule.exports = async (client, interaction, args) => {\n    var channelName = await client.getTemplate(interaction.guild);\n    channelName = channelName.replace(`{emoji}`, \"🎤\")\n    channelName = channelName.replace(`{name}`, `Stage Channels: ${interaction.guild.channels.cache.filter(channel => channel.type ===  Discord.ChannelType.GuildStageVoice).size || 0}`)\n\n    await interaction.guild.channels.create({\n        name: channelName,\n        type:  Discord.ChannelType.GuildVoice, permissionOverwrites: [\n            {\n                deny: [Discord.PermissionsBitField.Flags.Connect],\n                id: interaction.guild.id\n            },\n        ],\n    }).then(async (channel) => {\n        Schema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n            if (data) {\n                data.StageChannels = channel.id;\n                data.save();\n            }\n            else {\n                new Schema({\n                    Guild: interaction.guild.id,\n                    StageChannels: channel.id\n                }).save();\n            }\n        })\n\n        client.succNormal({\n            text: `Stage channel count created!`,\n            fields: [\n                {\n                    name: `📘┆Channel`,\n                    value: `${channel}`\n                }\n            ],\n            type: 'editreply'\n        }, interaction);\n    })\n\n}\n\n ","size_bytes":1481},"src/commands/serverstats/static-emoji.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/stats\");\n\nmodule.exports = async (client, interaction, args) => {\n    let Emojis = \"\";\n    let EmojiCount = 0;\n    let Animated = 0;\n    let OverallEmojis = 0;\n\n    function Emoji(id) {\n        return client.emojis.cache.get(id).toString();\n    }\n\n    interaction.guild.emojis.cache.forEach((emoji) => {\n        OverallEmojis++;\n        if (emoji.animated) {\n            Animated++;\n        } else {\n            EmojiCount++;\n        }\n    });\n\n    var channelName = await client.getTemplate(interaction.guild);\n    channelName = channelName.replace(`{emoji}`, \"😀\")\n    channelName = channelName.replace(`{name}`, `Static Emojis: ${EmojiCount || '0'}`)\n\n    await interaction.guild.channels.create({\n        name: channelName,\n        type:  Discord.ChannelType.GuildVoice, permissionOverwrites: [\n            {\n                deny: [Discord.PermissionsBitField.Flags.Connect],\n                id: interaction.guild.id\n            },\n        ],\n    }).then(async (channel) => {\n        Schema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n            if (data) {\n                data.StaticEmojis = channel.id;\n                data.save();\n            }\n            else {\n                new Schema({\n                    Guild: interaction.guild.id,\n                    StaticEmojis: channel.id\n                }).save();\n            }\n        })\n\n        client.succNormal({\n            text: `Static emoji count created!`,\n            fields: [\n                {\n                    name: `📘┆Channel`,\n                    value: `${channel}`\n                }\n            ],\n            type: 'editreply'\n        }, interaction);\n    })\n\n}\n\n","size_bytes":1757},"src/commands/serverstats/text-channels.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/stats\");\n\nmodule.exports = async (client, interaction, args) => {\n    var channelName = await client.getTemplate(interaction.guild);\n    channelName = channelName.replace(`{emoji}`, \"💬\")\n    channelName = channelName.replace(`{name}`, `Text Channels: ${interaction.guild.channels.cache.filter(channel => channel.type === Discord.ChannelType.GuildText).size || 0}`)\n\n    await interaction.guild.channels.create({\n        name: channelName,\n        type:  Discord.ChannelType.GuildVoice, permissionOverwrites: [\n            {\n                deny: [Discord.PermissionsBitField.Flags.Connect],\n                id: interaction.guild.id\n            },\n        ],\n    }).then(async (channel) => {\n        Schema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n            if (data) {\n                data.TextChannels = channel.id;\n                data.save();\n            }\n            else {\n                new Schema({\n                    Guild: interaction.guild.id,\n                    TextChannels: channel.id\n                }).save();\n            }\n        })\n\n        client.succNormal({\n            text: `Text channel count created!`,\n            fields: [\n                {\n                    name: `📘┆Channel`,\n                    value: `${channel}`\n                }\n            ],\n            type: 'editreply'\n        }, interaction);\n    })\n\n}\n\n ","size_bytes":1470},"src/commands/serverstats/tier.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/stats\");\n\nmodule.exports = async (client, interaction, args) => {\n    let tier = {\n        \"TIER_1\": `1`,\n        \"TIER_2\": `2`,\n        \"TIER_3\": `3`,\n        \"NONE\": `0`,\n    }\n\n    var channelName = await client.getTemplate(interaction.guild);\n    channelName = channelName.replace(`{emoji}`, \"🥇\")\n    channelName = channelName.replace(`{name}`, `Tier: ${tier[interaction.guild.premiumTier] || '0'}`)\n\n    await interaction.guild.channels.create({\n        name: channelName,\n        type:  Discord.ChannelType.GuildVoice, permissionOverwrites: [\n            {\n                deny: [Discord.PermissionsBitField.Flags.Connect],\n                id: interaction.guild.id\n            },\n        ],\n    }).then(async (channel) => {\n        Schema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n            if (data) {\n                data.BoostTier = channel.id;\n                data.save();\n            }\n            else {\n                new Schema({\n                    Guild: interaction.guild.id,\n                    BoostTier: channel.id\n                }).save();\n            }\n        })\n\n        client.succNormal({\n            text: `Tier count created!`,\n            fields: [\n                {\n                    name: `📘┆Channel`,\n                    value: `${channel}`\n                }\n            ],\n            type: 'editreply'\n        }, interaction);\n    })\n\n}\n\n ","size_bytes":1495},"src/commands/serverstats/time.js":{"content":"const Discord = require('discord.js');\nconst moment = require('moment');\nconst momentTimezone = require('moment-timezone');\n\nconst Schema = require(\"../../database/models/stats\");\n\nmodule.exports = async (client, interaction, args) => {\n    const time = interaction.options.getString(\"timezone\");\n\n    if (!momentTimezone.tz.zone(time)) return client.errNormal({\n        error: `Timezone is not valid`,\n        type: 'editreply'\n    }, interaction)\n\n    const timeNow = moment().tz(time).format(\"HH:mm (z)\");\n\n    var channelName = await client.getTemplate(interaction.guild);\n    channelName = channelName.replace(`{emoji}`, \"⏰\")\n    channelName = channelName.replace(`{name}`, `${timeNow}`)\n\n    await interaction.guild.channels.create({\n        name: channelName,\n        type:  Discord.ChannelType.GuildVoice, permissionOverwrites: [\n            {\n                deny: [Discord.PermissionsBitField.Flags.Connect],\n                id: interaction.guild.id\n            },\n        ],\n    }).then(async (channel) => {\n        new Schema({\n            Guild: interaction.guild.id,\n            TimeZone: time,\n            Time: channel.id,\n        }).save();\n\n        client.succNormal({\n            text: `Voice channel count created!`,\n            fields: [\n                {\n                    name: `📘┆Channel`,\n                    value: `${channel}`\n                }\n            ],\n            type: 'editreply'\n        }, interaction);\n    })\n\n}\n\n ","size_bytes":1463},"src/commands/serverstats/voice-channels.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/stats\");\n\nmodule.exports = async (client, interaction, args) => {\n    var channelName = await client.getTemplate(interaction.guild);\n    channelName = channelName.replace(`{emoji}`, \"🔊\")\n    channelName = channelName.replace(`{name}`, `Voice Channels: ${interaction.guild.channels.cache.filter(channel => channel.type ===  Discord.ChannelType.GuildVoice).size || 0}`)\n\n    await interaction.guild.channels.create({\n        name: channelName,\n        type:  Discord.ChannelType.GuildVoice, permissionOverwrites: [\n            {\n                deny: [Discord.PermissionsBitField.Flags.Connect],\n                id: interaction.guild.id\n            },\n        ],\n    }).then(async (channel) => {\n        Schema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n            if (data) {\n                data.VoiceChannels = channel.id;\n                data.save();\n            }\n            else {\n                new Schema({\n                    Guild: interaction.guild.id,\n                    VoiceChannels: channel.id\n                }).save();\n            }\n        })\n\n        client.succNormal({\n            text: `Voice channel count created!`,\n            fields: [\n                {\n                    name: `📘┆Channel`,\n                    value: `${channel}`\n                }\n            ],\n            type: 'editreply'\n        }, interaction);\n    })\n\n}\n\n ","size_bytes":1476},"src/commands/setup/customvoice.js":{"content":"const Discord = require('discord.js');\n\nconst voiceSchema = require(\"../../database/models/voice\");\n\nmodule.exports = async (client, interaction, args) => {\n    const category = interaction.options.getChannel('category');\n    const ChannelName = interaction.options.getString('channelname');\n\n    interaction.guild.channels.create({\n        name: ChannelName,\n        type:  Discord.ChannelType.GuildVoice,\n        parent: category.id,\n        permissionOverwrites: [\n            {\n                deny: [Discord.PermissionsBitField.Flags.Speak],\n                id: interaction.guild.id\n            },\n        ],\n    }).then((ch) => {\n        voiceSchema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n            if (data) {\n                data.Category = category.id;\n                data.Channel = ch.id\n                data.ChannelName = ChannelName\n                data.save();\n            }\n            else {\n                new voiceSchema({\n                    Guild: interaction.guild.id,\n                    Channel: ch.id,\n                    ChannelName: ChannelName,\n                    Category: category.id\n                }).save();\n            }\n        });\n\n        client.succNormal({\n            text: `Custom voice has been set up successfully!`,\n            fields: [\n                {\n                    name: `📘┆Channel`,\n                    value: `${ch} (${ch.name})`\n                }\n            ],\n            type: 'editreply'\n        }, interaction);\n    })\n}\n\n ","size_bytes":1519},"src/commands/setup/deletesetup.js":{"content":"const Discord = require('discord.js');\n\nconst Counting = require(\"../../database/models/countChannel\");\nconst GTN = require(\"../../database/models/guessNumber\");\nconst GTW = require(\"../../database/models/guessWord\");\nconst WordSnake = require(\"../../database/models/wordsnake\");\nconst Birthdays = require(\"../../database/models/birthdaychannels\");\nconst Chatbot = require(\"../../database/models/chatbot-channel\");\nconst Review = require(\"../../database/models/reviewChannels\");\nconst Suggestion = require(\"../../database/models/suggestionChannels\");\nconst logs = require(\"../../database/models/logChannels\");\nconst boostLogs = require(\"../../database/models/boostChannels\");\nconst levelLogs = require(\"../../database/models/levelChannels\");\nconst voiceSchema = require(\"../../database/models/voice\");\nconst ticketSchema = require(\"../../database/models/tickets\");\nconst welcomeChannel = require(\"../../database/models/welcomeChannels\");\nconst leaveChannel = require(\"../../database/models/leaveChannels\");\nconst welcomeRole = require(\"../../database/models/joinRole\");\n\nmodule.exports = async (client, interaction, args) => {\n    const options = {\n        tickets: ticketSchema,\n        customvoice: voiceSchema,\n        serverlogs: logs,\n        levellogs: levelLogs,\n        boostlogs: boostLogs,\n        birthdays: Birthdays,\n        chatbot: Chatbot,\n        reviews: Review,\n        suggestions: Suggestion,\n        counting: Counting,\n        gtn: GTN,\n        gtw: GTW,\n        welcomechannel: welcomeChannel,\n        leavechannel: leaveChannel,\n        welcomerole: welcomeRole,\n        wordsnake: WordSnake\n    };\n\n    const choice = interaction.options.getString('setup');\n\n    options[choice].findOneAndDelete({ Guild: interaction.guild.id }).then(() => {\n        client.succNormal({ \n            text: `Setup successfully deleted!`,\n            type: 'editreply'\n        }, interaction);\n    })\n}\n\n ","size_bytes":1912},"src/commands/setup/fun.js":{"content":"const Discord = require('discord.js');\n\nconst Birthdays = require(\"../../database/models/birthdaychannels\");\nconst Chatbot = require(\"../../database/models/chatbot-channel\");\nconst Review = require(\"../../database/models/reviewChannels\");\nconst Suggestion = require(\"../../database/models/suggestionChannels\");\nconst StarBoard = require(\"../../database/models/starboardChannels\");\n\nmodule.exports = async (client, interaction, args) => {\n    const choice = interaction.options.getString('setup');\n    const channel = interaction.options.getChannel('channel');\n    \n    const choices = {\n        birthdays : Birthdays,\n        chatbot : Chatbot,\n        reviews : Review,\n        suggestions : Suggestion,\n        starboard : StarBoard\n    };\n\n    client.createChannelSetup(choices[choice], channel, interaction);\n}\n\n \n","size_bytes":818},"src/commands/setup/games.js":{"content":"const Discord = require('discord.js');\n\nconst Counting = require(\"../../database/models/countChannel\");\nconst GTN = require(\"../../database/models/guessNumber\");\nconst GTW = require(\"../../database/models/guessWord\");\nconst WordSnake = require(\"../../database/models/wordsnake\");\n\nmodule.exports = async (client, interaction, args) => {\n    const choice = interaction.options.getString('setup');\n    const channel = interaction.options.getChannel('channel');\n\n    if (choice == \"counting\") {\n        client.embed({\n            title: `🔢・Counting`,\n            desc: `This is the start of counting! The first number is **1**`\n        }, channel)\n\n        client.createChannelSetup(Counting, channel, interaction)\n    }\n\n    if (choice == \"gtn\") {\n        client.embed({\n            title: `🔢・Guess the number`,\n            desc: `Guess the number between **1** and **10.000**!`\n        }, channel)\n\n        client.createChannelSetup(GTN, channel, interaction)\n    }\n\n    if (choice == \"gtw\") {\n        var word = \"start\";\n        var shuffled = word.split('').sort(function () { return 0.5 - Math.random() }).join('');\n\n        client.embed({\n            title: `💬・Guess the word`,\n            desc: `Put the letters in the right position!`,\n            fields: [\n                {\n                    name: `🔀┆Word`,\n                    value: `${shuffled.toLowerCase()}`\n                }\n            ],\n        }, channel)\n\n        client.createChannelSetup(GTW, channel, interaction)\n    }\n\n    if (choice == \"wordsnake\") {\n        client.createChannelSetup(WordSnake, channel, interaction)\n    }\n}\n\n ","size_bytes":1624},"src/commands/setup/logs.js":{"content":"const Discord = require('discord.js');\n\nconst logs = require(\"../../database/models/logChannels\");\nconst boostLogs = require(\"../../database/models/boostChannels\");\nconst levelLogs = require(\"../../database/models/levelChannels\");\n\nmodule.exports = async (client, interaction, args) => {\n    const choice = interaction.options.getString('setup');\n    const channel = interaction.options.getChannel('channel');\n    \n    const choices = {\n        serverLogs : logs,\n        levelLogs : levelLogs,\n        boostLogs : boostLogs\n    };\n\n    client.createChannelSetup(choices[choice], channel, interaction);\n}\n\n \n","size_bytes":608},"src/commands/setup/ticketpanel.js":{"content":"const Discord = require('discord.js');\n\nconst ticketSchema = require(\"../../database/models/tickets\");\n\nmodule.exports = async (client, interaction, args) => {\n    const name = interaction.options.getString('name');\n    const description = interaction.options.getString('description');\n\n    ticketSchema.findOne({ Guild: interaction.guild.id }, async (err, ticketData) => {\n        if (ticketData) {\n            const channel = interaction.guild.channels.cache.get(ticketData.Channel);\n            const button = new Discord.ButtonBuilder()\n                .setCustomId('Bot_openticket')\n                .setLabel(name)\n                .setStyle(Discord.ButtonStyle.Primary)\n                .setEmoji('🎫')\n\n            const row = new Discord.ActionRowBuilder()\n                .addComponents(button)\n\n            client.embed({\n                title: name,\n                desc: description,\n                components: [row]\n            }, channel)\n\n            client.succNormal({\n                text: `Ticket panel has been set up successfully!`,\n                type: 'editreply'\n            }, interaction);\n        }\n        else {\n            client.errNormal({\n                error: `Run the ticket setup first!`,\n                type: 'editreply'\n            }, interaction);\n        }\n    })\n}\n\n ","size_bytes":1312},"src/commands/setup/tickets.js":{"content":"const Discord = require('discord.js');\n\nconst ticketSchema = require(\"../../database/models/tickets\");\n\nmodule.exports = async (client, interaction, args) => {\n    const category = interaction.options.getChannel('category');\n    const role = interaction.options.getRole('role');\n    const channel = interaction.options.getChannel('channel');\n    const logs = interaction.options.getChannel('logs');\n\n    ticketSchema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n        if (data) {\n            data.Category = category.id;\n            data.Role = role.id;\n            data.Channel = channel.id;\n            data.Logs = logs.id;\n            data.save();\n        }\n        else {\n            new ticketSchema({\n                Guild: interaction.guild.id,\n                Category: category.id,\n                Role: role.id,\n                Channel: channel.id,\n                Logs: logs.id\n            }).save();\n        }\n    })\n\n    client.succNormal({\n        text: `Tickets has been set up successfully!`,\n        type: 'editreply'\n    }, interaction);\n}\n\n ","size_bytes":1081},"src/commands/setup/welcomechannels.js":{"content":"const Discord = require('discord.js');\n\nconst welcomeChannel = require(\"../../database/models/welcomeChannels\");\nconst leaveChannel = require(\"../../database/models/leaveChannels\");\n\nmodule.exports = async (client, interaction, args) => {\n    const choice = interaction.options.getString('setup');\n    const channel = interaction.options.getChannel('channel');\n\n    const choices = {\n        welcomechannel : welcomeChannel,\n        leavechannel : leaveChannel\n    };\n\n    client.createChannelSetup(choices[choice], channel, interaction);\n}\n\n \n","size_bytes":544},"src/commands/setup/welcomerole.js":{"content":"const Discord = require('discord.js');\n\nconst welcomeRole = require(\"../../database/models/joinRole\");\n\nmodule.exports = async (client, interaction, args) => {\n    const role = interaction.options.getRole('role');\n\n    client.createRoleSetup(welcomeRole, role, interaction)\n}\n\n ","size_bytes":278},"src/commands/soundboard/dancememe.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    if (!interaction.member.voice.channel) return client.errNormal({ error: `You're not in a voice channel!`, type: 'editreply' }, interaction);\n\n    if (interaction.guild.members.me.voice.channel && interaction.member.voice.channel.id !== interaction.guild.members.me.voice.channel.id) return client.errNormal({ error: `You are not in the same voice channel!`, type: 'editreply' }, interaction);\n\n    client.soundboard(interaction.guild.id, interaction, \"https://www.myinstants.com/media/sounds/y2mate-mp3cut_sRzY6rh.mp3\");\n\n    client.succNormal({ text: \"Soundboard started! Playing **dance meme**\", type: 'editreply' }, interaction);\n};","size_bytes":697},"src/commands/soundboard/defaultdance.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    if (!interaction.member.voice.channel) return client.errNormal({ error: `You're not in a voice channel!`, type: 'editreply' }, interaction);\n\n    if (interaction.guild.members.me.voice.channel && interaction.member.voice.channel.id !== interaction.guild.members.me.voice.channel.id) return client.errNormal({ error: `You are not in the same voice channel!`, type: 'editreply' }, interaction);\n\n    client.soundboard(interaction.guild.id, interaction, \"https://www.myinstants.com/media/sounds/fortnite-default-dance-bass-boosted.mp3\");\n\n    client.succNormal({ text: \"Soundboard started! Playing **default dance**\", type: 'editreply' }, interaction);\n};","size_bytes":714},"src/commands/soundboard/despacito.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    if (!interaction.member.voice.channel) return client.errNormal({ error: `You're not in a voice channel!`, type: 'editreply' }, interaction);\n\n    if (interaction.guild.members.me.voice.channel && interaction.member.voice.channel.id !== interaction.guild.members.me.voice.channel.id) return client.errNormal({ error: `You are not in the same voice channel!`, type: 'editreply' }, interaction);\n\n    client.soundboard(interaction.guild.id, interaction, \"https://www.myinstants.com/media/sounds/despacito.mp3\");\n\n    client.succNormal({ text: \"Soundboard started! Playing **despacito**\", type: 'editreply' }, interaction);\n};","size_bytes":684},"src/commands/soundboard/discordcall.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    if (!interaction.member.voice.channel) return client.errNormal({ error: `You're not in a voice channel!`, type: 'editreply' }, interaction);\n\n    if (interaction.guild.members.me.voice.channel && interaction.member.voice.channel.id !== interaction.guild.members.me.voice.channel.id) return client.errNormal({ error: `You are not in the same voice channel!`, type: 'editreply' }, interaction);\n\n    client.soundboard(interaction.guild.id, interaction, \"https://www.myinstants.com/media/sounds/discord-call-sound.mp3\");\n\n    client.succNormal({ text: \"Soundboard started! Playing **discord call**\", type: 'editreply' }, interaction);\n};","size_bytes":696},"src/commands/soundboard/discordjoin.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    if (!interaction.member.voice.channel) return client.errNormal({ error: `You're not in a voice channel!`, type: 'editreply' }, interaction);\n\n    if (interaction.guild.members.me.voice.channel && interaction.member.voice.channel.id !== interaction.guild.members.me.voice.channel.id) return client.errNormal({ error: `You are not in the same voice channel!`, type: 'editreply' }, interaction);\n\n    client.soundboard(interaction.guild.id, interaction, \"https://www.myinstants.com/media/sounds/discord-sounds.mp3\");\n\n    client.succNormal({ text: \"Soundboard started! Playing **discord join**\", type: 'editreply' }, interaction);\n};","size_bytes":692},"src/commands/soundboard/discordleave.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    if (!interaction.member.voice.channel) return client.errNormal({ error: `You're not in a voice channel!`, type: 'editreply' }, interaction);\n\n    if (interaction.guild.members.me.voice.channel && interaction.member.voice.channel.id !== interaction.guild.members.me.voice.channel.id) return client.errNormal({ error: `You are not in the same voice channel!`, type: 'editreply' }, interaction);\n\n    client.soundboard(interaction.guild.id, interaction, \"https://www.myinstants.com/media/sounds/discord-leave_soGsPwn.mp3\");\n\n    client.succNormal({ text: \"Soundboard started! Playing **discord leave**\", type: 'editreply' }, interaction);\n};","size_bytes":700},"src/commands/soundboard/discordnotification.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    if (!interaction.member.voice.channel) return client.errNormal({ error: `You're not in a voice channel!`, type: 'editreply' }, interaction);\n\n    if (interaction.guild.members.me.voice.channel && interaction.member.voice.channel.id !== interaction.guild.members.me.voice.channel.id) return client.errNormal({ error: `You are not in the same voice channel!`, type: 'editreply' }, interaction);\n\n    client.soundboard(interaction.guild.id, interaction, \"https://www.myinstants.com/media/sounds/discord-notification.mp3\");\n\n    client.succNormal({ text: \"Soundboard started! Playing **discord notification**\", type: 'editreply' }, interaction);\n};","size_bytes":706},"src/commands/soundboard/elevator.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    if (!interaction.member.voice.channel) return client.errNormal({ error: `You're not in a voice channel!`, type: 'editreply' }, interaction);\n\n    if (interaction.guild.members.me.voice.channel && interaction.member.voice.channel.id !== interaction.guild.members.me.voice.channel.id) return client.errNormal({ error: `You are not in the same voice channel!`, type: 'editreply' }, interaction);\n\n    client.soundboard(interaction.guild.id, interaction, \"https://www.myinstants.com/media/sounds/musique-dascenseur-mp3cut.mp3\");\n\n    client.succNormal({ text: \"Soundboard started! Playing **elevator**\", type: 'editreply' }, interaction);\n};","size_bytes":699},"src/commands/soundboard/fbi.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    if (!interaction.member.voice.channel) return client.errNormal({ error: `You're not in a voice channel!`, type: 'editreply' }, interaction);\n\n    if (interaction.guild.members.me.voice.channel && interaction.member.voice.channel.id !== interaction.guild.members.me.voice.channel.id) return client.errNormal({ error: `You are not in the same voice channel!`, type: 'editreply' }, interaction);\n\n    client.soundboard(interaction.guild.id, interaction, \"https://www.myinstants.com/media/sounds/fbi-open-up-sfx.mp3\");\n\n    client.succNormal({ text: \"Soundboard started! Playing **fbi**\", type: 'editreply' }, interaction);\n};","size_bytes":684},"src/commands/soundboard/jeff.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    if (!interaction.member.voice.channel) return client.errNormal({ error: `You're not in a voice channel!`, type: 'editreply' }, interaction);\n\n    if (interaction.guild.members.me.voice.channel && interaction.member.voice.channel.id !== interaction.guild.members.me.voice.channel.id) return client.errNormal({ error: `You are not in the same voice channel!`, type: 'editreply' }, interaction);\n\n    client.soundboard(interaction.guild.id, interaction, \"https://www.myinstants.com/media/sounds/jeff.mp3\");\n\n    client.succNormal({ text: \"Soundboard started! Playing **jeff**\", type: 'editreply' }, interaction);\n};","size_bytes":674},"src/commands/soundboard/lambo.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    if (!interaction.member.voice.channel) return client.errNormal({ error: `You're not in a voice channel!`, type: 'editreply' }, interaction);\n\n    if (interaction.guild.members.me.voice.channel && interaction.member.voice.channel.id !== interaction.guild.members.me.voice.channel.id) return client.errNormal({ error: `You are not in the same voice channel!`, type: 'editreply' }, interaction);\n\n    client.soundboard(interaction.guild.id, interaction, \"https://www.myinstants.com/media/sounds/lambo.mp3\");\n\n    client.succNormal({ text: \"Soundboard started! Playing **lambo**\", type: 'editreply' }, interaction);\n};","size_bytes":676},"src/commands/soundboard/missionfailed.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    if (!interaction.member.voice.channel) return client.errNormal({ error: `You're not in a voice channel!`, type: 'editreply' }, interaction);\n\n    if (interaction.guild.members.me.voice.channel && interaction.member.voice.channel.id !== interaction.guild.members.me.voice.channel.id) return client.errNormal({ error: `You are not in the same voice channel!`, type: 'editreply' }, interaction);\n\n    client.soundboard(interaction.guild.id, interaction, \"https://www.myinstants.com/media/sounds/dank-meme-compilation-volume-17_cutted.mp3\");\n\n    client.succNormal({ text: \"Soundboard started! Playing **mission failed**\", type: 'editreply' }, interaction);\n};","size_bytes":718},"src/commands/soundboard/moaning.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    if (!interaction.member.voice.channel) return client.errNormal({ error: `You're not in a voice channel!`, type: 'editreply' }, interaction);\n\n    if (interaction.guild.members.me.voice.channel && interaction.member.voice.channel.id !== interaction.guild.members.me.voice.channel.id) return client.errNormal({ error: `You are not in the same voice channel!`, type: 'editreply' }, interaction);\n\n    client.soundboard(interaction.guild.id, interaction, \"https://www.myinstants.com/media/sounds/moaning.mp3\");\n\n    client.succNormal({ text: \"Soundboard started! Playing **moaning**\", type: 'editreply' }, interaction);\n};","size_bytes":680},"src/commands/soundboard/nani.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    if (!interaction.member.voice.channel) return client.errNormal({ error: `You're not in a voice channel!`, type: 'editreply' }, interaction);\n\n    if (interaction.guild.members.me.voice.channel && interaction.member.voice.channel.id !== interaction.guild.members.me.voice.channel.id) return client.errNormal({ error: `You are not in the same voice channel!`, type: 'editreply' }, interaction);\n\n    client.soundboard(interaction.guild.id, interaction, \"https://www.myinstants.com/media/sounds/nani.mp3\");\n\n    client.succNormal({ text: \"Soundboard started! Playing **nani**\", type: 'editreply' }, interaction);\n};","size_bytes":674},"src/commands/soundboard/nyancat.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    if (!interaction.member.voice.channel) return client.errNormal({ error: `You're not in a voice channel!`, type: 'editreply' }, interaction);\n\n    if (interaction.guild.members.me.voice.channel && interaction.member.voice.channel.id !== interaction.guild.members.me.voice.channel.id) return client.errNormal({ error: `You are not in the same voice channel!`, type: 'editreply' }, interaction);\n\n    client.soundboard(interaction.guild.id, interaction, \"https://www.myinstants.com/media/sounds/nyan-cat.mp3\");\n\n    client.succNormal({ text: \"Soundboard started! Playing **nyancat**\", type: 'editreply' }, interaction);\n};","size_bytes":681},"src/commands/soundboard/ohh.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    if (!interaction.member.voice.channel) return client.errNormal({ error: `You're not in a voice channel!`, type: 'editreply' }, interaction);\n\n    if (interaction.guild.members.me.voice.channel && interaction.member.voice.channel.id !== interaction.guild.members.me.voice.channel.id) return client.errNormal({ error: `You are not in the same voice channel!`, type: 'editreply' }, interaction);\n\n    client.soundboard(interaction.guild.id, interaction, \"https://www.myinstants.com/media/sounds/ohh.mp3\");\n\n    client.succNormal({ text: \"Soundboard started! Playing **ohh**\", type: 'editreply' }, interaction);\n};","size_bytes":672},"src/commands/soundboard/reee.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    if (!interaction.member.voice.channel) return client.errNormal({ error: `You're not in a voice channel!`, type: 'editreply' }, interaction);\n\n    if (interaction.guild.members.me.voice.channel && interaction.member.voice.channel.id !== interaction.guild.members.me.voice.channel.id) return client.errNormal({ error: `You are not in the same voice channel!`, type: 'editreply' }, interaction);\n\n    client.soundboard(interaction.guild.id, interaction, \"https://www.myinstants.com/media/sounds/reee.mp3\");\n\n    client.succNormal({ text: \"Soundboard started! Playing **reee**\", type: 'editreply' }, interaction);\n};","size_bytes":674},"src/commands/soundboard/rickastley.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    if (!interaction.member.voice.channel) return client.errNormal({ error: `You're not in a voice channel!`, type: 'editreply' }, interaction);\n\n    if (interaction.guild.members.me.voice.channel && interaction.member.voice.channel.id !== interaction.guild.members.me.voice.channel.id) return client.errNormal({ error: `You are not in the same voice channel!`, type: 'editreply' }, interaction);\n\n    client.soundboard(interaction.guild.id, interaction, \"https://www.myinstants.com/media/sounds/epic.swf_1.mp3\");\n\n    client.succNormal({ text: \"Soundboard started! Playing **rick astley**\", type: 'editreply' }, interaction);\n};","size_bytes":687},"src/commands/soundboard/rimshot.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    if (!interaction.member.voice.channel) return client.errNormal({ error: `You're not in a voice channel!`, type: 'editreply' }, interaction);\n\n    if (interaction.guild.members.me.voice.channel && interaction.member.voice.channel.id !== interaction.guild.members.me.voice.channel.id) return client.errNormal({ error: `You are not in the same voice channel!`, type: 'editreply' }, interaction);\n\n    client.soundboard(interaction.guild.id, interaction, \"https://www.myinstants.com/media/sounds/rimshot.mp3\");\n\n    client.succNormal({ text: \"Soundboard started! Playing **rimshot**\", type: 'editreply' }, interaction);\n};","size_bytes":680},"src/commands/soundboard/roblox.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    if (!interaction.member.voice.channel) return client.errNormal({ error: `You're not in a voice channel!`, type: 'editreply' }, interaction);\n\n    if (interaction.guild.members.me.voice.channel && interaction.member.voice.channel.id !== interaction.guild.members.me.voice.channel.id) return client.errNormal({ error: `You are not in the same voice channel!`, type: 'editreply' }, interaction);\n\n    client.soundboard(interaction.guild.id, interaction, \"https://www.myinstants.com/media/sounds/roblox-death-sound-effect.mp3\");\n\n    client.succNormal({ text: \"Soundboard started! Playing **roblox**\", type: 'editreply' }, interaction);\n};","size_bytes":697},"src/commands/soundboard/running.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    if (!interaction.member.voice.channel) return client.errNormal({ error: `You're not in a voice channel!`, type: 'editreply' }, interaction);\n\n    if (interaction.guild.members.me.voice.channel && interaction.member.voice.channel.id !== interaction.guild.members.me.voice.channel.id) return client.errNormal({ error: `You are not in the same voice channel!`, type: 'editreply' }, interaction);\n\n    client.soundboard(interaction.guild.id, interaction, \"https://www.myinstants.com/media/sounds/running.mp3\");\n\n    client.succNormal({ text: \"Soundboard started! Playing **running**\", type: 'editreply' }, interaction);\n};","size_bytes":680},"src/commands/soundboard/shotdown.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    if (!interaction.member.voice.channel) return client.errNormal({ error: `You're not in a voice channel!`, type: 'editreply' }, interaction);\n\n    if (interaction.guild.members.me.voice.channel && interaction.member.voice.channel.id !== interaction.guild.members.me.voice.channel.id) return client.errNormal({ error: `You are not in the same voice channel!`, type: 'editreply' }, interaction);\n\n    client.soundboard(interaction.guild.id, interaction, \"https://www.myinstants.com/media/sounds/shotdown.mp3\");\n\n    client.succNormal({ text: \"Soundboard started! Playing **shotdown**\", type: 'editreply' }, interaction);\n};","size_bytes":682},"src/commands/soundboard/spongebob.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    if (!interaction.member.voice.channel) return client.errNormal({ error: `You're not in a voice channel!`, type: 'editreply' }, interaction);\n\n    if (interaction.guild.members.me.voice.channel && interaction.member.voice.channel.id !== interaction.guild.members.me.voice.channel.id) return client.errNormal({ error: `You are not in the same voice channel!`, type: 'editreply' }, interaction);\n\n    client.soundboard(interaction.guild.id, interaction, \"https://www.myinstants.com/media/sounds/a-few-moments-later-hd.mp3\");\n\n    client.succNormal({ text: \"Soundboard started! Playing **spongebob**\", type: 'editreply' }, interaction);\n};","size_bytes":697},"src/commands/soundboard/startup.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    if (!interaction.member.voice.channel) return client.errNormal({ error: `You're not in a voice channel!`, type: 'editreply' }, interaction);\n\n    if (interaction.guild.members.me.voice.channel && interaction.member.voice.channel.id !== interaction.guild.members.me.voice.channel.id) return client.errNormal({ error: `You are not in the same voice channel!`, type: 'editreply' }, interaction);\n\n    client.soundboard(interaction.guild.id, interaction, \"https://www.myinstants.com/media/sounds/startup.mp3\");\n\n    client.succNormal({ text: \"Soundboard started! Playing **start up**\", type: 'editreply' }, interaction);\n};","size_bytes":681},"src/commands/soundboard/thomas.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    if (!interaction.member.voice.channel) return client.errNormal({ error: `You're not in a voice channel!`, type: 'editreply' }, interaction);\n\n    if (interaction.guild.members.me.voice.channel && interaction.member.voice.channel.id !== interaction.guild.members.me.voice.channel.id) return client.errNormal({ error: `You are not in the same voice channel!`, type: 'editreply' }, interaction);\n\n    client.soundboard(interaction.guild.id, interaction, \"https://www.myinstants.com/media/sounds/thomas.mp3\");\n\n    client.succNormal({ text: \"Soundboard started! Playing **thomas**\", type: 'editreply' }, interaction);\n};","size_bytes":678},"src/commands/soundboard/tobecontinued.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    if (!interaction.member.voice.channel) return client.errNormal({ error: `You're not in a voice channel!`, type: 'editreply' }, interaction);\n\n    if (interaction.guild.members.me.voice.channel && interaction.member.voice.channel.id !== interaction.guild.members.me.voice.channel.id) return client.errNormal({ error: `You are not in the same voice channel!`, type: 'editreply' }, interaction);\n\n    client.soundboard(interaction.guild.id, interaction, \"https://www.myinstants.com/media/sounds/untitled_1071.mp3\");\n\n    client.succNormal({ text: \"Soundboard started! Playing **to be continued**\", type: 'editreply' }, interaction);\n};","size_bytes":694},"src/commands/soundboard/wegothim.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    if (!interaction.member.voice.channel) return client.errNormal({ error: `You're not in a voice channel!`, type: 'editreply' }, interaction);\n\n    if (interaction.guild.members.me.voice.channel && interaction.member.voice.channel.id !== interaction.guild.members.me.voice.channel.id) return client.errNormal({ error: `You are not in the same voice channel!`, type: 'editreply' }, interaction);\n\n    client.soundboard(interaction.guild.id, interaction, \"https://www.myinstants.com/media/sounds/ladies-and-gentlemen-we-got-him-song.mp3\");\n\n    client.succNormal({ text: \"Soundboard started! Playing **we got him**\", type: 'editreply' }, interaction);\n};","size_bytes":712},"src/commands/soundboard/windowserror.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    if (!interaction.member.voice.channel) return client.errNormal({ error: `You're not in a voice channel!`, type: 'editreply' }, interaction);\n\n    if (interaction.guild.members.me.voice.channel && interaction.member.voice.channel.id !== interaction.guild.members.me.voice.channel.id) return client.errNormal({ error: `You are not in the same voice channel!`, type: 'editreply' }, interaction);\n\n    client.soundboard(interaction.guild.id, interaction, \"https://www.myinstants.com/media/sounds/erro.mp3\");\n\n    client.succNormal({ text: \"Soundboard started! Playing **windows error**\", type: 'editreply' }, interaction);\n};","size_bytes":683},"src/commands/soundboard/windowsshutdown.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    if (!interaction.member.voice.channel) return client.errNormal({ error: `You're not in a voice channel!`, type: 'editreply' }, interaction);\n\n    if (interaction.guild.members.me.voice.channel && interaction.member.voice.channel.id !== interaction.guild.members.me.voice.channel.id) return client.errNormal({ error: `You are not in the same voice channel!`, type: 'editreply' }, interaction);\n\n    client.soundboard(interaction.guild.id, interaction, \"https://www.myinstants.com/media/sounds/preview_4.mp3\");\n\n    client.succNormal({ text: \"Soundboard started! Playing **windows shutdown**\", type: 'editreply' }, interaction);\n};","size_bytes":691},"src/commands/soundboard/windowsstartup.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    if (!interaction.member.voice.channel) return client.errNormal({ error: `You're not in a voice channel!`, type: 'editreply' }, interaction);\n\n    if (interaction.guild.members.me.voice.channel && interaction.member.voice.channel.id !== interaction.guild.members.me.voice.channel.id) return client.errNormal({ error: `You are not in the same voice channel!`, type: 'editreply' }, interaction);\n\n    client.soundboard(interaction.guild.id, interaction, \"https://www.myinstants.com/media/sounds/windows-xp-startup.mp3\");\n\n    client.succNormal({ text: \"Soundboard started! Playing **windows startup**\", type: 'editreply' }, interaction);\n};","size_bytes":699},"src/commands/soundboard/wow.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    if (!interaction.member.voice.channel) return client.errNormal({ error: `You're not in a voice channel!`, type: 'editreply' }, interaction);\n\n    if (interaction.guild.members.me.voice.channel && interaction.member.voice.channel.id !== interaction.guild.members.me.voice.channel.id) return client.errNormal({ error: `You are not in the same voice channel!`, type: 'editreply' }, interaction);\n\n    client.soundboard(interaction.guild.id, interaction, \"https://www.myinstants.com/media/sounds/anime-wow-sound-effect.mp3\");\n\n    client.succNormal({ text: \"Soundboard started! Playing **wow**\", type: 'editreply' }, interaction);\n};","size_bytes":691},"src/commands/soundboard/yeet.js":{"content":"\nmodule.exports = async (client, interaction, args) => {\n\n    if (!interaction.member.voice.channel) return client.errNormal({ error: `You're not in a voice channel!`, type: 'editreply' }, interaction);\n\n    if (interaction.guild.members.me.voice.channel && interaction.member.voice.channel.id !== interaction.guild.members.me.voice.channel.id) return client.errNormal({ error: `You are not in the same voice channel!`, type: 'editreply' }, interaction);\n\n    client.soundboard(interaction.guild.id, interaction, \"https://www.myinstants.com/media/sounds/yeet.mp3\");\n\n    client.succNormal({ text: \"Soundboard started! Playing **yeet**\", type: 'editreply' }, interaction);\n};","size_bytes":674},"src/commands/stickymessages/messages.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/stickymessages\");\n\nmodule.exports = async (client, interaction, args) => {\n    const data = await Schema.find({ Guild: interaction.guild.id });\n\n    if (data) {\n        let list = ``;\n\n        for (var i = 0; i < data.length; i++) {\n            list += `**${i + 1}** - Channel: ${data[i].Channel}`;\n        }\n\n        await client.embed({ \n            title: `💬・Sticky messages`, \n            desc: list, \n            type: 'editreply' \n        }, interaction)\n    }\n    else {\n        client.errNormal({ \n            error: \"No data found!\",\n            type: 'editreply' \n        }, interaction)\n    }\n}\n\n ","size_bytes":699},"src/commands/stickymessages/stick.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/stickymessages\");\n\nmodule.exports = async (client, interaction, args) => {\n    const channel = interaction.options.getChannel('channel');\n    const content = interaction.options.getString('message');\n\n    const embed = new Discord.EmbedBuilder()\n        .setDescription(`${content}`)\n        .setColor(client.config.colors.normal);\n    channel.send({ embeds: [embed] }).then(msg => {\n        Schema.findOne({ Guild: interaction.guild.id, Channel: channel.id }, async (err, data) => {\n            if (data) {\n                data.Channel = channel.id;\n                data.Content = content;\n                data.LastMessage = msg.id;\n                data.save();\n            }\n            else {\n                new Schema({\n                    Guild: interaction.guild.id,\n                    Channel: channel.id,\n                    LastMessage: msg.id,\n                    Content: content,\n                }).save();\n            }\n        })\n\n        client.succNormal({\n            text: \"Sticky message created\",\n            fields: [\n                {\n                    name: `💬┆Message`,\n                    value: `${content}`\n                }\n            ],\n            type: 'editreply'\n        }, interaction)\n    })\n}\n\n ","size_bytes":1327},"src/commands/stickymessages/unstick.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/stickymessages\");\n\nmodule.exports = async (client, interaction, args) => {\n    const channel = interaction.options.getChannel('channel');\n\n    Schema.findOne({ Guild: interaction.guild.id, Channel: channel.id }, async (err, data) => {\n        if (data) {\n            Schema.findOneAndDelete({ Guild: interaction.guild.id, Channel: channel.id }).then(() => {\n                client.succNormal({\n                    text: \"Sticky message deleted\",\n                    fields: [\n                        {\n                            name: `📘┆Channel`,\n                            value: `${channel}`\n                        }\n                    ],\n                    type: 'editreply'\n                }, interaction);\n            })\n        }\n        else {\n            client.errNormal({\n                error: 'No message found!',\n                type: 'editreply'\n            }, interaction)\n        }\n    })\n}\n\n ","size_bytes":1006},"src/commands/suggestions/accept.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/suggestionChannels\");\n\nmodule.exports = async (client, interaction, args) => {\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n        perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n    }, interaction)\n\n    if (perms == false) return;\n\n    const messageID = interaction.options.getString('id');\n\n    const data = await Schema.findOne({ Guild: interaction.guild.id });\n    if (data) {\n        const suggestionchannel = interaction.guild.channels.cache.get(data.Channel);\n        const suggestEmbed = await suggestionchannel.messages.fetch(messageID);\n        const embedData = suggestEmbed.embeds[0];\n\n        client.embed({\n            title: `${client.emotes.normal.check}・Suggestion accepted`,\n            desc: `\\`\\`\\`${embedData.description}\\`\\`\\``,\n            color: client.config.colors.succes,\n            author: {\n                name: embedData.author.name,\n                iconURL: embedData.author.iconURL\n            },\n            type: 'edit'\n        }, suggestEmbed)\n\n        try {\n            const user = await client.users.cache.find((u) => u.tag === embedData.author.name);\n\n            if (user) {\n                client.embed({\n                    title: `${client.emotes.normal.check}・Suggestion accepted`,\n                    desc: `Your suggestion in ${interaction.guild.name} has been accepted by a moderator!`,\n                    fields: [\n                        {\n                            name: `💬┆Suggestion`,\n                            value: `${embedData.description}`\n                        }\n                    ],\n                }, user).catch({})\n            }\n        }\n        catch { }\n\n        client.succNormal({\n            text: \"Suggestion successfully accepted\",\n            fields: [\n                {\n                    name: `💬┆Suggestion`,\n                    value: `${embedData.description}`\n                }\n            ],\n            type: 'editreply'\n        }, interaction);\n    }\n    else {\n        client.errNormal({\n            error: `No suggestion channel set! Please do the setup`,\n            type: 'editreply'\n        }, interaction);\n    }\n}\n\n ","size_bytes":2296},"src/commands/suggestions/deny.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/suggestionChannels\");\n\nmodule.exports = async (client, interaction, args) => {\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n        perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n    }, interaction)\n\n    if (perms == false) return;\n\n    const messageID = interaction.options.getString('id');\n\n    const data = await Schema.findOne({ Guild: interaction.guild.id });\n    if (data) {\n        const suggestionchannel = interaction.guild.channels.cache.get(data.Channel);\n        const suggestEmbed = await suggestionchannel.messages.fetch(messageID);\n        const embedData = suggestEmbed.embeds[0];\n\n        client.embed({\n            title: `${client.emotes.normal.error}・Suggestion denied`,\n            desc: `\\`\\`\\`${embedData.description}\\`\\`\\``,\n            color: client.config.colors.error,\n            author: {\n                name: embedData.author.name,\n                iconURL: embedData.author.iconURL\n            },\n            type: 'edit'\n        }, suggestEmbed)\n\n        try {\n            const user = await client.users.cache.find((u) => u.tag === embedData.author.name);\n\n            if (user) {\n                client.embed({\n                    title: `${client.emotes.normal.check}・Suggestion denied`,\n                    desc: `Your suggestion in ${interaction.guild.name} has been denied by a moderator!`,\n                    fields: [\n                        {\n                            name: `💬┆Suggestion`,\n                            value: `${embedData.description}`\n                        }\n                    ],\n                }, user).catch({})\n            }\n        }\n        catch { }\n\n        client.succNormal({\n            text: \"Suggestion successfully denied\",\n            fields: [\n                {\n                    name: `💬┆Suggestion`,\n                    value: `${embedData.description}`\n                }\n            ],\n            type: 'editreply'\n        }, interaction);\n    }\n    else {\n        client.errNormal({\n            error: `No suggestion channel set! Please do the setup`,\n            type: 'editreply'\n        }, interaction);\n    }\n}\n\n ","size_bytes":2287},"src/commands/suggestions/send.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/suggestionChannels\");\n\nmodule.exports = async (client, interaction, args) => {\n    const suggestionQuery = interaction.options.getString('suggestion');\n\n    const data = await Schema.findOne({ Guild: interaction.guild.id });\n    if (data) {\n        const channel = interaction.guild.channels.cache.get(data.Channel);\n\n        client.embed({\n            title: `💡・Suggestion`,\n            desc: `${suggestionQuery}`,\n            author: {\n                name: interaction.user.tag,\n                iconURL: interaction.user.displayAvatarURL({ dynamic: true, size: 1024 })\n            }\n        }, channel).then((msg) => {\n            client.succNormal({\n                text: `Suggestion successfully submitted!`,\n                fields: [\n                    {\n                        name: `💬┇Suggestion`,\n                        value: `${suggestionQuery}`,\n                        inline: true\n                    },\n                    {\n                        name: `📘┇Channel`,\n                        value: `<#${data.Channel}>`,\n                        inline: true\n                    }\n                ],\n                type: 'editreply'\n            }, interaction);\n\n            msg.react(client.emotes.normal.arrowUp);\n            msg.react(client.emotes.normal.arrowDown);\n        }).catch((e) => {\n            return client.errNormal({\n                error: `No suggestion channel set! Please do the setup`,\n                type: 'editreply'\n            }, interaction)\n        })\n    }\n    else {\n        client.errNormal({\n            error: `No suggestion channel set! Please do the setup`,\n            type: 'editreply'\n        }, interaction);\n    }\n}\n\n ","size_bytes":1778},"src/commands/thanks/check.js":{"content":"const Discord = require('discord.js');\nconst thanksSchema = require(\"../../database/models/thanks\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    const member = interaction.options.getUser('user');\n\n    thanksSchema.findOne({ User: member.id }, async (err, data) => {\n        if (data) {\n\n            return client.embed({ title: `🤝・Thanks`, desc: `**${member.tag}** has \\`${data.Received}\\` thanks`, type: 'editreply' }, interaction);\n\n        }\n        else {\n\n            return client.embed({ title: `🤝・Thanks`, desc: `**${member.tag}** has \\`0\\` thanks`, type: 'editreply' }, interaction);\n        }\n    });\n\n}\n\n ","size_bytes":645},"src/commands/thanks/thanks.js":{"content":"const Discord = require('discord.js');\n\nconst thanksSchema = require(\"../../database/models/thanks\");\nconst thanksAuthor = require(\"../../database/models/thanksAuthor\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    const target = interaction.options.getUser('user');\n    if (!target) return client.errUsage({ usage: \"thanks [mention user]\", type: 'editreply' }, interaction);\n\n    if (target.id === interaction.user.id) return client.errNormal({ error: `You cannot thank yourself!`, type: 'editreply' }, interaction);\n\n    thanksAuthor.findOne({ User: target.id, Author: interaction.user.id }, async (err, data) => {\n        if (data) {\n            client.errNormal({ error: `You already thanked this user!`, type: 'editreply' }, interaction);\n        }\n        else {\n            thanksSchema.findOne({ User: target.id }, async (err, data) => {\n                if (data) {\n                    data.Received += 1;\n                    data.save();\n                    client.succNormal({ text: `You have thanked <@${target.id}>! They now have \\`${data.Received}\\` thanks`, type: 'editreply' }, interaction);\n                }\n                else {\n                    new thanksSchema({\n                        User: target.id,\n                        UserTag: target.tag,\n                        Received: 1,\n                    }).save();\n                    client.succNormal({ text: `You have thanked <@${target.id}>! They now have \\`1\\` thanks`, type: 'editreply' }, interaction);\n                }\n            })\n\n            new thanksAuthor({\n                User: target.id,\n                Author: interaction.user.id,\n            }).save();\n        }\n    })\n}\n\n ","size_bytes":1690},"src/commands/tickets/add.js":{"content":"const Discord = require('discord.js');\n\nconst ticketSchema = require(\"../../database/models/tickets\");\n\nmodule.exports = async (client, interaction, args) => {\n    const data = await ticketSchema.findOne({ Guild: interaction.guild.id });\n\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n        perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n    }, interaction)\n\n    if (perms == false) return;\n\n    if (data) {\n        const ticketCategory = interaction.guild.channels.cache.get(data.Category);\n        if (ticketCategory == undefined) {\n            return client.errNormal({\n                error: \"Do the ticket setup!\",\n                type: 'editreply'\n            }, interaction)\n        }\n\n        if (interaction.channel.parentId == ticketCategory.id) {\n            let user = interaction.options.getUser('user');\n            interaction.channel.permissionOverwrites.edit(user.id, { ViewChannel: true, SendMessages: true });\n\n            return client.simpleEmbed({\n                desc: `Added ${user}`,\n                type: 'editreply'\n            }, interaction)\n        }\n        else {\n            client.errNormal({\n                error: \"This is not a ticket!\",\n                type: 'editreply'\n            }, interaction)\n        }\n    }\n}\n\n ","size_bytes":1339},"src/commands/tickets/claim.js":{"content":"const Discord = require('discord.js');\n\nconst ticketSchema = require(\"../../database/models/tickets\");\nconst ticketChannels = require(\"../../database/models/ticketChannels\");\n\nmodule.exports = async (client, interaction, args) => {\n    const data = await ticketSchema.findOne({ Guild: interaction.guild.id });\n    const ticketData = await ticketChannels.findOne({ Guild: interaction.guild.id, channelID: interaction.channel.id })\n\n    let type = 'reply';\n    if (interaction.isCommand()) type = 'editreply';\n    \n    if (ticketData) {\n        if (interaction.user.id !== ticketData.creator) {\n            const perms = await client.checkUserPerms({\n                flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n                perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n            }, interaction)\n\n            if (perms == false) return;\n\n            if (data) {\n                if (ticketData.claimed == \"\" || ticketData.claimed == undefined || ticketData.claimed == \"None\") {\n                    const ticketCategory = interaction.guild.channels.cache.get(data.Category);\n\n                    if (ticketCategory == undefined) {\n                        return client.errNormal({\n                            error: \"Do the ticket setup!\",\n                            type: type\n                        }, interaction)\n                    }\n\n                    if (interaction.channel.parentId == ticketCategory.id) {\n\n                        ticketData.claimed = interaction.user.id;\n                        ticketData.save();\n\n                        return client.simpleEmbed({\n                            desc: `You will now be assisted by <@!${interaction.user.id}>`,\n                            type: type\n                        }, interaction)\n\n                    }\n                    else {\n                        client.errNormal({\n                            error: \"This is not a ticket!\",\n                            type: type\n                        }, interaction)\n                    }\n                }\n                else {\n                    client.errNormal({\n                        error: \"Ticket has already been claimed!\",\n                        type: 'ephemeral'\n                    }, interaction)\n                }\n            }\n            else {\n                return client.errNormal({\n                    error: \"Do the ticket setup!\",\n                    type: type\n                }, interaction)\n            }\n        }\n        else {\n            return client.errNormal({\n                error: \"You are not allowed to claim your own ticket!\",\n                type: 'ephemeral'\n            }, interaction)\n        }\n    }\n}\n\n ","size_bytes":2698},"src/commands/tickets/close.js":{"content":"const Discord = require('discord.js');\n\nconst ticketSchema = require(\"../../database/models/tickets\");\nconst ticketChannels = require(\"../../database/models/ticketChannels\");\nconst ticketMessageConfig = require(\"../../database/models/ticketMessage\");\n\nmodule.exports = async (client, interaction, args) => {\n    const data = await ticketSchema.findOne({ Guild: interaction.guild.id });\n    const ticketData = await ticketChannels.findOne({ Guild: interaction.guild.id, channelID: interaction.channel.id });\n\n    let type = 'reply';\n    if (interaction.isCommand()) type = 'editreply';\n\n    if (ticketData) {\n        if (ticketData.resolved == true) return client.errNormal({\n            error: \"Ticket is already closed!\",\n            type: 'ephemeraledit'\n        }, interaction);\n\n        if (data) {\n            const ticketCategory = interaction.guild.channels.cache.get(data.Category);\n            const logsChannel = interaction.guild.channels.cache.get(data.Logs);\n\n            if (ticketCategory == undefined) {\n                return client.errNormal({\n                    error: \"Do the setup!\",\n                    type: type\n                }, interaction);\n            }\n\n            if (interaction.guild.channels.cache.find(c => c.id === ticketCategory.id)) {\n                client.users.fetch(ticketData.creator).then(async usr => {\n                    interaction.channel.permissionOverwrites.edit(usr, {\n                        ViewChannel: false,\n                        SendMessages: false,\n                        AttachFiles: false,\n                        ReadMessageHistory: false,\n                        AddReactions: false\n                    });\n\n                    try {\n                        var closeMessageTicket = \"Here is the transcript for your ticket, please keep this if you ever want to refer to it!\";\n                        let ticketMessageData = await ticketMessageConfig.findOne({ Guild: interaction.guild.id });\n                        if (ticketMessageData) {\n                            closeMessageTicket = ticketMessageData.dmMessage;\n                        }\n\n                        client.embed({\n                            desc: closeMessageTicket,\n                            fields: [\n                                {\n                                    name: \"👤┆Closer\",\n                                    value: `${interaction.user}`,\n                                    inline: true\n                                },\n                                {\n                                    name: \"📄┆Ticket id\",\n                                    value: `${ticketData.TicketID}`,\n                                    inline: true\n                                },\n                                {\n                                    name: \"💬┆Server\",\n                                    value: `${interaction.guild.name}`,\n                                    inline: true\n                                }\n                            ]\n                        }, usr)\n                        client.transcript(interaction, usr).catch(() => { });\n                    }\n                    catch (err) { }\n                })\n\n                if (logsChannel) {\n                    client.embed({\n                        title: `🔒・Ticket closed`,\n                        desc: `Ticket is closed`,\n                        color: client.config.colors.error,\n                        fields: [\n                            {\n                                name: \"📘┆Ticket id\",\n                                value: `${ticketData.TicketID}`,\n                            },\n                            {\n                                name: \"👤┆Closer\",\n                                value: `${interaction.user.tag} (${interaction.user.id})`,\n                            },\n                            {\n                                name: \"👤┆Creator\",\n                                value: `<@!${ticketData.creator}>`,\n                            },\n                            {\n                                name: \"✋┆Claimed by\",\n                                value: `<@!${ticketData.creator}>`,\n                            },\n                            {\n                                name: \"⏰┆Date\",\n                                value: `<t:${(Date.now() / 1000).toFixed(0)}:F>`,\n                            }\n                        ]\n                    }, logsChannel)\n                    client.transcript(interaction, logsChannel);\n                }\n\n                ticketData.resolved = true;\n                ticketData.save();\n\n                interaction.channel.edit({ name: `ticket-closed` });\n                client.simpleEmbed({\n                    desc: `Ticket closed by <@!${interaction.user.id}>`,\n                    type: type\n                }, interaction)\n\n                const row = new Discord.ActionRowBuilder()\n                    .addComponents(\n                        new Discord.ButtonBuilder()\n                            .setCustomId('Bot_transcriptTicket')\n                            .setEmoji('📝')\n                            .setStyle(Discord.ButtonStyle.Primary),\n\n                        new Discord.ButtonBuilder()\n                            .setCustomId('Bot_openTicket')\n                            .setEmoji('🔓')\n                            .setStyle(Discord.ButtonStyle.Primary),\n\n                        new Discord.ButtonBuilder()\n                            .setCustomId('Bot_deleteTicket')\n                            .setEmoji('⛔')\n                            .setStyle(Discord.ButtonStyle.Danger),\n                    );\n\n                client.embed({\n                    title: \"🔒・Closed\",\n                    desc: `📝 - Save transcript \\n🔓 - Reopen ticket \\n⛔ - Delete ticket`,\n                    components: [row],\n                }, interaction.channel)\n            }\n            else {\n                return client.errNormal({\n                    error: \"Do the ticket setup!\",\n                    type: type\n                }, interaction);\n\n            }\n        }\n        else {\n            return client.errNormal({\n                error: \"Do the ticket setup!\",\n                type: type\n            }, interaction)\n        }\n    }\n}\n\n ","size_bytes":6340},"src/commands/tickets/create.js":{"content":"const Discord = require('discord.js');\n\nconst ticketSchema = require(\"../../database/models/tickets\");\nconst ticketChannels = require(\"../../database/models/ticketChannels\");\nconst ticketMessageConfig = require(\"../../database/models/ticketMessage\");\n\nmodule.exports = async (client, interaction, args) => {\n    let reason = \"Not given\";\n    if (interaction.options) reason = interaction.options.getString('reason') || \"Not given\";\n\n    let type = 'reply';\n    if (interaction.isCommand()) type = 'editreply';\n\n    ticketChannels.findOne({ Guild: interaction.guild.id, creator: interaction.user.id, resolved: false }, async (err, data) => {\n        if (data) {\n            if (interaction.isCommand()) {\n                return client.errNormal({\n                    error: \"Ticket limit reached. 1/1\",\n                    type: 'ephemeraledit'\n                }, interaction);\n            }\n            else return client.errNormal({\n                error: \"Ticket limit reached. 1/1\",\n                type: 'ephemeral'\n            }, interaction);\n        }\n        else {\n            ticketSchema.findOne({ Guild: interaction.guild.id }, async (err, TicketData) => {\n                if (TicketData) {\n                    const logsChannel = interaction.guild.channels.cache.get(TicketData.Logs);\n                    const ticketCategory = interaction.guild.channels.cache.get(TicketData.Category);\n                    const ticketRole = interaction.guild.roles.cache.get(TicketData.Role);\n                    let role = interaction.guild.roles.cache.find(r => r.id === ticketRole.id);\n\n                    try {\n                        var openTicket = \"Thanks for creating a ticket! \\nSupport will be with you shortly \\n\\n🔒 - Close ticket \\n✋ - Claim ticket \\n📝 - Save transcript \\n🔔 - Send a notification\";\n                        let ticketMessageData = await ticketMessageConfig.findOne({ Guild: interaction.guild.id });\n                        if (ticketMessageData) {\n                            openTicket = ticketMessageData.openTicket;\n                        }\n\n                        const row = new Discord.ActionRowBuilder()\n                            .addComponents(\n                                new Discord.ButtonBuilder()\n                                    .setCustomId('Bot_closeticket')\n                                    .setEmoji('🔒')\n                                    .setStyle(Discord.ButtonStyle.Primary),\n\n                                new Discord.ButtonBuilder()\n                                    .setCustomId('Bot_claimTicket')\n                                    .setEmoji('✋')\n                                    .setStyle(Discord.ButtonStyle.Primary),\n\n                                new Discord.ButtonBuilder()\n                                    .setCustomId('Bot_transcriptTicket')\n                                    .setEmoji('📝')\n                                    .setStyle(Discord.ButtonStyle.Primary),\n\n                                new Discord.ButtonBuilder()\n                                    .setCustomId('Bot_noticeTicket')\n                                    .setEmoji('🔔')\n                                    .setStyle(Discord.ButtonStyle.Primary),\n                            );\n\n                        client.embed({\n                            title: `${client.emotes.animated.loading}・Progress`,\n                            desc: `Your ticket is being created...`,\n                            type: 'ephemeral'\n                        }, interaction).then((msg) => {\n\n                            if (TicketData.TicketCount) {\n                                TicketData.TicketCount += 1;\n                                TicketData.save();\n                            }\n                            else {\n                                TicketData.TicketCount = 1;\n                                TicketData.save();\n                            }\n\n                            if (ticketCategory == undefined) {\n                                return client.errNormal({\n                                    error: \"Do the setup!\",\n                                    type: type\n                                }, interaction);\n                            }\n                            else {\n\n                                let category = interaction.guild.channels.cache.find(c => c.id === ticketCategory.id);\n\n                                let permsToHave = [\n                                    Discord.PermissionsBitField.Flags.AddReactions,\n                                    Discord.PermissionsBitField.Flags.SendMessages,\n                                    Discord.PermissionsBitField.Flags.ViewChannel,\n                                    Discord.PermissionsBitField.Flags.AttachFiles,\n                                    Discord.PermissionsBitField.Flags.ReadMessageHistory,\n                                ]\n\n                                var ticketid = String(TicketData.TicketCount).padStart(4, 0);;\n\n                                interaction.guild.channels.create({\n                                    name: `ticket-${ticketid}`,\n                                    permissionOverwrites: [\n                                        {\n                                            deny: [Discord.PermissionsBitField.Flags.ViewChannel],\n                                            id: interaction.guild.id\n                                        },\n                                        {\n                                            allow: permsToHave,\n                                            id: interaction.user.id\n                                        },\n                                        {\n                                            allow: permsToHave,\n                                            id: role.id\n                                        },\n                                    ],\n                                    parent: category.id\n                                }).then(async channel => {\n                                    client.embed({\n                                        title: `⚙️・System`,\n                                        desc: `Ticket has been created`,\n                                        fields: [\n                                            {\n                                                name: \"👤┆Creator\",\n                                                value: `${interaction.user}`,\n                                                inline: true\n                                            },\n                                            {\n                                                name: \"📂┆Channel\",\n                                                value: `${channel}`,\n                                                inline: true\n                                            },\n                                            {\n                                                name: \"⏰┆Created at\",\n                                                value: `<t:${(Date.now() / 1000).toFixed(0)}:f>`,\n                                                inline: true\n                                            }\n                                        ],\n                                        type: type\n                                    }, interaction)\n\n                                    new ticketChannels({\n                                        Guild: interaction.guild.id,\n                                        TicketID: ticketid,\n                                        channelID: channel.id,\n                                        creator: interaction.user.id,\n                                        claimed: \"None\"\n                                    }).save();\n\n                                    if (logsChannel) {\n                                        client.embed({\n                                            title: `📝・Open ticket`,\n                                            desc: `A new ticket has been created`,\n                                            fields: [\n                                                {\n                                                    name: \"👤┆Creator\",\n                                                    value: `${interaction.user.tag} (${interaction.user.id})`,\n                                                    inline: false\n                                                },\n                                                {\n                                                    name: \"📂┆Channel\",\n                                                    value: `${channel.name} is found at ${channel}`,\n                                                    inline: false\n                                                },\n                                                {\n                                                    name: \"⏰┆Created at\",\n                                                    value: `<t:${(Date.now() / 1000).toFixed(0)}:F>`,\n                                                    inline: false\n                                                }\n                                            ],\n                                        }, logsChannel)\n                                    }\n\n                                    await client.embed({\n                                        desc: openTicket,\n                                        fields: [\n                                            {\n                                                name: \"👤┆Creator\",\n                                                value: `${interaction.user}`,\n                                                inline: true\n                                            },\n                                            {\n                                                name: \"📄┆Subject\",\n                                                value: `${reason}`,\n                                                inline: true\n                                            },\n                                            {\n                                                name: \"⏰┆Created at\",\n                                                value: `<t:${(Date.now() / 1000).toFixed(0)}:F>`,\n                                                inline: true\n                                            }\n                                        ],\n                                        components: [row],\n                                        content: `${interaction.user}, ${role}`\n                                    }, channel)\n                                })\n                            }\n\n                        })\n\n                    }\n                    catch (err) {\n                        client.errNormal({\n                            error: \"Do the setup!\",\n                            type: type\n                        }, interaction);\n                        console.log(err);\n                    }\n                }\n                else {\n                    return client.errNormal({\n                        error: \"Do the setup!\",\n                        type: type\n                    }, interaction);\n                }\n            })\n        }\n    })\n}\n\n ","size_bytes":11238},"src/commands/tickets/delete.js":{"content":"const Discord = require('discord.js');\n\nconst ticketSchema = require(\"../../database/models/tickets\");\nconst ticketChannels = require(\"../../database/models/ticketChannels\");\n\nmodule.exports = async (client, interaction, args) => {\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n        perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n    }, interaction)\n\n    if (perms == false) return;\n\n    let type = 'reply';\n    if (interaction.isCommand()) type = 'editreply';\n\n    ticketSchema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n        if (data) {\n            const ticketCategory = interaction.guild.channels.cache.get(data.Category);\n\n            if (ticketCategory == undefined) {\n                return client.errNormal({\n                    error: \"Do the ticket setup!\",\n                    type: type\n                }, interaction)\n            }\n\n            if (interaction.channel.parentId == ticketCategory.id) {\n                client.simpleEmbed({\n                    desc: `Delete this ticket in **5s**`,\n                    type: type\n                }, interaction).then(msg => setTimeout(() => {\n                    interaction.channel.delete();\n                    ticketChannels.findOne({ Guild: interaction.guild.id, channelID: interaction.channel.id }, async (err, data) => {\n                        if (data) {\n                            var remove = await ticketChannels.deleteOne({ Guild: interaction.guild.id, channelID: interaction.channel.id });\n                        }\n                    })\n                }, 5000));\n            }\n            else {\n                client.errNormal({\n                    error: \"This is not a ticket!\",\n                    type: type\n                }, interaction);\n            }\n        }\n        else {\n            return client.errNormal({\n                error: \"Do the ticket setup!\",\n                type: type\n            }, interaction)\n        }\n    })\n}\n\n ","size_bytes":2032},"src/commands/tickets/information.js":{"content":"const Discord = require('discord.js');\n\nconst ticketSchema = require(\"../../database/models/tickets\");\nconst ticketChannels = require(\"../../database/models/ticketChannels\");\n\nmodule.exports = async (client, interaction, args) => {\n    ticketChannels.findOne({ Guild: interaction.guild.id, channelID: interaction.channel.id }, async (err, ticketData) => {\n        if (ticketData) {\n            ticketSchema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n                if (data) {\n                    const ticketCategory = interaction.guild.channels.cache.get(data.Category);\n\n                    if (ticketCategory == undefined) {\n                        return client.errNormal({\n                            error: \"Do the setup!\",\n                            type: 'editreply'\n                        }, interaction);\n                    }\n\n                    if (interaction.channel.parentId == ticketCategory.id) {\n\n                        client.embed({\n                            desc: `${client.emotes.animated.loading}・Loading information...`,\n                            type: 'editreply'\n                        }, interaction).then((msg) => {\n\n                            client.transcript(interaction, interaction.channel);\n\n                            return client.embed({\n                                title: `ℹ・Information`,\n                                fields: [\n                                    {\n                                        name: \"Ticket name\",\n                                        value: `\\`${interaction.channel.name}\\``,\n                                        inline: true,\n                                    },\n                                    {\n                                        name: \"Channel id\",\n                                        value: `\\`${interaction.channel.id}\\``,\n                                        inline: true,\n                                    },\n                                    {\n                                        name: \"Creator\",\n                                        value: `<@!${ticketData.creator}>`,\n                                        inline: true,\n                                    },\n                                    {\n                                        name: \"Claimed by\",\n                                        value: `<@!${ticketData.claimed}>`,\n                                        inline: true,\n                                    },\n                                    {\n                                        name: \"Ticket id\",\n                                        value: `${ticketData.TicketID}`,\n                                        inline: true,\n                                    },\n                                ],\n                                type: 'editreply'\n                            }, msg)\n                        })\n\n                    }\n                    else {\n                        client.errNormal({ \n                            error: \"This is not a ticket!\", \n                            type: 'editreply'\n                        }, interaction);\n                    }\n                }\n                else {\n                    return client.errNormal({ \n                        error: \"Do the setup!\", \n                        type: 'editreply'\n                    }, interaction);\n                }\n            })\n        }\n    })\n}\n\n ","size_bytes":3434},"src/commands/tickets/lower.js":{"content":"const Discord = require('discord.js');\n\nconst ticketSchema = require(\"../../database/models/tickets\");\nconst ticketChannels = require(\"../../database/models/ticketChannels\");\n\nmodule.exports = async (client, interaction, args) => {\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n        perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n    }, interaction)\n\n    if (perms == false) return;\n\n    ticketSchema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n        if (data) {\n            const ticketCategory = interaction.guild.channels.cache.get(data.Category);\n            const ticketRole = interaction.guild.roles.cache.get(data.Role);\n\n            if (ticketCategory == undefined) {\n                return client.errNormal({\n                    error: \"Do the setup!\",\n                    type: 'editreply'\n                }, interaction);\n            }\n\n            if (interaction.channel.parentId == ticketCategory.id) {\n\n                try {\n                    interaction.channel.permissionOverwrites.edit(ticketRole, {\n                        ViewChannel: true,\n                        SendMessages: true,\n                        AttachFiles: true,\n                        ReadMessageHistory: true,\n                        AddReactions: true\n                    });\n\n                    return client.simpleEmbed({\n                        desc: `Ticket lowered by <@!${interaction.user.id}>`,\n                        type: 'editreply'\n                    }, interaction)\n                }\n                catch {\n                    client.errNormal({\n                        error: \"Something went wrong!\",\n                        type: 'editreply'\n                    }, interaction);\n                }\n\n            }\n            else {\n                client.errNormal({ \n                    error: \"This is not a ticket!\", \n                    type: 'editreply'\n                }, interaction);\n\n            }\n        }\n        else {\n            return client.errNormal({ \n                error: \"Do the setup!\", \n                type: 'editreply'\n            }, interaction);\n        }\n    })\n}\n\n ","size_bytes":2209},"src/commands/tickets/notice.js":{"content":"const Discord = require('discord.js');\n\nconst ticketSchema = require(\"../../database/models/tickets\");\nconst ticketChannels = require(\"../../database/models/ticketChannels\");\n\nmodule.exports = async (client, interaction, args) => {\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n        perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n    }, interaction)\n\n    if (perms == false) return;\n\n    let type = 'reply';\n    if (interaction.isCommand()) type = 'editreply';\n\n    ticketChannels.findOne({ Guild: interaction.guild.id, channelID: interaction.channel.id }, async (err, ticketData) => {\n        if (ticketData) {\n            if (interaction.user.id !== ticketData.creator) {\n                ticketSchema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n                    if (data) {\n                        const ticketCategory = interaction.guild.channels.cache.get(data.Category);\n\n                        if (ticketCategory == undefined) {\n                            return client.errNormal({\n                                error: \"Do the setup!\",\n                                type: type\n                            }, interaction);\n                        }\n\n                        if (interaction.channel.parentId == ticketCategory.id) {\n                            client.simpleEmbed({\n                                desc: `Hey <@!${ticketData.creator}>, \\n\\nCan we still help you? \\nIf there is no response within **24 hours**, we will close this ticket \\n\\n- Team ${interaction.guild.name}`,\n                                content: `<@!${ticketData.creator}>`,\n                                type: type\n                            }, interaction)\n                        }\n                        else {\n                            client.errNormal({\n                                error: \"This is not a ticket!\",\n                                type: type\n                            }, interaction);\n\n                        }\n                    }\n                    else {\n                        return client.errNormal({\n                            error: \"Do the setup!\",\n                            type: type\n                        }, interaction);\n                    }\n                })\n            }\n            else {\n                return client.errNormal({\n                    error: \"You are not allowed to notice your own ticket!\",\n                    type: 'ephemeral'\n                }, interaction)\n            }\n        }\n    })\n}\n\n ","size_bytes":2575},"src/commands/tickets/open.js":{"content":"const Discord = require('discord.js');\n\nconst ticketSchema = require(\"../../database/models/tickets\");\nconst ticketChannels = require(\"../../database/models/ticketChannels\");\n\nmodule.exports = async (client, interaction, args) => {\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n        perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n    }, interaction)\n\n    if (perms == false) return;\n\n    let type = 'reply';\n    if (interaction.isCommand()) type = 'editreply';\n\n    ticketChannels.findOne({ Guild: interaction.guild.id, channelID: interaction.channel.id }, async (err, ticketData) => {\n        if (ticketData) {\n            if (ticketData.resolved == false) return client.errNormal({\n                error: \"Ticket is already open!\",\n                type: 'ephemeraledit'\n            }, interaction);\n\n            ticketSchema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n                if (data) {\n                    const ticketCategory = interaction.guild.channels.cache.get(data.Category);\n\n                    if (ticketCategory == undefined) {\n                        return client.errNormal({\n                            error: \"Do the setup!\",\n                            type: type\n                        }, interaction);\n                    }\n\n                    if (interaction.channel.parentId == ticketCategory.id) {\n                        client.users.fetch(ticketData.creator).then(usr => {\n                            interaction.channel.permissionOverwrites.edit(usr, {\n                                ViewChannel: true,\n                                SendMessages: true,\n                                AttachFiles: true,\n                                ReadMessageHistory: true,\n                                AddReactions: true\n                            });\n\n                            var ticketid = String(ticketData.TicketID).padStart(4, 0);\n                            interaction.channel.setName(`ticket-${ticketid}`);\n                        })\n\n                        ticketData.resolved = false;\n                        ticketData.save();\n\n                        return client.simpleEmbed({\n                            desc: `Ticket opened by <@!${interaction.user.id}>`,\n                            type: type\n                        }, interaction)\n                    }\n                    else {\n                        client.errNormal({\n                            error: \"This is not a ticket!\",\n                            type: type\n                        }, interaction);\n\n                    }\n                }\n                else {\n                    return client.errNormal({\n                        error: \"Do the setup!\",\n                        type: type\n                    }, interaction);\n                }\n            })\n        }\n    })\n}\n\n ","size_bytes":2909},"src/commands/tickets/raise.js":{"content":"const Discord = require('discord.js');\n\nconst ticketSchema = require(\"../../database/models/tickets\");\nconst ticketChannels = require(\"../../database/models/ticketChannels\");\n\nmodule.exports = async (client, interaction, args) => {\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n        perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n    }, interaction)\n\n    if (perms == false) return;\n\n    ticketSchema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n        if (data) {\n            const ticketCategory = interaction.guild.channels.cache.get(data.Category);\n            const ticketRole = interaction.guild.roles.cache.get(data.Role);\n\n            if (ticketCategory == undefined) {\n                return client.errNormal({\n                    error: \"Do the setup!\",\n                    type: 'editreply'\n                }, interaction);\n            }\n\n            if (interaction.channel.parentId == ticketCategory.id) {\n\n                try {\n                    interaction.channel.permissionOverwrites.edit(ticketRole, {\n                        ViewChannel: false,\n                        SendMessages: false,\n                        AttachFiles: false,\n                        ReadMessageHistory: false,\n                        AddReactions: false\n                    });\n\n                    return client.simpleEmbed({\n                        desc: `Ticket raised by <@!${interaction.user.id}>`,\n                        type: 'editreply'\n                    }, interaction)\n                }\n                catch {\n                    client.errNormal({\n                        error: \"Something went wrong!\",\n                        type: 'editreply'\n                    }, interaction);\n                }\n\n            }\n            else {\n                client.errNormal({\n                    error: \"This is not a ticket!\",\n                    type: 'editreply'\n                }, interaction);\n\n            }\n        }\n        else {\n            return client.errNormal({\n                error: \"Do the setup!\",\n                type: 'editreply'\n            }, interaction);\n        }\n    })\n}\n\n ","size_bytes":2209},"src/commands/tickets/remove.js":{"content":"const Discord = require('discord.js');\n\nconst ticketSchema = require(\"../../database/models/tickets\");\nconst ticketChannels = require(\"../../database/models/ticketChannels\");\n\nmodule.exports = async (client, interaction, args) => {\n    const data = await ticketSchema.findOne({ Guild: interaction.guild.id });\n    const ticketData = await ticketChannels.findOne({ Guild: interaction.guild.id, channelID: interaction.channel.id });\n\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n        perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n    }, interaction)\n\n    if (perms == false) return;\n\n    if (data) {\n        const ticketCategory = interaction.guild.channels.cache.get(data.Category);\n        if (ticketCategory == undefined) {\n            return client.errNormal({\n                error: \"Do the ticket setup!\",\n                type: 'editreply'\n            }, interaction)\n        }\n\n        if (interaction.channel.parentId == ticketCategory.id) {\n            let user = interaction.options.getUser('user');\n            if (ticketData && user.id == ticketData.creator) {\n                return client.errNormal({ \n                    error: \"You cannot remove the ticket maker from this ticket\", \n                    type: 'ephemeraledit' \n                }, interaction)\n            }\n\n            interaction.channel.permissionOverwrites.edit(user.id, { ViewChannel: false, SendMessages: false });\n\n            return client.simpleEmbed({\n                desc: `Removed ${user}`,\n                type: 'editreply'\n            }, interaction)\n        }\n        else {\n            client.errNormal({ \n                error: \"This is not a ticket!\", \n                type: 'editreply' \n            }, interaction)\n        }\n    }\n}\n\n ","size_bytes":1818},"src/commands/tickets/rename.js":{"content":"const Discord = require('discord.js');\n\nconst ticketSchema = require(\"../../database/models/tickets\");\n\nmodule.exports = async (client, interaction, args) => {\n    const data = await ticketSchema.findOne({ Guild: interaction.guild.id });\n\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n        perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n    }, interaction)\n\n    if (perms == false) return;\n\n    if (data) {\n        const ticketCategory = interaction.guild.channels.cache.get(data.Category);\n        if (ticketCategory == undefined) {\n            return client.errNormal({\n                error: \"Do the ticket setup!\",\n                type: 'editreply'\n            }, interaction)\n        }\n\n        if (interaction.channel.parentId == ticketCategory.id) {\n            let name = interaction.options.getString('name');\n            interaction.channel.edit({ name: name });\n\n            return client.simpleEmbed({\n                desc: `Channel name has changed to ${name}`,\n                type: 'editreply'\n            }, interaction)\n        }\n        else {\n            client.errNormal({\n                error: \"This is not a ticket!\",\n                type: 'editreply'\n            }, interaction)\n        }\n    }\n}\n\n ","size_bytes":1306},"src/commands/tickets/transcript.js":{"content":"const Discord = require('discord.js');\n\nconst ticketSchema = require(\"../../database/models/tickets\");\nconst ticketChannels = require(\"../../database/models/ticketChannels\");\n\nmodule.exports = async (client, interaction, args) => {\n    const perms = await client.checkUserPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n        perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n    }, interaction)\n\n    if (perms == false) return;\n\n    let type = 'reply';\n    if (interaction.isCommand()) type = 'editreply';\n\n    ticketChannels.findOne({ Guild: interaction.guild.id, channelID: interaction.channel.id }, async (err, ticketData) => {\n        if (ticketData) {\n            ticketSchema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n                if (data) {\n                    const ticketCategory = interaction.guild.channels.cache.get(data.Category);\n\n                    if (ticketCategory == undefined) {\n                        return client.errNormal({\n                            error: \"Do the setup!\",\n                            type: type\n                        }, interaction);\n                    }\n\n                    if (interaction.channel.parentId == ticketCategory.id) {\n                        return client.simpleEmbed({\n                            desc: `${client.emotes.animated.loading}・Transcript saving...`,\n                            type: type\n                        }, interaction).then(async (editMsg) => {\n                            client.transcript(interaction, interaction.channel).then(() => {\n\n                                return client.simpleEmbed({\n                                    desc: `Transcript saved`,\n                                    type: 'editreply'\n                                }, interaction)\n\n                            })\n                        });\n                    }\n                    else {\n                        client.errNormal({\n                            error: \"This is not a ticket!\",\n                            type: type\n                        }, interaction);\n\n                    }\n                }\n                else {\n                    return client.errNormal({\n                        error: \"Do the setup!\",\n                        type: type\n                    }, interaction);\n                }\n            })\n        }\n    })\n}\n\n ","size_bytes":2391},"src/commands/tickets/unclaim.js":{"content":"const Discord = require('discord.js');\n\nconst ticketSchema = require(\"../../database/models/tickets\");\nconst ticketChannels = require(\"../../database/models/ticketChannels\");\n\nmodule.exports = async (client, interaction, args) => {\n    const data = await ticketSchema.findOne({ Guild: interaction.guild.id });\n    const ticketData = await ticketChannels.findOne({ Guild: interaction.guild.id, channelID: interaction.channel.id })\n\n    if (ticketData) {\n        if (interaction.user.id !== ticketData.creator) {\n            const perms = await client.checkUserPerms({\n                flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n                perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n            }, interaction)\n        \n            if (perms == false) return;\n\n            if (data) {\n                if (ticketData.claimed == \"\" || ticketData.claimed == undefined || ticketData.claimed == \"None\") {\n                    client.errNormal({\n                        text: \"Ticket not claimed!\",\n                        type: 'ephemeral'\n                    }, interaction)\n                }\n                else {\n                    if (ticketData.claimed == interaction.user.id) {\n                        const ticketCategory = interaction.guild.channels.cache.get(data.Category);\n\n                        if (ticketCategory == undefined) {\n                            return client.errNormal({\n                                error: \"Do the setup!\",\n                                type: 'editreply'\n                            }, interaction);\n                        }\n\n                        if (interaction.channel.parentId == ticketCategory.id) {\n\n                            ticketData.claimed = \"None\";\n                            ticketData.save();\n\n                            return client.simpleEmbed({\n                                desc: `This ticket can now be claimed again!`,\n                                type: 'editreply'\n                            }, interaction)\n\n                        }\n                        else {\n                            client.errNormal({\n                                error: \"This is not a ticket!\",\n                                type: 'editreply'\n                            }, interaction)\n                        }\n                    }\n                    else {\n                        client.errNormal({\n                            error: \"You have not claimed this ticket!\",\n                            type: 'editreply'\n                        }, interaction)\n                    }\n                }\n            }\n            else {\n                return client.errNormal({\n                    error: \"Do the ticket setup!\",\n                    type: 'editreply'\n                }, interaction)\n            }\n        }\n    }\n}\n\n ","size_bytes":2830},"src/commands/tools/anagram.js":{"content":"const Discord = require('discord.js');\nconst fetch = require(\"node-fetch\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    const word = interaction.options.getString('word');\n\n    fetch(`http://www.anagramica.com/all/${encodeURIComponent(word)}`).then((res) => res.json()).catch({})\n        .then(async (json) => {\n            let content = ``;\n            if (!json.all[0]) return client.errNormal({ error: \"No word found!\", type: 'editreply' }, interaction)\n\n            json.all.forEach(i => {\n                content += `${i}\\n`;\n            });\n\n            client.embed({\n                title: `❓・Anagram`,\n                desc: `I formed a word with the given letters`,\n                fields: [\n                    {\n                        name: `💬┇Word(s)`,\n                        value: content\n                    }\n                ],\n                type: 'editreply'\n            }, interaction)\n        }).catch({})\n\n}\n\n ","size_bytes":961},"src/commands/tools/button.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const url = interaction.options.getString('url');\n    const text = interaction.options.getString('text');\n\n    if (text.length > 50) return client.errNormal({ error: \"Your button text cannot be longer than 50 characters\", type: 'editreply' }, interaction);\n\n    let button = new Discord.ButtonBuilder()\n        .setLabel(`${text}`)\n        .setURL(`${url}`)\n        .setStyle(Discord.ButtonStyle.Link);\n\n    let row = new Discord.ActionRowBuilder()\n        .addComponents(button)\n\n    client.embed({\n        title: `🔗・${text}`,\n        desc: `Click the button to open the link!`,\n        components: [row],\n        type: 'editreply'\n    }, interaction)\n\n}\n\n ","size_bytes":764},"src/commands/tools/calculator.js":{"content":"const Discord = require('discord.js');\nconst math = require('mathjs');\n\nmodule.exports = async (client, interaction, args) => {\n    const createButton = (label, disabled, getRandomString) => {\n        let style = Discord.ButtonStyle.Secondary;\n        if (label === 'AC' || label === 'DC' || label === '⌫') {\n            style = Discord.ButtonStyle.Danger;\n        } else if (label === '=') {\n            style = Discord.ButtonStyle.Success;\n        } else if (\n            label === '(' ||\n            label === ')' ||\n            label === '^' ||\n            label === '%' ||\n            label === '÷' ||\n            label === 'x' ||\n            label === '-' ||\n            label === '+' ||\n            label === '.'\n        ) {\n            style = Discord.ButtonStyle.Primary;\n        }\n        if (disabled) {\n            const btn = new Discord.ButtonBuilder()\n                .setLabel(label)\n                .setStyle(style)\n                .setDisabled();\n            if (label === '\\u200b') {\n                btn.setCustomId(`${getRandomString(10)}`);\n            } else {\n                btn.setCustomId('cal' + label);\n            }\n            return btn;\n        } else {\n            const btn = new Discord.ButtonBuilder().setLabel(label).setStyle(style);\n            if (label === '\\u200b') {\n                btn.setDisabled();\n                btn.setCustomId(`${getRandomString(10)}`);\n            } else {\n                btn.setCustomId('cal' + label);\n            }\n            return btn;\n        }\n    };\n\n    const addRow = (btns) => {\n        const row = new Discord.ActionRowBuilder();\n        for (const btn of btns) {\n            row.addComponents(btn);\n        }\n        return row;\n    };\n\n    const getRandomString = (length) => {\n        const randomChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n        let result = '';\n        for (let i = 0; i < length; i++) {\n            result += randomChars.charAt(\n                Math.floor(Math.random() * randomChars.length),\n            );\n        }\n        return result;\n    };\n\n    let str = ' ';\n    let stringify = '```\\n' + str + '\\n```';\n\n    const row = [];\n    const rows = [];\n\n    const button = new Array([], [], [], [], []);\n    const buttons = new Array([], [], [], [], []);\n\n    const text = [\n        '(',\n        ')',\n        '^',\n        '%',\n        'AC',\n        '7',\n        '8',\n        '9',\n        '÷',\n        'DC',\n        '4',\n        '5',\n        '6',\n        'x',\n        '⌫',\n        '1',\n        '2',\n        '3',\n        '-',\n        '\\u200b',\n        '.',\n        '0',\n        '=',\n        '+',\n        '\\u200b',\n    ];\n\n    let cur = 0;\n    let current = 0;\n\n    for (let i = 0; i < text.length; i++) {\n        if (button[current].length === 5) current++;\n        button[current].push(\n            createButton(text[i], false, getRandomString),\n        );\n        if (i === text.length - 1) {\n            for (const btn of button) row.push(addRow(btn));\n        }\n    }\n\n    await client.embed({\n        title: `🧮・Calculator`,\n        desc: stringify,\n        components: row,\n        type: 'editreply'\n    }, interaction).then(msg => {\n        function edit() {\n            client.embed({\n                title: `🧮・Calculator`,\n                desc: stringify,\n                components: row,\n                type: 'editreply'\n            }, interaction)\n        }\n\n        function lock() {\n            for (let i = 0; i < text.length; i++) {\n                if (buttons[cur].length === 5) cur++;\n                buttons[cur].push(\n                    createButton(text[i], true, getRandomString),\n                );\n                if (i === text.length - 1) {\n                    for (const btn of buttons) rows.push(addRow(btn));\n                }\n            }\n\n            client.embed({\n                title: `🧮・Calculator`,\n                desc: stringify,\n                components: [rows],\n                type: 'editreply'\n            }, interaction)\n        }\n\n        const calc = interaction.channel.createMessageComponentCollector({ componentType: Discord.ComponentType.Button });\n\n        calc.on('collect', async (btn) => {\n            if (btn.user.id !== interaction.user.id) return;\n\n            btn.deferUpdate();\n            if (btn.customId === 'calAC') {\n                str += ' ';\n                stringify = '```\\n' + str + '\\n```';\n                edit();\n            } else if (btn.customId === 'calx') {\n                str += '*';\n                stringify = '```\\n' + str + '\\n```';\n                edit();\n            } else if (btn.customId === 'cal÷') {\n                str += '/';\n                stringify = '```\\n' + str + '\\n```';\n                edit();\n            } else if (btn.customId === 'cal⌫') {\n                if (str === ' ' || str === '' || str === null || str === undefined) {\n                    return;\n                } else {\n                    str = str.split('');\n                    str.pop();\n                    str = str.join('');\n                    stringify = '```\\n' + str + '\\n```';\n                    edit();\n                }\n            } else if (btn.customId === 'cal=') {\n                if (str === ' ' || str === '' || str === null || str === undefined) {\n                    return;\n                } else {\n                    try {\n                        str += ' = ' + math.evaluate(str);\n                        stringify = '```\\n' + str + '\\n```';\n                        edit();\n                        str = ' ';\n                        stringify = '```\\n' + str + '\\n```';\n                    } catch (e) {\n                        str = \"The provided equation is invalid!\";\n                        stringify = '```\\n' + str + '\\n```';\n                        edit();\n                        str = ' ';\n                        stringify = '```\\n' + str + '\\n```';\n                    }\n                }\n            } else if (btn.customId === 'calDC') {\n                str = \"Calculator is disabled!\";\n                stringify = '```\\n' + str + '\\n```';\n                edit();\n                calc.stop();\n                lock();\n            } else {\n                str += btn.customId.replace('cal', '');\n                stringify = '```\\n' + str + '\\n```';\n                edit();\n            }\n        });\n\n        client.embed({\n            title: `🧮・Calculator`,\n            desc: stringify,\n            components: row,\n            type: 'editreply'\n        }, interaction)\n    })\n\n}\n\n ","size_bytes":6528},"src/commands/tools/decode.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const code = interaction.options.getString('code');\n\n    if (isNaN(parseInt(code))) return client.errNormal({\n        error: `You can only decode binary code!`,\n        type: 'editreply'\n    }, interaction);\n\n    let decode = code.split(' ')\n        .map(bin => String.fromCharCode(parseInt(bin, 2)))\n        .join('');\n\n    client.embed({\n        title: `${client.emotes.normal.check}・Success!`,\n        desc: `I have decoded code`,\n        fields: [\n            {\n                name: \"📥 - Input\",\n                value: `\\`\\`\\`${code}\\`\\`\\``,\n                inline: false,\n            },\n            {\n                name: \"📥 - Output\",\n                value: `\\`\\`\\`${decode}\\`\\`\\``,\n                inline: false,\n            },\n        ],\n        type: 'editreply'\n    }, interaction)\n\n}\n\n ","size_bytes":908},"src/commands/tools/emojify.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction) => {\n\n    const args = interaction.options.getString('text');\n\n    if (args.length > 4096) return client.errNormal({ error: \"Your emojify text cannot be longer than 4096 characters\", type: 'editreply' }, interaction);\n\n    const specialCodes = {\n        '0': ':zero:',\n        '1': ':one:',\n        '2': ':two:',\n        '3': ':three:',\n        '4': ':four:',\n        '5': ':five:',\n        '6': ':six:',\n        '7': ':seven:',\n        '8': ':eight:',\n        '9': ':nine:',\n        '#': ':hash:',\n        '*': ':asterisk:',\n        '?': ':grey_question:',\n        '!': ':grey_exclamation:',\n        ' ': '   '\n    }\n\n    const text = args.toLowerCase().split('').map(letter => {\n        if (/[a-z]/g.test(letter)) {\n            return `:regional_indicator_${letter}:`\n        } else if (specialCodes[letter]) {\n            return `${specialCodes[letter]}`\n        }\n        return letter;\n    }).join('');\n\n    client.embed({\n        title: `🙂・Emojify`,\n        desc: `${text}`,\n        type: 'editreply'\n    }, interaction)\n\n}\n\n ","size_bytes":1122},"src/commands/tools/encode.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const text = interaction.options.getString('text');\n\n    let encode = text.split(\"\").map(x => x.charCodeAt(0).toString(2)).join(\" \");\n\n    client.embed({\n        title: `${client.emotes.normal.check}・Success!`,\n        desc: `I converted text to binary text`,\n        fields: [\n            {\n                name: \"📥┇Input\",\n                value: `\\`\\`\\`${text}\\`\\`\\``,\n                inline: false,\n            },\n            {\n                name: \"📤┇Output\",\n                value: `\\`\\`\\`${encode}\\`\\`\\``,\n                inline: false,\n            },\n        ],\n        type: 'editreply'\n    }, interaction)\n\n}\n\n ","size_bytes":734},"src/commands/tools/enlarge.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const emoji = interaction.options.getString('emoji');\n    const parsedEmoji = Discord.parseEmoji(emoji)\n\n    if (parsedEmoji) {\n        const ex = parsedEmoji.animated ? \".gif\" : \".png\";\n        const url = `https://cdn.discordapp.com/emojis/${parsedEmoji.id + ex}`;\n\n        return client.embed({\n            image: url,\n            type: 'editreply'\n        }, interaction)\n    } else {\n        client.errNormal({ error: \"Please supply a valid emoji!\", type: 'editreply' }, interaction)\n    }\n}\n\n ","size_bytes":600},"src/commands/tools/mcskin.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const name = interaction.options.getString('name');\n\n    if (name == null) return client.errUsage({ usage: \"mcskin [player name]\",type: 'editreply' }, interaction)\n\n    client.embed({\n        title: `🎮・Skin of ${name}`,\n        image: `https://minotar.net/armor/body/${name}/700.png`,\n        type: 'editreply'\n    }, interaction)\n\n}\n\n ","size_bytes":442},"src/commands/tools/mcstatus.js":{"content":"const Discord = require('discord.js');\nconst fetch = require(\"node-fetch\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    const ip = interaction.options.getString('ip');\n\n    if (ip == null) return client.errUsage({ usage: \"mcstatus [ip]\", type: 'editreply' }, interaction)\n\n    fetch(`https://api.mcsrvstat.us/2/${ip}`)\n        .then((res) => res.json()).catch({})\n        .then(async (json) => {\n\n            if (!json.players) return client.errNormal({ error: \"Can't find the server!\", type: 'editreply' }, interaction)\n\n            return client.embed({\n                title: `📁・${ip}`,\n                thumbnail: `https://eu.mc-api.net/v3/server/favicon/${ip}`,\n                fields: [{\n                    name: \"🟢┇Online\",\n                    value: `${json.online}`,\n                    inline: true,\n                },\n                {\n                    name: \"🏷️┇Version\",\n                    value: `${json.version}`,\n                    inline: true,\n                },\n                {\n                    name: \"👤┇Players online\",\n                    value: `${json.players.online}/${json.players.max}`,\n                    inline: true,\n                },\n                ], type: 'editreply'\n            }, interaction)\n        }).catch({})\n}\n\n ","size_bytes":1306},"src/commands/tools/pwdgen.js":{"content":"const Discord = require('discord.js');\nconst generator = require('generate-password');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const password = generator.generate({\n        length: 12,\n        symbols: true,\n        numbers: true\n    });\n\n    client.succNormal({ text: `I have generate a password and have it sent to your DM`, type: 'editreply' }, interaction);\n\n    client.succNormal({\n        text: `Your generated password`,\n        fields: [\n            {\n                name: \"🔑┇Password\",\n                value: `${password}`,\n                inline: true,\n            },\n            {\n                name: \"👣┇Length\",\n                value: `12`,\n                inline: true,\n            }\n        ]\n    }, interaction.user)\n\n}\n\n ","size_bytes":772},"src/commands/tools/qrcode.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const text = interaction.options.getString('text');\n\n    client.embed({\n        title: `📱・Qrcode`,\n        image: `https://api.qrserver.com/v1/create-qr-code/?size=1024x1024&data=${text.replace(new RegExp(\" \", \"g\"), \"%20\")}`,\n        type: 'editreply'\n    }, interaction)\n\n}\n\n ","size_bytes":383},"src/commands/tools/remind.js":{"content":"const Discord = require('discord.js');\nconst Schema = require(\"../../database/models/reminder\");\nconst ms = require(\"ms\");\n\nmodule.exports = async (client, interaction, args) => {\n\n    const time = interaction.options.getString('time');\n    const text = interaction.options.getString('message');\n\n    const endtime = new Date().getTime() + ms(time);\n\n    Schema.findOne({ Text: text, User: interaction.user.id, endTime: endtime }, async (err, data) => {\n        if (data) {\n            return client.errNormal({ error: `You already made this reminder!`, type: 'editreply' }, interaction);\n        }\n        else {\n            return client.succNormal({\n                text: `Your reminder is set!`,\n                fields: [{\n                    name: `${client.emotes.normal.clock}┇End Time`,\n                    value: `${new Date(endtime).toLocaleTimeString()}`,\n                    inline: true,\n                },\n                {\n                    name: `💭┇Reminder`,\n                    value: `${text}`,\n                    inline: true,\n                }\n                ],\n                type: 'editreply'\n            }, interaction);\n        }\n    })\n\n    setTimeout(async () => {\n\n        client.embed({\n            title: `🔔・Reminder`,\n            desc: `Your reminder just ended!`,\n            fields: [\n                {\n                    name: `💭┇Reminder`,\n                    value: `${text}`,\n                    inline: true,\n                }\n            ],\n        }, interaction.user);\n\n        let deleted = await Schema.findOneAndDelete({ Text: text, User: interaction.user.id, endTime: endtime });\n    }, endtime - new Date().getTime());\n\n}\n\n ","size_bytes":1693},"src/commands/tools/review.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/reviewChannels\");\n\nmodule.exports = async (client, interaction, args) => {\n    const stars = interaction.options.getNumber('stars');\n    const message = interaction.options.getString('message') || 'Not given';\n\n    if (stars < 1 || stars > 5) return client.errNormal({\n        error: `Stars must be a minimum of 1 and a maximum of 5`,\n        type: 'editreply'\n    }, interaction)\n\n    Schema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n        if (data) {\n            const channel = interaction.member.guild.channels.cache.get(data.Channel);\n            if (!channel) return  client.errNormal({\n                error: `No review channel set! Do \\`reviewchannel\\``,\n                type: 'editreply'\n            }, interaction);\n            \n            let totalStars = \"\";\n            for (let i = 0; i < stars; i++) {\n                totalStars += \":star:\";\n            }\n\n            client.succNormal({\n                text: \"Your review has been successfully submitted\",\n                fields: [\n                    {\n                        name: `⭐┇Stars`,\n                        value: `${stars}`,\n                        inline: true\n                    },\n                    {\n                        name: `📘┇Channel`,\n                        value: `<#${data.Channel}>`,\n                        inline: true\n                    }\n                ],\n                type: 'editreply'\n            }, interaction);\n\n            client.embed({\n                title: `Review・${interaction.user.tag}`,\n                desc: `A new review has been written!`,\n                fields: [\n                    {\n                        name: \"Stars\",\n                        value: `${totalStars}`,\n                        inline: true,\n                    },\n                    {\n                        name: \"Note\",\n                        value: `${message}`,\n                        inline: true,\n                    },\n                ]\n            }, channel)\n\n        }\n        else {\n            client.errNormal({\n                error: `No review channel set! Do \\`reviewchannel\\``,\n                type: 'editreply'\n            }, interaction)\n        }\n    })\n}\n\n ","size_bytes":2301},"src/commands/tools/sourcebin.js":{"content":"const Discord = require('discord.js');\nconst sourcebin = require('sourcebin');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const language = interaction.options.getString('language');\n    const code = interaction.options.getString('code');\n\n    const bin = await sourcebin.create(\n        [\n            {\n                content: `${code}`,\n                language: `${language}`,\n            },\n        ],\n        {\n            title: '💻・Random Code',\n            description: 'This is code was uploaded via Bot',\n        },\n    ).then(value => {\n        client.succNormal({\n            text: `Your code has been posted!`,\n            fields: [\n                {\n                    name: `🔗┇Link`,\n                    value: `[Click here to see your code](${value.url})`,\n                    inline: true,\n                }\n            ],\n            type: 'editreply'\n        }, interaction);\n    })\n\n}\n\n ","size_bytes":936},"src/commands/tools/url.js":{"content":"const Discord = require('discord.js');\nconst isgd = require('isgd');\n\nmodule.exports = async (client, interaction, args) => {\n\n    const url = interaction.options.getString('site');\n    const code = interaction.options.getString('code');\n\n    isgd.custom(url, code, function(res) {\n        if (res.startsWith(\"Error\")) return client.errNormal({\n            error: `${res.replace(\"Error: \", \"\")}`,\n            type: 'editreply'\n        }, interaction)\n\n        client.succNormal({\n            text: `Your shortened url has been created!`,\n            fields: [\n                {\n                    name: `🔗┇Link`,\n                    value: `${res}`,\n                    inline: true,\n                }\n            ], \n            type: 'editreply'\n        }, interaction);\n    });\n}\n\n ","size_bytes":791},"src/commands/voice/limit.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    const perms = await client.checkBotPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageChannels],\n        perms: [Discord.PermissionsBitField.Flags.ManageChannels]\n    }, interaction)\n\n    if (perms == false) return;\n\n    let limit = interaction.options.getNumber('limit');\n\n    const channel = interaction.member.voice.channel;\n    if (!channel) return client.errNormal({\n        error: `You're not in a voice channel!`,\n        type: 'editreply'\n    }, interaction);\n    var checkVoice = await client.checkVoice(interaction.guild, channel);\n    if (!checkVoice) {\n        return client.errNormal({\n            error: `You cannot edit this channel!`,\n            type: 'editreply'\n        }, interaction);\n    } else {\n        channel.setUserLimit(limit);\n\n        client.succNormal({\n            text: `The channel limit was to \\`${limit}\\`!`,\n            fields: [\n                {\n                    name: `📘┆Channel`,\n                    value: `${channel} (${channel.name})`\n                }\n            ],\n            type: 'editreply'\n        }, interaction);\n    }\n}\n\n","size_bytes":1197},"src/commands/voice/lock.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    const perms = await client.checkBotPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageChannels],\n        perms: [Discord.PermissionsBitField.Flags.ManageChannels]\n    }, interaction)\n\n    if (perms == false) return;\n\n    const channel = interaction.member.voice.channel;\n    if (!channel) return client.errNormal({\n        error: `You're not in a voice channel!`,\n        type: 'editreply'\n    }, interaction);\n\n    var checkVoice = await client.checkVoice(interaction.guild, channel);\n    if (!checkVoice) {\n        return client.errNormal({\n            error: `You cannot edit this channel!`,\n            type: 'editreply'\n        }, interaction);\n    } else {\n        client.succNormal({\n            text: `The channel was succesfully locked!`,\n            fields: [\n                {\n                    name: `📘┆Channel`,\n                    value: `${channel} (${channel.name})`\n                }\n            ],\n            type: 'editreply'\n        }, interaction);\n\n        channel.permissionOverwrites.edit(interaction.guild.roles.cache.find(x => x.name === '@everyone'), {\n            Connect: false\n        });\n    }\n}\n\n","size_bytes":1249},"src/commands/voice/rename.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    const perms = await client.checkBotPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageChannels],\n        perms: [Discord.PermissionsBitField.Flags.ManageChannels]\n    }, interaction)\n\n    if (perms == false) return;\n\n    let name = interaction.options.getString('name').toLowerCase();\n\n    const channel = interaction.member.voice.channel;\n    if (!channel) return client.errNormal({\n        error: `You're not in a voice channel!`,\n        type: 'editreply'\n    }, interaction);\n    var checkVoice = await client.checkVoice(interaction.guild, channel);\n    if (!checkVoice) {\n        return client.errNormal({\n            error: `You cannot edit this channel!`,\n            type: 'editreply'\n        }, interaction);\n    } else {\n\n        channel.edit({ name: name });\n\n        client.succNormal({\n            text: `The channel was renamed to \\`${name}\\``,\n            fields: [\n                {\n                    name: `📘┆Channel`,\n                    value: `${channel} (${channel.name})`\n                }\n            ],\n            type: 'editreply'\n        }, interaction);\n    }\n}\n\n","size_bytes":1211},"src/commands/voice/unlock.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, interaction, args) => {\n    const perms = await client.checkBotPerms({\n        flags: [Discord.PermissionsBitField.Flags.ManageChannels],\n        perms: [Discord.PermissionsBitField.Flags.ManageChannels]\n    }, interaction)\n\n    if (perms == false) return;\n\n    const channel = interaction.member.voice.channel;\n    if (!channel) return client.errNormal({\n        error: `You're not in a voice channel!`,\n        type: 'editreply'\n    }, interaction);\n    var checkVoice = await client.checkVoice(interaction.guild, channel);\n    if (!checkVoice) {\n        return client.errNormal({\n            error: `You cannot edit this channel!`,\n            type: 'editreply'\n        }, interaction);\n    } else {\n        client.succNormal({\n            text: `The channel was succesfully unlocked!`,\n            fields: [\n                {\n                    name: `📘┆Channel`,\n                    value: `${channel} (${channel.name})`\n                }\n            ],\n            type: 'editreply'\n        }, interaction);\n\n        channel.permissionOverwrites.edit(interaction.guild.roles.cache.find(x => x.name === '@everyone'), {\n            Connect: true\n        });\n    }\n}\n\n","size_bytes":1249},"src/database/models/afk.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    User: String,\n    Message: {type: String, default: false}\n});\n\nmodule.exports = mongoose.model(\"afk\", Schema);","size_bytes":209},"src/database/models/badge.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    User: { type: String },\n    FLAGS: { type: Array }\n});\n\nmodule.exports = mongoose.model(\"badges\", Schema);","size_bytes":186},"src/database/models/birthday.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    User: String,\n    Birthday: String,\n});\n\nmodule.exports = mongoose.model(\"birthday\", Schema);","size_bytes":192},"src/database/models/birthdaychannels.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Channel: String,\n});\n\nmodule.exports = mongoose.model(\"birthdaychannels\", Schema);","size_bytes":181},"src/database/models/blacklist.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Words: Array\n});\n\nmodule.exports = mongoose.model(\"blacklist-words\", Schema);","size_bytes":176},"src/database/models/boostChannels.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Channel: String,\n});\n\nmodule.exports = mongoose.model(\"boostChannels\", Schema);","size_bytes":178},"src/database/models/boostMessage.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    boostMessage: String,\n    unboostMessage: String,\n});\n\nmodule.exports = mongoose.model(\"boostMessage\", Schema);","size_bytes":210},"src/database/models/channelList.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Channels: Array\n});\n\nmodule.exports = mongoose.model(\"channellist\", Schema);","size_bytes":175},"src/database/models/chatbot-channel.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Channel: String,\n});\n\nmodule.exports = mongoose.model(\"chatbot\", Schema);","size_bytes":172},"src/database/models/count.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    User: String,\n    Count: Number,\n});\n\nmodule.exports = mongoose.model(\"count\", Schema);","size_bytes":186},"src/database/models/countChannel.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Channel: String,\n    Mode: { type: String, default: \"hard\" },\n});\n\nmodule.exports = mongoose.model(\"countChannel\", Schema);","size_bytes":222},"src/database/models/customCommand.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Name: String,\n    Responce: String,\n});\n\nmodule.exports = mongoose.model(\"customCommands\", Schema);","size_bytes":198},"src/database/models/customCommandAdvanced.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Name: String,\n    Responce: String,\n    Action: { type: String, default: \"Normal\" },\n});\n\nmodule.exports = mongoose.model(\"customCommandsAdvanced\", Schema);","size_bytes":255},"src/database/models/developers.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Action: String,\n    Date: String\n});\n\nmodule.exports = mongoose.model(\"developers\", Schema);","size_bytes":172},"src/database/models/economy.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    User: String,\n    Money: Number,\n    Bank: Number\n});\n\nmodule.exports = mongoose.model(\"economy\", Schema);","size_bytes":205},"src/database/models/economyItems.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    User: String,\n    FishingRod: { type: Boolean, default: false },\n    FishingRodUsage: { type: Number, default: 0 },\n});\n\nmodule.exports = mongoose.model(\"economyItems\", Schema);","size_bytes":276},"src/database/models/economyStore.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Role: String,\n    Amount: Number\n});\n\nmodule.exports = mongoose.model(\"economyStore\", Schema);","size_bytes":193},"src/database/models/economyTimeout.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    User: String,\n    Beg: String,\n    Crime: String,\n    Daily: String,\n    Weekly: String,\n    Monthly: String,\n    Hourly: String,\n    Work: String,\n    Rob: String,\n    Fish: String,\n    Hunt: String,\n    Yearly: String,\n    Present: String\n});\n\nmodule.exports = mongoose.model(\"economytimeout\", Schema);","size_bytes":403},"src/database/models/family.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    User: String,\n    Parent: { type: Array, default: null },\n    Partner: { type: String, default: null },\n    Children: { type: Array, default: null },\n});\n\nmodule.exports = mongoose.model(\"family\", Schema);","size_bytes":304},"src/database/models/functions.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Levels: { type: Boolean, default: false },\n    Beta: { type: Boolean, default: false },\n    AntiAlt: { type: Boolean, default: false },\n    AntiSpam: { type: Boolean, default: false },\n    AntiCaps: { type: Boolean, default: false },\n    AntiInvite: { type: Boolean, default: false },\n    AntiLinks: { type: Boolean, default: false },\n    Prefix: String,\n    Color: String \n});\n\nmodule.exports = mongoose.model(\"functions\", Schema);","size_bytes":531},"src/database/models/giveaways.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    messageId: String,\n    channelId: String,\n    guildId: String,\n    startAt: Number,\n    endAt: Number,\n    ended: Boolean,\n    winnerCount: Number,\n    prize: String,\n    messages: {\n        giveaway: String,\n        giveawayEnded: String,\n        inviteToParticipate: String,\n        drawing: String,\n        dropMessage: String,\n        winMessage: mongoose.Mixed,\n        embedFooter: mongoose.Mixed,\n        noWinner: String,\n        winners: String,\n        endedAt: String,\n        hostedBy: String\n    },\n    thumbnail: String,\n    hostedBy: String,\n    winnerIds: { type: [String], default: undefined },\n    reaction: mongoose.Mixed,\n    botsCanWin: Boolean,\n    embedColor: mongoose.Mixed,\n    embedColorEnd: mongoose.Mixed,\n    exemptPermissions: { type: [], default: undefined },\n    exemptMembers: String,\n    bonusEntries: String,\n    extraData: mongoose.Mixed,\n    lastChance: {\n        enabled: Boolean,\n        content: String,\n        threshold: Number,\n        embedColor: mongoose.Mixed\n    },\n    pauseOptions: {\n        isPaused: Boolean,\n        content: String,\n        unPauseAfter: Number,\n        embedColor: mongoose.Mixed,\n        durationAfterPause: Number\n    },\n    isDrop: Boolean,\n    allowedMentions: {\n        parse: { type: [String], default: undefined },\n        users: { type: [String], default: undefined },\n        roles: { type: [String], default: undefined }\n    }\n});\n\nmodule.exports = mongoose.model(\"giveaways\", Schema);","size_bytes":1545},"src/database/models/guessNumber.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Channel: String,\n    Number: { type: String, default: \"5126\" },\n});\n\nmodule.exports = mongoose.model(\"guessNumber\", Schema);","size_bytes":223},"src/database/models/guessWord.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Channel: String,\n    Word: { type: String, default: \"start\" },\n});\n\nmodule.exports = mongoose.model(\"guessWord\", Schema);","size_bytes":220},"src/database/models/inviteBy.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    inviteUser: String,\n    User: String,\n});\n\nmodule.exports = mongoose.model(\"inviteBy\", Schema);","size_bytes":194},"src/database/models/inviteMessages.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    inviteJoin: String,\n    inviteLeave: String\n});\n\nmodule.exports = mongoose.model(\"inviteMessages\", Schema);","size_bytes":206},"src/database/models/inviteRewards.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Invites: Number,\n    Role: String,\n});\n\nmodule.exports = mongoose.model(\"inviteRewards\", Schema);","size_bytes":196},"src/database/models/invites.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    User: String,\n    Invites: Number,\n    Total: Number,\n    Left: Number\n});\n\nmodule.exports = mongoose.model(\"invites\", Schema);","size_bytes":226},"src/database/models/joinRole.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Role: String,\n});\n\nmodule.exports = mongoose.model(\"joinRole\", Schema);","size_bytes":170},"src/database/models/leaveChannels.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Channel: String,\n});\n\nmodule.exports = mongoose.model(\"leaveChannels\", Schema);","size_bytes":178},"src/database/models/levelChannels.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Channel: String,\n});\n\nmodule.exports = mongoose.model(\"levelChannels\", Schema);","size_bytes":178},"src/database/models/levelMessages.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Message: String\n});\n\nmodule.exports = mongoose.model(\"levelmessage\", Schema);","size_bytes":176},"src/database/models/levelRewards.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Level: Number,\n    Role: String,\n});\n\nmodule.exports = mongoose.model(\"levelRewards\", Schema);","size_bytes":193},"src/database/models/levels.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    userID: { type: String },\n    guildID: { type: String },\n    xp: { type: Number, default: 0 },\n    level: { type: Number, default: 0 },\n    lastUpdated: { type: Date, default: new Date() }\n});\n\nmodule.exports = mongoose.model(\"Levels\", Schema);","size_bytes":324},"src/database/models/logChannels.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Channel: String,\n});\n\nmodule.exports = mongoose.model(\"logChannels\", Schema);","size_bytes":176},"src/database/models/messageRewards.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Messages: Number,\n    Role: String,\n});\n\nmodule.exports = mongoose.model(\"messageRewards\", Schema);","size_bytes":198},"src/database/models/messages.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    User: String,\n    Messages: Number,\n});\n\nmodule.exports = mongoose.model(\"messages\", Schema);","size_bytes":192},"src/database/models/music.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Channel: String\n});\n\nmodule.exports = mongoose.model(\"music\", Schema);","size_bytes":169},"src/database/models/notes.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    User: String,\n    Code: String,\n    Note: String\n});\n\nmodule.exports = mongoose.model(\"notes\", Schema);","size_bytes":202},"src/database/models/privatechannels.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Category: String,\n    ChannelName: String,\n    ChannelCount: { type: Number, default: 0 }\n});\n\nmodule.exports = mongoose.model(\"privatechannels\", Schema);","size_bytes":253},"src/database/models/profile.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    User: String,\n    Gender: { type: String, default: \"\" },\n    Age: { type: String, default: \"\" },\n    Orgin: { type: String, default: \"\" },\n    Pets: Array,\n    Songs: Array,\n    Movies: Array,\n    Actors: Array,\n    Artists: Array,\n    Food: Array,\n    Hobbys: Array,\n    Status: { type: String, default: \"\" },\n    Aboutme: { type: String, default: \"\" },\n    Color: { type: String, default: \"\" },\n    Birthday: { type: String, default: \"\" },\n});\n\nmodule.exports = mongoose.model(\"Profile\", Schema);","size_bytes":578},"src/database/models/radios.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Name: String,\n    Url: String\n});\n\nmodule.exports = mongoose.model(\"radios\", Schema);","size_bytes":184},"src/database/models/reactionRoles.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Message: String,\n    Category: String,\n    Roles: Object\n});\n\nmodule.exports = mongoose.model(\"reactionRoles\", Schema);","size_bytes":218},"src/database/models/reminder.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    User: String,\n    Text: String,\n    endTime: Number\n});\n\nmodule.exports = mongoose.model(\"reminder\", Schema);","size_bytes":189},"src/database/models/reviewChannels.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Channel: String,\n});\n\nmodule.exports = mongoose.model(\"reviewChannels\", Schema);","size_bytes":179},"src/database/models/starboardChannels.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Channel: String,\n});\n\nmodule.exports = mongoose.model(\"starboardChannels\", Schema);","size_bytes":182},"src/database/models/stats.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Members: String,\n    Boost: String,\n    Channels: String,\n    Roles: String,\n    Emojis: String,\n    AnimatedEmojis: String,\n    NewsChannels: String,\n    StageChannels: String,\n    StaticEmojis: String,\n    TextChannels: String,\n    BoostTier: String,\n    VoiceChannels: String,\n    Time: String,\n    TimeZone: String,\n    ChannelTemplate: String,\n});\n\nmodule.exports = mongoose.model(\"stats\", Schema);","size_bytes":502},"src/database/models/stickymessages.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Channel: String,\n    Content: String,\n    LastMessage: String,\n});\n\nmodule.exports = mongoose.model(\"stickymessages\", Schema);","size_bytes":225},"src/database/models/suggestionChannels.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Channel: String,\n});\n\nmodule.exports = mongoose.model(\"suggestionChannels\", Schema);","size_bytes":183},"src/database/models/tempban.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    guildId: String,\n    userId: String,\n    expires: Date\n});\n\nmodule.exports = mongoose.model(\"tempban\", Schema);","size_bytes":191},"src/database/models/thanks.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    User: String,\n    UserTag: String,\n    Received: Number\n});\n\nmodule.exports = mongoose.model(\"thanks\", Schema);","size_bytes":191},"src/database/models/thanksAuthor.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    User: String,\n    Author: String\n});\n\nmodule.exports = mongoose.model(\"thanksAuthor\", Schema);","size_bytes":174},"src/database/models/ticketChannels.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    TicketID: Number,\n    channelID: String,\n    creator: String,\n    claimed: String,\n    resolved: { type: Boolean, default: false }\n});\n\nmodule.exports = mongoose.model(\"ticketChannels\", Schema);","size_bytes":293},"src/database/models/ticketMessage.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    openTicket: String,\n    dmMessage: String\n});\n\nmodule.exports = mongoose.model(\"ticketMessage\", Schema);","size_bytes":203},"src/database/models/tickets.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Category: String,\n    Role: String,\n    Channel: String,\n    Logs: String,\n    TicketCount: { type: Number, default: 0 },\n});\n\nmodule.exports = mongoose.model(\"tickets\", Schema);","size_bytes":277},"src/database/models/userBans.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    User: String,\n});\n\nmodule.exports = mongoose.model(\"userBans\", Schema);","size_bytes":151},"src/database/models/verify.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Channel: String,\n    Role: String,\n    Logs: String,\n});\n\nmodule.exports = mongoose.model(\"verify\", Schema);","size_bytes":207},"src/database/models/voice.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Category: String,\n    Channel: String,\n    ChannelName: String,\n    ChannelCount: { type: Number, default: 0 }\n});\n\nmodule.exports = mongoose.model(\"voice\", Schema);","size_bytes":264},"src/database/models/voiceChannels.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Channel: String,\n});\n\nmodule.exports = mongoose.model(\"voiceChannels\", Schema);","size_bytes":178},"src/database/models/votecredits.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    User: String,\n    Credits: Number,\n    Unlimited: Boolean\n});\n\nmodule.exports = mongoose.model(\"votecredits\", Schema);","size_bytes":198},"src/database/models/warnCase.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Case: Number\n});\n\nmodule.exports = mongoose.model(\"warnCase\", Schema);","size_bytes":169},"src/database/models/warnings.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    User: String,\n    Warnings: [Object]\n});\n\nmodule.exports = mongoose.model(\"warnings\", Schema);","size_bytes":193},"src/database/models/welcomeChannels.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Channel: String,\n});\n\nmodule.exports = mongoose.model(\"welcomeChannels\", Schema);","size_bytes":180},"src/database/models/wordsnake.js":{"content":"const mongoose = require('mongoose');\n\nconst Schema = new mongoose.Schema({\n    Guild: String,\n    Channel: String,\n    lastWord: String,\n});\n\nmodule.exports = mongoose.model(\"wordsnake\", Schema);","size_bytes":196},"src/events/channel/channelCreate.js":{"content":"const discord = require('discord.js');\n\nmodule.exports = async (client, channel) => {\n    let types = {\n        0: \"Text Channel\",\n        2: \"Voice Channel\",\n        4: \"Category\",\n        5: \"News Channel\",\n        10: \"News Thread\",\n        11: \"Public Thread\",\n        12: \"Private Thread\",\n        13: \"Stage Channel\",\n        14: \"Category\",\n    }\n\n    const logsChannel = await client.getLogs(channel.guild.id);\n    if (!logsChannel) return;\n\n    console.log(channel.type)\n    client.embed({\n        title: `🔧・Channel created`,\n        desc: `A channel has been created`,\n        fields: [\n            {\n                name: `> Name`,\n                value: `- ${channel.name}`\n            },\n            {\n                name: `> ID`,\n                value: `- ${channel.id}`\n            },\n            {\n                name: `> Category`,\n                value: `- ${channel.parent}`\n            },\n            {\n                name: `> Channel`,\n                value: `- <#${channel.id}>`\n            },\n            {\n                name: `> Type`,\n                value: `- ${types[channel.type]}`\n            }\n        ]\n    }, logsChannel).catch(() => { })\n};","size_bytes":1183},"src/events/channel/channelDelete.js":{"content":"const discord = require('discord.js');\n\nconst ticketChannels = require(\"../../database/models/ticketChannels\");\n\nmodule.exports = async (client, channel) => {\n    let types = {\n        0: \"Text Channel\",\n        2: \"Voice Channel\",\n        4: \"Category\",\n        5: \"News Channel\",\n        10: \"News Thread\",\n        11: \"Public Thread\",\n        12: \"Private Thread\",\n        13: \"Stage Channel\",\n        14: \"Category\",\n    }\n    \n    const logsChannel = await client.getLogs(channel.guild.id);\n    if (!logsChannel) return;\n\n    client.embed({\n        title: `🔧・Channel deleted`,\n        desc: `A channel has been deleted`,\n        fields: [\n            {\n                name: `> Name`,\n                value: `- ${channel.name}`\n            },\n            {\n                name: `> ID`,\n                value: `- ${channel.id}`\n            },\n            {\n                name: `> Category`,\n                value: `- ${channel.parent}`\n            },\n            {\n                name: `> Type`,\n                value: `- ${types[channel.type]}`\n            }\n        ]\n    }, logsChannel).catch(() => { })\n\n    try {\n        ticketChannels.findOne({ Guild: channel.guild.id, channelID: channel.id }, async (err, data) => {\n            if (data) {\n                var remove = await ticketChannels.deleteOne({ Guild: channel.guild.id, channelID: channel.id });\n            }\n        })\n    }\n    catch { }\n};","size_bytes":1421},"src/events/channel/channelNameUpdate.js":{"content":"const discord = require('discord.js');\n\nmodule.exports = async (client, channel, oldName, newName) => {\n    let types = {\n        0: \"Text Channel\",\n        2: \"Voice Channel\",\n        4: \"Category\",\n        5: \"News Channel\",\n        10: \"News Thread\",\n        11: \"Public Thread\",\n        12: \"Private Thread\",\n        13: \"Stage Channel\",\n        14: \"Category\",\n    }\n\n    const logsChannel = await client.getLogs(channel.guild.id);\n    if (!logsChannel) return;\n\n    client.embed({\n        title: `🔧・Channel name adjusted`,\n        desc: `One channel name modified`,\n        fields: [\n            {\n                name: `> Old Name`,\n                value: `- ${oldName}`\n            },\n            {\n                name: `> New Name`,\n                value: `- ${newName}`\n            },\n            {\n                name: `> ID`,\n                value: `- ${channel.id}`\n            },\n            {\n                name: `> Category`,\n                value: `- ${channel.parent}`\n            },\n            {\n                name: `> Channel`,\n                value: `- <#${channel.id}>`\n            },\n            {\n                name: `> Type`,\n                value: `- ${types[channel.type]}`\n            }\n        ]\n    }, logsChannel).catch(() => { })\n};","size_bytes":1278},"src/events/channel/channelPinsUpdate.js":{"content":"const discord = require('discord.js');\n\nmodule.exports = async (client, channel, time) => {\n    let types = {\n        0: \"Text Channel\",\n        2: \"Voice Channel\",\n        4: \"Category\",\n        5: \"News Channel\",\n        10: \"News Thread\",\n        11: \"Public Thread\",\n        12: \"Private Thread\",\n        13: \"Stage Channel\",\n        14: \"Category\",\n    }\n\n    const logsChannel = await client.getLogs(channel.guild.id);\n    if (!logsChannel) return;\n\n    client.embed({\n        title: `🔧・Channel pins updated`,\n        desc: `Channel pins have been updated`,\n        fields: [\n            {\n                name: `> Name`,\n                value: `- ${channel.name}`\n            },\n            {\n                name: `> ID`,\n                value: `- ${channel.id}`\n            },\n            {\n                name: `> Category`,\n                value: `- ${channel.parent}`\n            },\n            {\n                name: `> Channel`,\n                value: `- <#${channel.id}>`\n            },\n            {\n                name: `> Type`,\n                value: `- ${types[channel.type]}`\n            },\n            {\n                name: `> Pinned at`,\n                value: `- <t:${(time / 1000).toFixed(0)}>`\n            }\n        ]\n    }, logsChannel).catch(() => { })\n};","size_bytes":1293},"src/events/channel/channelTopicUpdate.js":{"content":"const discord = require('discord.js');\n\nmodule.exports = async (client, channel, oldTopic, newTopic) => {\n    let types = {\n        0: \"Text Channel\",\n        2: \"Voice Channel\",\n        4: \"Category\",\n        5: \"News Channel\",\n        10: \"News Thread\",\n        11: \"Public Thread\",\n        12: \"Private Thread\",\n        13: \"Stage Channel\",\n        14: \"Category\",\n    }\n\n    const logsChannel = await client.getLogs(channel.guild.id);\n    if (!logsChannel) return;\n\n    client.embed({\n        title: `🔧・Channel topic adjusted`,\n        desc: `One channel topic modified`,\n        fields: [\n            {\n                name: `> Old Topic`,\n                value: `- ${oldTopic}`\n            },\n            {\n                name: `> New Topic`,\n                value: `- ${newTopic}`\n            },\n            {\n                name: `> Name`,\n                value: `- ${channel.name}`\n            },\n            {\n                name: `> ID`,\n                value: `- ${channel.id}`\n            },\n            {\n                name: `> Category`,\n                value: `- ${channel.parent}`\n            },\n            {\n                name: `> Channel`,\n                value: `- <#${channel.id}>`\n            },\n            {\n                name: `> Type`,\n                value: `- ${types[channel.type]}`\n            }\n        ]\n    }, logsChannel).catch(() => { })\n};","size_bytes":1390},"src/events/client/clientReady.js":{"content":"const Discord = require('discord.js');\nconst chalk = require('chalk');\nconst { random } = require('mathjs');\n\nmodule.exports = async (client) => {\n    const startLogs = new Discord.WebhookClient({\n        id: client.webhooks.startLogs.id,\n        token: client.webhooks.startLogs.token,\n    });\n\n    console.log(`\\u001b[0m`);\n    console.log(chalk.blue(chalk.bold(`System`)), (chalk.white(`>>`)), chalk.red(`Shard #${client.shard.ids[0] + 1}`), chalk.green(`is ready!`))\n    console.log(chalk.blue(chalk.bold(`Bot`)), (chalk.white(`>>`)), chalk.green(`Started on`), chalk.red(`${client.guilds.cache.size}`), chalk.green(`servers!`))\n\n    let embed = new Discord.EmbedBuilder()\n        .setTitle(`🆙・Finishing shard`)\n        .setDescription(`A shard just finished`)\n        .addFields(\n            { name: \"🆔┆ID\", value: `${client.shard.ids[0] + 1}/${client.options.shardCount}`, inline: true },\n            { name: \"📃┆State\", value: `Ready`, inline: true },\n        )\n        .setColor(client.config.colors.normal)\n    startLogs.send({\n        username: 'Bot Logs',\n        embeds: [embed],\n    });\n\n    setInterval(async function () {\n        const promises = [\n            client.shard.fetchClientValues('guilds.cache.size'),\n        ];\n        return Promise.all(promises)\n            .then(results => {\n                const totalGuilds = results[0].reduce((acc, guildCount) => acc + guildCount, 0);\n                let statuttext;\n                if (process.env.DISCORD_STATUS) {\n                    statuttext = process.env.DISCORD_STATUS.split(', ');\n                } else {\n                    statuttext = [\n                        `・❓┆/help`,\n                        `・💻┆${totalGuilds} servers`,\n                        `・📨┆discord.gg/corwindev`,\n                        `・🎉┆400+ commands`,\n                        `・🏷️┆Version ${require(`${process.cwd()}/package.json`).version}`\n                    ];\n                }\n                const randomText = statuttext[Math.floor(Math.random() * statuttext.length)];\n                client.user.setPresence({ activities: [{ name: randomText, type: Discord.ActivityType.Playing }], status: 'online' });\n            })\n    }, 50000)\n\n    client.player.init(client.user.id);\n}\n\n","size_bytes":2287},"src/events/client/error.js":{"content":"module.exports = async (e) => {\n    console.error(e);\n}","size_bytes":55},"src/events/client/errorCreate.js":{"content":"const Discord = require('discord.js');\nconst generator = require('generate-password');\n\nmodule.exports = (client, err, command, interaction) => {\n    console.log(err);\n    const password = generator.generate({\n        length: 10,\n        numbers: true\n    });\n\n    const errorlog = new Discord.WebhookClient({\n        id: client.webhooks.errorLogs.id,\n        token: client.webhooks.errorLogs.token,\n    });\n\n    let embed = new Discord.EmbedBuilder()\n        .setTitle(`🚨・${password}`)\n        .addFields(\n            { name: \"✅┇Guild\", value: `${interaction.guild.name} (${interaction.guild.id})`},\n            { name: `💻┇Command`, value: `${command}`},\n            { name: `💬┇Error`, value: `\\`\\`\\`${err}\\`\\`\\``},\n            { name: `📃┇Stack error`, value: `\\`\\`\\`${err.stack.substr(0, 1018)}\\`\\`\\``},\n        )\n        .setColor(client.config.colors.normal)\n    errorlog.send({\n        username: `Bot errors`,\n        embeds: [embed],\n\n    }).catch(error => { console.log(error) })\n\n    let row = new Discord.ActionRowBuilder()\n        .addComponents(\n            new Discord.ButtonBuilder()\n                .setLabel(\"Support server\")\n                .setURL(client.config.discord.serverInvite)\n                .setStyle(Discord.ButtonStyle.Link),\n        );\n\n    client.embed({\n        title: `${client.emotes.normal.error}・Error`,\n        desc: `There was an error executing this command`,\n        color: client.config.colors.error,\n        fields: [\n            {\n                name: `Error code`,\n                value: `\\`${password}\\``,\n                inline: true,\n            },\n            {\n                name: `What now?`,\n                value: `You can contact the developers by joining the support server`,\n                inline: true,\n            }\n        ],\n        components: [row],\n        type: 'editreply'\n    }, interaction).catch(() => {\n        client.embed({\n            title: `${client.emotes.normal.error}・Error`,\n            desc: `There was an error executing this command`,\n            color: client.config.colors.error,\n            fields: [\n                {\n                    name: `Error code`,\n                    value: `\\`${password}\\``,\n                    inline: true,\n                },\n                {\n                    name: `What now?`,\n                    value: `You can contact the developers by joining the support server`,\n                    inline: true,\n                }\n            ],\n            components: [row],\n            type: 'editreply'\n        }, interaction)\n    })\n};","size_bytes":2581},"src/events/client/guildCreate.js":{"content":"const Discord = require('discord.js');\n\nconst Functions = require(\"../../database/models/functions\");\n\nmodule.exports = async (client, guild) => {\n    const webhookClient = new Discord.WebhookClient({\n        id: client.webhooks.serverLogs.id,\n        token: client.webhooks.serverLogs.token,\n    });\n\n    if (guild == undefined) return;\n\n    new Functions({\n        Guild: guild.id,\n        Prefix: client.config.discord.prefix\n    }).save();\n\n    try {\n        const promises = [\n            client.shard.broadcastEval(client => client.guilds.cache.size),\n            client.shard.broadcastEval(client => client.guilds.cache.reduce((acc, guild) => acc + guild.memberCount, 0)),\n        ];\n        Promise.all(promises)\n            .then(async (results) => {\n                const totalGuilds = results[0].reduce((acc, guildCount) => acc + guildCount, 0);\n                const embed = new Discord.EmbedBuilder()\n                    .setTitle(\"🟢・Added to a new server!\")\n                    .addFields(\n                        { name: \"Total servers:\", value: `${totalGuilds}`, inline: true },\n                        { name: \"Server name\", value: `${guild.name}`, inline: true },\n                        { name: \"Server ID\", value: `${guild.id}`, inline: true },\n                        { name: \"Server members\", value: `${guild.memberCount}`, inline: true },\n                        { name: \"Server owner\", value: `<@!${guild.ownerId}> (${guild.ownerId})`, inline: true },\n                    )\n                    .setThumbnail(\"https://cdn.discordapp.com/attachments/843487478881976381/852419422392156210/BotPartyEmote.png\")\n                    .setColor(client.config.colors.normal)\n                webhookClient.send({\n                    username: 'Bot Logs',\n                    avatarURL: client.user.avatarURL(),\n                    embeds: [embed],\n                });\n            })\n\n        let defaultChannel = \"\";\n        guild.channels.cache.forEach((channel) => {\n            if (channel.type == Discord.ChannelType.GuildText && defaultChannel == \"\") {\n                if (channel.permissionsFor(guild.members.me).has(Discord.PermissionFlagsBits.SendMessages)) {\n                    defaultChannel = channel;\n                }\n            }\n        })\n\n        let row = new Discord.ActionRowBuilder()\n            .addComponents(\n                new Discord.ButtonBuilder()\n                    .setLabel(\"Invite\")\n                    .setURL(client.config.discord.botInvite)\n                    .setStyle(Discord.ButtonStyle.Link),\n\n                new Discord.ButtonBuilder()\n                    .setLabel(\"Support server\")\n                    .setURL(client.config.discord.serverInvite)\n                    .setStyle(Discord.ButtonStyle.Link),\n            );\n\n        client.embed({\n            title: \"Thanks for inviting the bot!\",\n            image: \"https://cdn.discordapp.com/attachments/843487478881976381/874694194474668052/bot_banner_invite.jpg\",\n            fields: [{\n                name: \"❓┆How to setup?\",\n                value: 'The default prefix = \\`/\\` \\nTo run setups with Bot run \\`/setup\\`',\n                inline: false,\n            },\n            {\n                name: \"☎️┆I need help what now?\",\n                value: `You can DM <@755297485328482356> for support or joining the [[Support server]](${client.config.discord.serverInvite})`,\n                inline: false,\n            },\n            {\n                name: \"💻┆What are the commands?\",\n                value: 'See that list of commands by doing \\`/help\\`',\n                inline: false,\n            },\n            {\n                name: \"📨┆Invite the bot!\",\n                value: `Invite the bot to click [[HERE]](${client.config.discord.botInvite})`,\n                inline: false,\n            },\n            ],\n            components: [row], \n        }, defaultChannel)\n    }\n    catch (err) {\n        console.log(err);\n    }\n\n\n};","size_bytes":3970},"src/events/client/guildDelete.js":{"content":"const discord = require('discord.js');\nconst fs = require('fs');\n\nconst Schema = require(\"../../database/models/afk\");\nconst Schema3 = require(\"../../database/models/customCommandAdvanced\");\nconst Schema4 = require(\"../../database/models/birthday\");\nconst Schema5 = require(\"../../database/models/blacklist\");\nconst Schema6 = require(\"../../database/models/channelList\");\nconst Schema7 = require(\"../../database/models/chatbot-channel\");\nconst Schema8 = require(\"../../database/models/count\");\nconst Schema9 = require(\"../../database/models/countChannel\");\nconst Schema10 = require(\"../../database/models/customCommand\");\nconst Schema11 = require(\"../../database/models/economy\");\nconst Schema12 = require(\"../../database/models/economyTimeout\");\nconst Schema13 = require(\"../../database/models/family\");\nconst Schema14 = require(\"../../database/models/functions\");\nconst Schema15 = require(\"../../database/models/guessNumber\");\nconst Schema16 = require(\"../../database/models/guessWord\");\nconst Schema17 = require(\"../../database/models/levelChannels\");\nconst Schema18 = require(\"../../database/models/levelRewards\");\nconst Schema19 = require(\"../../database/models/logChannels\");\nconst Schema20 = require(\"../../database/models/messages\");\nconst Schema21 = require(\"../../database/models/music\");\nconst Schema23 = require(\"../../database/models/notes\");\nconst Schema25 = require(\"../../database/models/privatechannels\");\nconst Schema27 = require(\"../../database/models/reactionRoles\");\nconst Schema28 = require(\"../../database/models/reviewChannels\");\nconst Schema29 = require(\"../../database/models/stats\");\nconst Schema30 = require(\"../../database/models/suggestionChannels\");\nconst Schema31 = require(\"../../database/models/ticketChannels\");\nconst Schema32 = require(\"../../database/models/ticketMessage\");\nconst Schema34 = require(\"../../database/models/tickets\");\nconst Schema35 = require(\"../../database/models/verify\");\nconst Schema36 = require(\"../../database/models/voice\");\nconst Schema37 = require(\"../../database/models/voiceChannels\");\nconst Schema38 = require(\"../../database/models/warnings\");\nconst Schema39 = require(\"../../database/models/wordsnake\");\nconst Schema40 = require(\"../../database/models/messageRewards\");\n\nmodule.exports = async (client, guild) => {\n    const kickLogs = new discord.WebhookClient({\n        id: client.webhooks.serverLogs2.id,\n        token: client.webhooks.serverLogs2.token,\n    });\n\n    if (guild.name == undefined) return;\n\n    const promises = [\n        client.shard.broadcastEval(client => client.guilds.cache.size),\n        client.shard.broadcastEval(client => client.guilds.cache.reduce((acc, guild) => acc + guild.memberCount, 0)),\n    ];\n    Promise.all(promises)\n        .then(async (results) => {\n            const totalGuilds = results[0].reduce((acc, guildCount) => acc + guildCount, 0);\n\n            const embed = new discord.EmbedBuilder()\n                .setTitle(\"🔴・Removed from a server!\")\n                .addFields(\n                    { name: \"Total servers:\", value: `${totalGuilds}`, inline: true },\n                    { name: \"Server name\", value: `${guild.name}`, inline: true },\n                    { name: \"Server ID\", value: `${guild.id}`, inline: true },\n                    { name: \"Server members\", value: `${guild.memberCount}`, inline: true },\n                    { name: \"Server owner\", value: `<@!${guild.ownerId}> (${guild.ownerId})`, inline: true },\n                )\n                .setThumbnail(\"https://cdn.discordapp.com/attachments/843487478881976381/852419424895631370/BotSadEmote.png\")\n                .setColor(client.config.colors.normal)\n            kickLogs.send({\n                username: 'Bot Logs',\n                avatarURL: client.user.avatarURL(),\n                embeds: [embed],\n            });\n        })\n\n            var remove = await Schema.deleteMany({ Guild: guild.id });\n            var remove = await Schema3.deleteMany({ Guild: guild.id });\n            var remove = await Schema4.deleteMany({ Guild: guild.id });\n            var remove = await Schema5.deleteMany({ Guild: guild.id });\n            var remove = await Schema6.deleteMany({ Guild: guild.id });\n            var remove = await Schema7.deleteMany({ Guild: guild.id });\n            var remove = await Schema8.deleteMany({ Guild: guild.id });\n            var remove = await Schema9.deleteMany({ Guild: guild.id });\n            var remove = await Schema10.deleteMany({ Guild: guild.id });\n            var remove = await Schema11.deleteMany({ Guild: guild.id });\n            var remove = await Schema12.deleteMany({ Guild: guild.id });\n            var remove = await Schema13.deleteMany({ Guild: guild.id });\n            var remove = await Schema14.deleteMany({ Guild: guild.id });\n            var remove = await Schema15.deleteMany({ Guild: guild.id });\n            var remove = await Schema16.deleteMany({ Guild: guild.id });\n            var remove = await Schema17.deleteMany({ Guild: guild.id });\n            var remove = await Schema18.deleteMany({ Guild: guild.id });\n            var remove = await Schema19.deleteMany({ Guild: guild.id });\n            var remove = await Schema20.deleteMany({ Guild: guild.id });\n            var remove = await Schema21.deleteMany({ Guild: guild.id });\n            var remove = await Schema23.deleteMany({ Guild: guild.id });\n            var remove = await Schema25.deleteMany({ Guild: guild.id });\n            var remove = await Schema27.deleteMany({ Guild: guild.id });\n            var remove = await Schema28.deleteMany({ Guild: guild.id });\n            var remove = await Schema29.deleteMany({ Guild: guild.id });\n            var remove = await Schema30.deleteMany({ Guild: guild.id });\n            var remove = await Schema31.deleteMany({ Guild: guild.id });\n            var remove = await Schema32.deleteMany({ Guild: guild.id });\n            var remove = await Schema34.deleteMany({ Guild: guild.id });\n            var remove = await Schema35.deleteMany({ Guild: guild.id });\n            var remove = await Schema36.deleteMany({ Guild: guild.id });\n            var remove = await Schema37.deleteMany({ Guild: guild.id });\n            var remove = await Schema38.deleteMany({ Guild: guild.id });\n            var remove = await Schema39.deleteMany({ Guild: guild.id });\n            var remove = await Schema40.deleteMany({ Guild: guild.id });\n};","size_bytes":6370},"src/events/client/interactionCreate.js":{"content":"const Discord = require('discord.js');\nconst Captcha = require(\"@haileybot/captcha-generator\");\n\nconst reactionSchema = require(\"../../database/models/reactionRoles\");\nconst banSchema = require(\"../../database/models/userBans\");\nconst verify = require(\"../../database/models/verify\");\nconst Commands = require(\"../../database/models/customCommand\");\nconst CommandsSchema = require(\"../../database/models/customCommandAdvanced\");\nmodule.exports = async (client, interaction) => {\n    // Commands\n    if (interaction.isCommand() || interaction.isUserContextMenuCommand()) {\n        banSchema.findOne({ User: interaction.user.id }, async (err, data) => {\n            if (data) {\n                return client.errNormal({\n                    error: \"You have been banned by the developers of this bot\",\n                    type: 'ephemeral'\n                }, interaction);\n            }\n            else {\n                const cmd = client.commands.get(interaction.commandName);\n                if (!cmd){\n                    const cmdd = await Commands.findOne({\n                        Guild: interaction.guild.id,\n                        Name: interaction.commandName,\n                    });\n                    if (cmdd) {\n                        return interaction.channel.send({ content: cmdd.Responce });\n                    }\n\n                    const cmdx = await CommandsSchema.findOne({\n                        Guild: interaction.guild.id,\n                        Name: interaction.commandName,\n                    });\n                    if (cmdx) {\n                        // Remove interaction\n                        if (cmdx.Action == \"Normal\") {\n                            return interaction.reply({ content: cmdx.Responce });\n                        } else if (cmdx.Action == \"Embed\") {\n                            return client.simpleEmbed(\n                                {\n                                    desc: `${cmdx.Responce}`,\n                                    type: 'reply'\n                                },\n                                interaction,\n                            );\n                        } else if (cmdx.Action == \"DM\") {\n                            await interaction.deferReply({ ephemeral: true });\n                            interaction.editReply({ content: \"I have sent you something in your DMs\" });\n                            return interaction.user.send({ content: cmdx.Responce }).catch((e) => {\n                                client.errNormal(\n                                    {\n                                        error: \"I can't DM you, maybe you have DM turned off!\",\n                                        type: 'ephemeral'\n                                    },\n                                    interaction,\n                                );\n                            });\n                        }\n                    }\n                }\n                if (interaction.options._subcommand !== null && interaction.options.getSubcommand() == \"help\") {\n                    const commands = interaction.client.commands.filter(x => x.data.name == interaction.commandName).map((x) => x.data.options.map((c) => '`' + c.name + '` - ' + c.description).join(\"\\n\"));\n\n                    return client.embed({\n                        title: `❓・Help panel`,\n                        desc: `Get help with the commands in \\`${interaction.commandName}\\` \\n\\n${commands}`,\n                        type: 'reply'\n                    }, interaction)\n                }\n\n                if(cmd) cmd.run(client, interaction, interaction.options._hoistedOptions).catch(err => {\n                    client.emit(\"errorCreate\", err, interaction.commandName, interaction)\n                })\n            }\n        })\n    }\n\n    // Verify system\n    if (interaction.isButton() && interaction.customId == \"Bot_verify\") {\n        const data = await verify.findOne({ Guild: interaction.guild.id, Channel: interaction.channel.id });\n        if (data) {\n            let captcha = new Captcha();\n\n            try {\n                var image = new Discord.AttachmentBuilder(captcha.JPEGStream, {name:\"captcha.jpeg\"});\n\n                interaction.reply({ files: [image], fetchReply: true }).then(function (msg) {\n                    const filter = s => s.author.id == interaction.user.id;\n\n                    interaction.channel.awaitMessages({ filter, max: 1 }).then(response => {\n                        if (response.first().content === captcha.value) {\n                            response.first().delete();\n                            msg.delete();\n\n                            client.succNormal({\n                                text: \"You have been successfully verified!\"\n                            }, interaction.user).catch(error => { })\n\n                            var verifyUser = interaction.guild.members.cache.get(interaction.user.id);\n                            verifyUser.roles.add(data.Role);\n                        }\n                        else {\n                            response.first().delete();\n                            msg.delete();\n\n                            client.errNormal({\n                                error: \"You have answered the captcha incorrectly!\",\n                                type: 'editreply'\n                            }, interaction).then(msgError => {\n                                setTimeout(() => {\n                                    msgError.delete();\n                                }, 2000)\n                            })\n                        }\n                    })\n                })\n            }\n            catch (error) {\n                console.log(error)\n            }\n        }\n        else {\n            client.errNormal({\n                error: \"Verify is disabled in this server! Or you are using the wrong channel!\",\n                type: 'ephemeral'\n            }, interaction);\n        }\n    }\n\n    // Reaction roles button\n    if (interaction.isButton()) {\n        var buttonID = interaction.customId.split(\"-\");\n\n        if (buttonID[0] == \"reaction_button\") {\n            reactionSchema.findOne({ Message: interaction.message.id }, async (err, data) => {\n                if (!data) return;\n\n                const [roleid] = data.Roles[buttonID[1]];\n\n                if (interaction.member.roles.cache.get(roleid)) {\n                    interaction.guild.members.cache.get(interaction.user.id).roles.remove(roleid).catch(error => { })\n\n                    interaction.reply({ content: `<@&${roleid}> was removed!`, ephemeral: true });\n                }\n                else {\n                    interaction.guild.members.cache.get(interaction.user.id).roles.add(roleid).catch(error => { })\n\n                    interaction.reply({ content: `<@&${roleid}> was added!`, ephemeral: true });\n                }\n            })\n        }\n    }\n\n    // Reaction roles select\n    if (interaction.isStringSelectMenu()) {\n        if (interaction.customId == \"reaction_select\") {\n            reactionSchema.findOne(\n                { Message: interaction.message.id },\n                async (err, data) => {\n                    if (!data) return;\n\n                    let roles = \"\";\n\n                    for (let i = 0; i < interaction.values.length; i++) {\n                        const [roleid] = data.Roles[interaction.values[i]];\n\n                        roles += `<@&${roleid}> `;\n\n                        if (interaction.member.roles.cache.get(roleid)) {\n                            interaction.guild.members.cache\n                                .get(interaction.user.id)\n                                .roles.remove(roleid)\n                                .catch((error) => { });\n                        } else {\n                            interaction.guild.members.cache\n                                .get(interaction.user.id)\n                                .roles.add(roleid)\n                                .catch((error) => { });\n                        }\n\n                        if ((i + 1) === interaction.values.length) {\n                            interaction.reply({\n                                content: `I have updated the following roles for you: ${roles}`,\n                                ephemeral: true,\n                            });\n                        }\n                    }\n                }\n            );\n        }\n    }\n    // Tickets\n    if (interaction.customId == \"Bot_openticket\") {\n        return require(`${process.cwd()}/src/commands/tickets/create.js`)(client, interaction);\n    }\n\n    if (interaction.customId == \"Bot_closeticket\") {\n        return require(`${process.cwd()}/src/commands/tickets/close.js`)(client, interaction);\n    }\n\n    if (interaction.customId == \"Bot_claimTicket\") {\n        return require(`${process.cwd()}/src/commands/tickets/claim.js`)(client, interaction);\n    }\n\n    if (interaction.customId == \"Bot_transcriptTicket\") {\n        return require(`${process.cwd()}/src/commands/tickets/transcript.js`)(client, interaction);\n    }\n\n    if (interaction.customId == \"Bot_openTicket\") {\n        return require(`${process.cwd()}/src/commands/tickets/open.js`)(client, interaction);\n    }\n\n    if (interaction.customId == \"Bot_deleteTicket\") {\n        return require(`${process.cwd()}/src/commands/tickets/delete.js`)(client, interaction);\n    }\n\n    if (interaction.customId == \"Bot_noticeTicket\") {\n        return require(`${process.cwd()}/src/commands/tickets/notice.js`)(client, interaction);\n    }\n}\n\n ","size_bytes":9515},"src/events/client/raw.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, d) => {\n    client.player.updateVoiceState(d);\n}\n\n ","size_bytes":123},"src/events/emoji/emojiCreate.js":{"content":"const discord = require('discord.js');\n\nmodule.exports = async (client, emoji) => {\n    const logsChannel = await client.getLogs(emoji.guild.id);\n    if (!logsChannel) return;\n\n    client.embed({\n        title: `😛・Emoji created`,\n        desc: `An emoji has been created`,\n        fields: [\n            {\n                name: `> Emoji`,\n                value: `- ${emoji}`\n            },\n            {\n                name: `> Name`,\n                value: `- ${emoji.name}`\n            },\n            {\n                name: `> ID`,\n                value: `- ${emoji.id}`\n            },\n            {\n                name: `> Url`,\n                value: `- ${emoji.url}`\n            }\n        ]\n    }, logsChannel).catch(() => { })\n};","size_bytes":742},"src/events/emoji/emojiDelete.js":{"content":"const discord = require('discord.js');\n\nmodule.exports = async (client, emoji) => {\n    const logsChannel = await client.getLogs(emoji.guild.id);\n    if (!logsChannel) return;\n\n    client.embed({\n        title: `😛・Emoji deleted`,\n        desc: `An emoji has been deleted`,\n        fields: [\n            {\n                name: `> Name`,\n                value: `- ${emoji.name}`\n            },\n            {\n                name: `> ID`,\n                value: `- ${emoji.id}`\n            }\n        ]\n    }, logsChannel).catch(() => { })\n};","size_bytes":544},"src/events/emoji/emojiUpdate.js":{"content":"const discord = require('discord.js');\n\nmodule.exports = async (client, oldEmoji, newEmoji) => {\n    const logsChannel = await client.getLogs(newEmoji.guild.id);\n    if (!logsChannel) return;\n\n    client.embed({\n        title: `😛・Emoji updated`,\n        desc: `An emoji has been updated`,\n        fields: [\n            {\n                name: `> Emoji`,\n                value: `- ${newEmoji}`\n            },\n            {\n                name: `> Before`,\n                value: `- ${oldEmoji.name}`\n            },\n            {\n                name: `> After`,\n                value: `- ${newEmoji.name}`\n            },\n            {\n                name: `> ID`,\n                value: `- ${newEmoji.id}`\n            }\n        ]\n    }, logsChannel).catch(() => { })\n};","size_bytes":775},"src/events/event/guildScheduledEventCreate.js":{"content":"const discord = require('discord.js');\n\nmodule.exports = async (client, event) => {\n    let types = {\n        GUILD_ONLY: \"Server only\",\n        PUBLIC: \"Public\",\n    }\n\n    let locations = {\n        NONE: \"None\",\n        STAGE_INSTANCE: \"Stage Channel\",\n        VOICE: \"Voice Channel\",\n        EXTERNAL: `External`\n    }\n\n    const logsChannel = await client.getLogs(event.guildId);\n    if (!logsChannel) return;\n\n    client.embed({\n        title: `🎡・Event created`,\n        desc: `An event has been created`,\n        fields: [\n            {\n                name: `> Name`,\n                value: `- ${event.name}`\n            },\n            {\n                name: `> Description`,\n                value: `- ${event.description || 'None'}`\n            },\n            {\n                name: `> Start`,\n                value: `- <t:${(event.scheduledStartTimestamp / 1000).toFixed(0)}>`\n            },\n            {\n                name: `> Privacy`,\n                value: `- ${types[event.privacyLevel]}`\n            },\n            {\n                name: `> Creator`,\n                value: `- <@!${event.creatorId}> (${event.creatorId})`\n            },\n            {\n                name: `> Location type`,\n                value: `- ${locations[event.entityType]}`\n            },\n            {\n                name: `> Timestamp`,\n                value: `- <t:${Math.floor(Date.now() / 1000)}:R>`\n            }\n        ]\n    }, logsChannel).catch(() => { })\n};","size_bytes":1471},"src/events/event/guildScheduledEventDelete.js":{"content":"const discord = require('discord.js');\n\nmodule.exports = async (client, event) => {\n    let types = {\n        GUILD_ONLY: \"Server only\",\n        PUBLIC: \"Public\",\n    }\n\n    let locations = {\n        NONE: \"None\",\n        STAGE_INSTANCE: \"Stage Channel\",\n        VOICE: \"Voice Channel\",\n        EXTERNAL: `External`\n    }\n\n    const logsChannel = await client.getLogs(event.guildId);\n    if (!logsChannel) return;\n\n    client.embed({\n        title: `🎡・Event deleted`,\n        desc: `An event has been deleted`,\n        fields: [\n            {\n                name: `> Name`,\n                value: `- ${event.name}`\n            },\n            {\n                name: `> Description`,\n                value: `- ${event.description || 'None'}`\n            },\n            {\n                name: `> Start`,\n                value: `- <t:${(event.scheduledStartTimestamp / 1000).toFixed(0)}>`\n            },\n            {\n                name: `> Privacy`,\n                value: `- ${types[event.privacyLevel]}`\n            },\n            {\n                name: `> Creator`,\n                value: `- <@!${event.creatorId}> (${event.creatorId})`\n            },\n            {\n                name: `> Location type`,\n                value: `- ${locations[event.entityType]}`\n            },\n            {\n                name: `> Timestamp`,\n                value: `- <t:${Math.floor(Date.now() / 1000)}:R>`\n            }\n        ]\n    }, logsChannel).catch(() => { })\n};","size_bytes":1471},"src/events/event/guildScheduledEventUpdate.js":{"content":"const discord = require('discord.js');\n\nmodule.exports = async (client, oldEvent, newEvent) => {\n    const logsChannel = await client.getLogs(newEvent.guildId);\n    if (!logsChannel) return;\n\n    client.embed({\n        title: `🎡・Event updated`,\n        desc: `An event has been updated`,\n        fields: [\n            {\n                name: `> Old Name`,\n                value: `- ${oldEvent.name}`\n            },\n            {\n                name: `> New Name`,\n                value: `- ${newEvent.name}`\n            },\n            {\n                name: `> Old Description`,\n                value: `- ${oldEvent.description || 'None'}`\n            },\n            {\n                name: `> New Description`,\n                value: `- ${newEvent.description || 'None'}`\n            },\n            {\n                name: `> Old Time`,\n                value: `- <t:${(oldEvent.scheduledStartTimestamp / 1000).toFixed(0)}>`\n            },\n            {\n                name: `> New Time`,\n                value: `- <t:${(newEvent.scheduledStartTimestamp / 1000).toFixed(0)}>`\n            },\n            {\n                name: `> Creator`,\n                value: `- <@!${newEvent.creatorId}> (${newEvent.creatorId})`\n            },\n            {\n                name: `> Timestamp`,\n                value: `- <t:${Math.floor(Date.now() / 1000)}:R>`\n            }\n        ]\n    }, logsChannel).catch(() => { })\n};","size_bytes":1420},"src/events/giveaway/endedGiveawayReactionAdded.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = (client, giveaway, member, reaction) => {\n    client.errNormal({\n        error: `The giveaway has unfortunately ended! You can't participate anymore`\n    }, member).catch(() => { });\n};","size_bytes":242},"src/events/giveaway/giveawayEnded.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = (client, giveaway, winners) => {\n    winners.forEach((member) => {\n        client.embed({\n            title: `🎉・Giveaway ended`,\n            desc: `Congratulations ${member.user.username}! You won the giveaway!`,\n            fields: [\n                {\n                    name: `🎁┆Prize`,\n                    value: `${giveaway.prize}`,\n                    inline: true\n                },\n                {\n                    name: `🥳┆Giveaway`,\n                    value: `[Click here](https://discordapp.com/channels/${giveaway.message.guildId}/${giveaway.message.channelId}/${giveaway.message.id})`,\n                    inline: true\n                }\n            ]\n        \n        }, member).catch(() => { });\n    });\n};","size_bytes":798},"src/events/giveaway/giveawayReactionAdded.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = (client, giveaway, member, reaction) => {\n    client.succNormal({\n        text: `Your entry into [this giveaway](https://discordapp.com/channels/${giveaway.message.guildId}/${giveaway.message.channelId}/${giveaway.message.id}) has been approved.`\n    }, member).catch(() => { });\n};","size_bytes":339},"src/events/giveaway/giveawayRerolled.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = (client, giveaway, winners) => {\n    winners.forEach((member) => {\n        client.embed({\n            title: `🎉・Giveaway ended`,\n            desc: `Congratulations ${member.user.username}! You won the giveaway!`,\n            fields: [\n                {\n                    name: `🎁┆Prize`,\n                    value: `${giveaway.prize}`,\n                    inline: true\n                },\n                {\n                    name: `🥳┆Giveaway`,\n                    value: `[Click here](https://discordapp.com/channels/${giveaway.message.guildId}/${giveaway.message.channelId}/${giveaway.message.id})`,\n                    inline: true\n                }\n            ]\n        \n        }, member).catch(() => { });\n    });\n};","size_bytes":798},"src/events/guild/guildAfkChannelAdd.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, guild, afkChannel) => {\n    const logsChannel = await client.getLogs(guild.id);\n    if (!logsChannel) return;\n\n    client.embed({\n        title: `🛑・New AFK channel`,\n        desc: `An AFK channel has been added to the server`,\n        fields: [\n            {\n                name: `> Channel`,\n                value: `- ${afkChannel}`\n            },\n            {\n                name: `> Name`,\n                value: `- ${afkChannel.name}`\n            },\n            {\n                name: `> ID`,\n                value: `- ${afkChannel.id}`\n            },\n            {\n                name: `> Timestamp`,\n                value: `- <t:${Math.floor(afkChannel.createdTimestamp / 1000)}:R>`\n            }\n        ]\n    }, logsChannel).catch(() => { })\n};","size_bytes":834},"src/events/guild/guildBanAdd.js":{"content":"const discord = require('discord.js');\n\nmodule.exports = async (client, ban) => {\n    const logsChannel = await client.getLogs(ban.guild.id);\n    if (!logsChannel) return;\n\n    client.embed({\n        title: `🔧・Member banned`,\n        desc: `A user has been banned`,\n        thumbnail: ban.user.avatarURL({ size: 4096 }),\n        fields: [\n            {\n                name: `> User`,\n                value: `- ${ban.user}`\n            },\n            {\n                name: `> Tag`,\n                value: `- ${ban.user.tag}`\n            },\n            {\n                name: `> ID`,\n                value: `- ${ban.user.id}`\n            },\n            {\n                name: `> Timestamp`,\n                value: `- <t:${Math.floor(ban.createdTimestamp / 1000)}:R>`\n            }\n        ]\n    }, logsChannel).catch(() => { })\n};","size_bytes":838},"src/events/guild/guildBanRemove.js":{"content":"const discord = require('discord.js');\n\nmodule.exports = async (client, ban) => {\n    const logsChannel = await client.getLogs(ban.guild.id);\n    if (!logsChannel) return;\n\n    client.embed({\n        title: `🔧・Member unbanned`,\n        desc: `A user has been unbanned`,\n        thumbnail: ban.user.avatarURL({ size: 4096 }),\n        fields: [\n            {\n                name: `> User`,\n                value: `- ${ban.user}`\n            },\n            {\n                name: `> Tag`,\n                value: `- ${ban.user.tag}`\n            },\n            {\n                name: `> ID`,\n                value: `- ${ban.user.id}`\n            },\n            {\n                name: `> Timestamp`,\n                value: `- <t:${Math.floor(ban.createdTimestamp / 1000)}:R>`\n            }\n        ]\n    }, logsChannel).catch(() => { })\n};","size_bytes":842},"src/events/guild/guildBannerAdd.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, guild, bannerURL) => {\n    const logsChannel = await client.getLogs(guild.id);\n    if (!logsChannel) return;\n\n    client.embed({\n        title: `🖼️・New banner`,\n        desc: `The server banner has been updated`,\n        image: bannerURL\n    }, logsChannel).catch(() => { })\n};","size_bytes":356},"src/events/guild/guildBoostLevelDown.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, guild, oldLevel, newLevel) => {\n    const logsChannel = await client.getLogs(guild.id);\n    if (!logsChannel) return;\n\n    client.embed({\n        title: `🆙・New boost level`,\n        desc: `This server has returned to a new boost level`,\n        fields: [\n            {\n                name: `> Old level`,\n                value: `- ${oldLevel}`\n            },\n            {\n                name: `> New level`,\n                value: `- ${newLevel}`\n            },\n            {\n                name: `> Timestamp`,\n                value: `- <t:${Math.floor(Date.now() / 1000)}:R>`\n            }\n        ]\n    }, logsChannel).catch(() => { })\n};","size_bytes":722},"src/events/guild/guildBoostLevelUp.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, guild, oldLevel, newLevel) => {\n    const logsChannel = await client.getLogs(guild.id);\n    if (!logsChannel) return;\n\n    client.embed({\n        title: `🆙・New boost level`,\n        desc: `This server has returned to a new boost level`,\n        fields: [\n            {\n                name: `> Old level`,\n                value: `- ${oldLevel}`\n            },\n            {\n                name: `> New level`,\n                value: `- ${newLevel}`\n            },\n            {\n                name: `> Timestamp`,\n                value: `- <t:${Math.floor(Date.now() / 1000)}:R>`\n            }\n        ]\n    }, logsChannel).catch(() => { })\n};","size_bytes":722},"src/events/guild/guildMemberAdd.js":{"content":"const discord = require('discord.js');\n\nconst roleSchema = require(\"../../database/models/joinRole\");\n\nmodule.exports = async (client, member) => {\n    const data = await roleSchema.findOne({ Guild: member.guild.id })\n    if (data) {\n        const role = member.guild.roles.cache.get(data.Role);\n        if (!role) return;\n\n        member.roles.add(role).catch(() => { });\n    }\n};","size_bytes":381},"src/events/guild/guildMemberBoost.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/boostChannels\");\nconst Schema2 = require(\"../../database/models/boostMessage\");\n\nmodule.exports = async (client, member) => {\n    try {\n        const channelData = await Schema.findOne({ Guild: member.guild.id });\n        const messageData = await Schema2.findOne({ Guild: member.guild.id });\n\n        if (messageData) {\n            let tier = {\n                \"TIER_1\": `1 `,\n                \"TIER_2\": `2`,\n                \"TIER_3\": `3`,\n                \"NONE\": `0`,\n            }\n\n            var boostMessage = messageData.boostMessage;\n            boostMessage = boostMessage.replace(`{user:username}`, member.user.username)\n            boostMessage = boostMessage.replace(`{user:discriminator}`, member.user.discriminator)\n            boostMessage = boostMessage.replace(`{user:tag}`, member.user.tag)\n            boostMessage = boostMessage.replace(`{user:mention}`, member)\n\n            boostMessage = boostMessage.replace(`{guild:name}`, member.guild.name)\n            boostMessage = boostMessage.replace(`{guild:members}`, member.guild.memberCount)\n            boostMessage = boostMessage.replace(`{guild:boosts}`, member.guild.premiumSubscriptionCount)\n            boostMessage = boostMessage.replace(`{guild:booststier}`, tier[member.guild.premiumTier])\n\n            if (channelData) {\n\n                try {\n                    var channel = client.channels.cache.get(channelData.Channel)\n\n                    client.embed({\n                        title: `🚀・New boost`,\n                        desc: boostMessage\n                    }, channel)\n                }\n                catch { }\n            }\n        }\n        else {\n            if (channelData) {\n\n                try {\n                    var channel = client.channels.cache.get(channelData.Channel)\n\n                    client.embed({\n                        title: `🚀・New boost`,\n                        desc: `${member} boosted the server!`\n                    }, channel)\n                }\n                catch { }\n            }\n        }\n    }\n    catch { }\n\n};","size_bytes":2140},"src/events/guild/guildMemberRemove.js":{"content":"const discord = require('discord.js');\n\nconst leaveSchema = require(\"../../database/models/leaveChannels\");\nconst messages = require(\"../../database/models/inviteMessages\");\nconst invitedBy = require(\"../../database/models/inviteBy\");\nconst invites = require(\"../../database/models/invites\");\n\nmodule.exports = async (client, member) => {\n    const messageData = await messages.findOne({ Guild: member.guild.id });\n    const inviteByData = await invitedBy.findOne({ Guild: member.guild.id, User: member.id });\n    const channelData = await leaveSchema.findOne({ Guild: member.guild.id });\n\n    if (inviteByData) {\n        const inviteData = await invites.findOne({ Guild: member.guild.id, User: inviteByData.inviteUser });\n\n        if (inviteData) {\n            inviteData.Invites -= 1;\n            inviteData.Left += 1;\n            inviteData.save();\n        }\n\n        if (channelData) {\n            if (messageData && messageData.inviteLeave) {\n                var leaveMessage = messageData.inviteLeave;\n                leaveMessage = leaveMessage.replace(`{user:username}`, member.user.username)\n                leaveMessage = leaveMessage.replace(`{user:discriminator}`, member.user.discriminator)\n                leaveMessage = leaveMessage.replace(`{user:tag}`, member.user.tag)\n                leaveMessage = leaveMessage.replace(`{user:mention}`, member)\n\n                leaveMessage = leaveMessage.replace(`{inviter:mention}`, `<@!${inviteByData.inviteUser}>`)\n                leaveMessage = leaveMessage.replace(`{inviter:invites}`, inviteData.Invites)\n                leaveMessage = leaveMessage.replace(`{inviter:invites:left}`, inviteData.Left)\n\n                leaveMessage = leaveMessage.replace(`{guild:name}`, member.guild.name)\n                leaveMessage = leaveMessage.replace(`{guild:members}`, member.guild.memberCount)\n\n                client.users.fetch(inviteData.inviteUser).then(async (user) => {\n                    leaveMessage = leaveMessage.replace(`{inviter:username}`, user.username)\n                    leaveMessage = leaveMessage.replace(`{inviter:discriminator}`, user.discriminator)\n                    leaveMessage = leaveMessage.replace(`{inviter:tag}`, `${user.username}#${user.discriminator}`)\n\n                    const channel = member.guild.channels.cache.get(channelData.Channel)\n\n                    await client.embed({\n                        title: `👋・Bye`,\n                        desc: leaveMessage\n                    }, channel).catch(() => { })\n                }).catch(async () => {\n                    if (channelData) {\n\n                        const channel = member.guild.channels.cache.get(channelData.Channel)\n\n                        await client.embed({\n                            title: `👋・Bye`,\n                            desc: `**${member.user.tag}** has left us`\n                        }, channel).catch(() => { })\n                    }\n                })\n            }\n            else {\n                client.users.fetch(inviteData.User).then(async (user) => {\n\n                    const channel = member.guild.channels.cache.get(channelData.Channel)\n\n                    await client.embed({\n                        title: `👋・Bye`,\n                        desc: `**${member.user.tag}** was invited by ${user.tag}`\n                    }, channel).catch(() => { })\n\n                }).catch(async () => {\n                    if (channelData) {\n\n                        const channel = member.guild.channels.cache.get(channelData.Channel)\n\n                        await client.embed({\n                            title: `👋・Bye`,\n                            desc: `**${member.user.tag}** was invited by ${user.tag}`\n                        }, channel).catch(() => { })\n                    }\n                })\n            }\n        }\n    }\n    else {\n        if (channelData) {\n\n            const channel = member.guild.channels.cache.get(channelData.Channel)\n\n            await client.embed({\n                title: `👋・Bye`,\n                desc: `**${member.user.tag}** has left us`\n            }, channel).catch(() => { })\n        }\n    }\n};","size_bytes":4143},"src/events/guild/guildMemberUnboost.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/boostChannels\");\nconst Schema2 = require(\"../../database/models/boostMessage\");\n\nmodule.exports = async (client, member) => {\n    try {\n        const channelData = await Schema.findOne({ Guild: member.guild.id });\n        const messageData = await Schema2.findOne({ Guild: member.guild.id });\n\n        if (messageData) {\n            let tier = {\n                \"TIER_1\": `1 `,\n                \"TIER_2\": `2`,\n                \"TIER_3\": `3`,\n                \"NONE\": `0`,\n            }\n\n            var boostMessage = messageData.unboostMessage;\n            boostMessage = boostMessage.replace(`{user:username}`, member.user.username)\n            boostMessage = boostMessage.replace(`{user:discriminator}`, member.user.discriminator)\n            boostMessage = boostMessage.replace(`{user:tag}`, member.user.tag)\n            boostMessage = boostMessage.replace(`{user:mention}`, member)\n\n            boostMessage = boostMessage.replace(`{guild:name}`, member.guild.name)\n            boostMessage = boostMessage.replace(`{guild:members}`, member.guild.memberCount)\n            boostMessage = boostMessage.replace(`{guild:boosts}`, member.guild.premiumSubscriptionCount)\n            boostMessage = boostMessage.replace(`{guild:booststier}`, tier[member.guild.premiumTier])\n\n            if (channelData) {\n \n                try {\n\n                    var channel = client.channels.cache.get(channelData.Channel)\n\n                    client.embed({\n                        title: `🚀・New unboost`,\n                        desc: boostMessage\n                    }, channel)\n                }\n                catch { }\n            }\n        }\n        else {\n            if (channelData) {\n\n                try {\n\n                    var channel = client.channels.cache.get(channelData.Channel)\n\n                    client.embed({\n                        title: `🚀・New unboost`,\n                        desc: `${member} unboosted the server!`\n                    }, channel)\n                }\n                catch { }\n            }\n        }\n    }\n    catch { }\n\n};","size_bytes":2151},"src/events/guild/guildMemberUpdate.js":{"content":"const Discord = require('discord.js');\n\n/**\n * \n * @param {Discord.Client} client \n * @param {Discord.GuildMember} oldMember \n * @param {Discord.GuildMember} newMember \n * @returns \n */\nmodule.exports = async (client, oldMember, newMember) => {\n    if (!oldMember || !newMember) return;\n    const removedRoles = oldMember.roles.cache.filter(role => !newMember.roles.cache.has(role.id));\n    const addedRoles = newMember.roles.cache.filter(role => !oldMember.roles.cache.has(role.id));\n    if (removedRoles.size === 0 && addedRoles.size === 0 || removedRoles.size === addedRoles.size) return;    \n    const logsChannel = await client.getLogs(newMember.guild.id);\n    if (!logsChannel) return;\n\n    var ostring = \"\";\n    if (removedRoles.size === 0) ostring = \"No roles removed\";\n    if (removedRoles.size > 0) removedRoles.forEach(element => { ostring += \"<@&\" + element + \"> \" });\n\n    var nstring = \"\";\n    if (addedRoles.size > 0) addedRoles.forEach(element => { nstring += \"<@&\" + element + \"> \" });\n\n    client.embed({\n        title: `${newMember.user.username} roles adjusted`,\n        desc: `There are roles changed`,\n        fields: [\n            {\n                name: `> Old Roles`,\n                value: `- ${ostring}`\n            },\n            {\n                name: `> New Roles`,\n                value: `- ${nstring}`\n            },\n        ]\n    }, logsChannel).catch(() => { })\n};","size_bytes":1399},"src/events/guild/guildVanityURLAdd.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, guild, url) => {\n    const logsChannel = await client.getLogs(guild.id);\n    if (!logsChannel) return;\n\n    client.embed({\n        title: `🔗・New Vanity URL`,\n        desc: `The server vanity URL has been updated`,\n        fields: [\n            {\n                name: `> URL`,\n                value: `- ${url}`\n            },\n            {\n                name: `> Timestamp`,\n                value: `- <t:${Math.floor(Date.now() / 1000)}:R>`\n            }\n        ]\n    }, logsChannel).catch(() => { })\n};","size_bytes":583},"src/events/invite/inviteCreate.js":{"content":"const discord = require('discord.js');\n\nmodule.exports = async (client, invite) => {\n    const logsChannel = await client.getLogs(invite.guild.id);\n    if (!logsChannel) return;\n\n    client.embed({\n        title: `📨・Invite created`,\n        desc: `A invite has been created`,\n        fields: [\n            {\n                name: `> Code`,\n                value: `- ${invite.code}`\n            },\n            {\n                name: `> Inviter`,\n                value: `- ${invite.inviter} (${invite.inviter.tag})`\n            },\n            {\n                name: `> Timestamp`,\n                value: `- <t:${Math.floor(invite.createdTimestamp / 1000)}:R>`\n            }\n        ]\n    }, logsChannel).catch(() => { })\n};","size_bytes":728},"src/events/invite/inviteDelete.js":{"content":"const discord = require('discord.js');\n\nmodule.exports = async (client, invite) => {\n    const logsChannel = await client.getLogs(invite.guild.id);\n    if (!logsChannel) return;\n\n    client.embed({\n        title: `📨・Invite deleted`,\n        desc: `A invite has been deleted`,\n        fields: [\n            {\n                name: `> Code`,\n                value: `- ${invite.code}`\n            },\n            {\n                name: `> Timestamp`,\n                value: `- <t:${Math.floor(invite.createdTimestamp / 1000)}:R>`\n            }\n        ]\n    }, logsChannel).catch(() => { })\n};","size_bytes":595},"src/events/invite/inviteJoin.js":{"content":"const discord = require('discord.js');\n\nconst invites = require(\"../../database/models/invites\");\nconst invitedBy = require(\"../../database/models/inviteBy\");\nconst welcomeSchema = require(\"../../database/models/welcomeChannels\");\nconst messages = require(\"../../database/models/inviteMessages\");\nconst rewards = require(\"../../database/models/inviteRewards\");\n\n\nmodule.exports = async (client, member, invite, inviter) => {\n    const messageData = await messages.findOne({ Guild: member.guild.id });\n\n    if (!invite || !inviter) {\n        if (messageData && messageData.inviteJoin) {\n            var joinMessage = messageData.inviteJoin;\n            joinMessage = joinMessage.replace(`{user:username}`, member.user.username)\n            joinMessage = joinMessage.replace(`{user:discriminator}`, member.user.discriminator)\n            joinMessage = joinMessage.replace(`{user:tag}`, member.user.tag)\n            joinMessage = joinMessage.replace(`{user:mention}`, member)\n\n            joinMessage = joinMessage.replace(`{inviter:username}`, \"System\")\n            joinMessage = joinMessage.replace(`{inviter:discriminator}`, \"#0000\")\n            joinMessage = joinMessage.replace(`{inviter:tag}`, \"System#0000\")\n            joinMessage = joinMessage.replace(`{inviter:mention}`, \"System\")\n            joinMessage = joinMessage.replace(`{inviter:invites}`, \"∞\")\n            joinMessage = joinMessage.replace(`{inviter:invites:left}`, \"∞\")\n\n            joinMessage = joinMessage.replace(`{guild:name}`, member.guild.name)\n            joinMessage = joinMessage.replace(`{guild:members}`, member.guild.memberCount)\n\n            welcomeSchema.findOne({ Guild: member.guild.id }, async (err, channelData) => {\n                if (channelData) {\n\n                    var channel = member.guild.channels.cache.get(channelData.Channel)\n\n                    await client.embed({\n                        title: `👋・Welcome`,\n                        desc: joinMessage\n                    }, channel).catch(() => { })\n                }\n            })\n        } else {\n            welcomeSchema.findOne({ Guild: member.guild.id }, async (err, channelData) => {\n                if (channelData) {\n\n                    var channel = member.guild.channels.cache.get(channelData.Channel)\n\n                    client.embed({\n                        title: `👋・Welcome`,\n                        desc: `I cannot trace how **${member} | ${member.user.tag}** has been joined`\n                    }, channel).catch(() => { })\n                }\n            })\n        }\n    }\n    else {\n        const data = await invites.findOne({ Guild: member.guild.id, User: inviter.id });\n\n        if (data) {\n            data.Invites += 1;\n            data.Total += 1;\n            data.save();\n\n            if (messageData) {\n                var joinMessage = messageData.inviteJoin;\n                joinMessage = joinMessage.replace(`{user:username}`, member.user.username)\n                joinMessage = joinMessage.replace(`{user:discriminator}`, member.user.discriminator)\n                joinMessage = joinMessage.replace(`{user:tag}`, member.user.tag)\n                joinMessage = joinMessage.replace(`{user:mention}`, member)\n\n                joinMessage = joinMessage.replace(`{inviter:username}`, inviter.username)\n                joinMessage = joinMessage.replace(`{inviter:discriminator}`, inviter.discriminator)\n                joinMessage = joinMessage.replace(`{inviter:tag}`, inviter.tag)\n                joinMessage = joinMessage.replace(`{inviter:mention}`, inviter)\n                joinMessage = joinMessage.replace(`{inviter:invites}`, data.Invites)\n                joinMessage = joinMessage.replace(`{inviter:invites:left}`, data.Left)\n\n                joinMessage = joinMessage.replace(`{guild:name}`, member.guild.name)\n                joinMessage = joinMessage.replace(`{guild:members}`, member.guild.memberCount)\n\n                welcomeSchema.findOne({ Guild: member.guild.id }, async (err, channelData) => {\n                    if (channelData) {\n\n                        var channel = member.guild.channels.cache.get(channelData.Channel)\n\n                        await client.embed({\n                            title: `👋・Welcome`,\n                            desc: joinMessage\n                        }, channel).catch(() => { })\n                    }\n                })\n            }\n            else {\n                welcomeSchema.findOne({ Guild: member.guild.id }, async (err, channelData) => {\n                    if (channelData) {\n\n                        var channel = member.guild.channels.cache.get(channelData.Channel)\n\n                        client.embed({\n                            title: `👋・Welcome`,\n                            desc: `**${member} | ${member.user.tag}** was invited by ${inviter.tag} **(${data.Invites} invites)**`\n                        }, channel)\n                    }\n                })\n            }\n\n            rewards.findOne({ Guild: member.guild.id, Invites: data.Invites }, async (err, data) => {\n                if (data) {\n                    try {\n                        var role = member.guild.roles.cache.get(data.Role);\n                        member.roles.add(role);\n                    }\n                    catch { }\n                }\n            })\n        }\n        else {\n            new invites({\n                Guild: member.guild.id,\n                User: inviter.id,\n                Invites: 1,\n                Total: 1,\n                Left: 0\n            }).save();\n\n            if (messageData) {\n                var joinMessage = messageData.inviteJoin;\n                joinMessage = joinMessage.replace(`{user:username}`, member.user.username)\n                joinMessage = joinMessage.replace(`{user:discriminator}`, member.user.discriminator)\n                joinMessage = joinMessage.replace(`{user:tag}`, member.user.tag)\n                joinMessage = joinMessage.replace(`{user:mention}`, member)\n\n                joinMessage = joinMessage.replace(`{inviter:username}`, inviter.username)\n                joinMessage = joinMessage.replace(`{inviter:discriminator}`, inviter.discriminator)\n                joinMessage = joinMessage.replace(`{inviter:tag}`, inviter.tag)\n                joinMessage = joinMessage.replace(`{inviter:mention}`, inviter)\n                joinMessage = joinMessage.replace(`{inviter:invites}`, \"1\")\n                joinMessage = joinMessage.replace(`{inviter:invites:left}`, \"0\")\n\n                joinMessage = joinMessage.replace(`{guild:name}`, member.guild.name)\n                joinMessage = joinMessage.replace(`{guild:members}`, member.guild.memberCount)\n\n                welcomeSchema.findOne({ Guild: member.guild.id }, async (err, channelData) => {\n                    if (channelData) {\n\n                        var channel = member.guild.channels.cache.get(channelData.Channel)\n\n                        await client.embed({\n                            title: `👋・Welcome`,\n                            desc: joinMessage\n                        }, channel).catch(() => { })\n                    }\n                })\n            }\n            else {\n                welcomeSchema.findOne({ Guild: member.guild.id }, async (err, channelData) => {\n                    if (channelData) {\n\n                        var channel = member.guild.channels.cache.get(channelData.Channel)\n\n                        await client.embed({\n                            title: `👋・Welcome`,\n                            desc: `**${member} | ${member.user.tag}** was invited by ${inviter.tag} **(1 invites)**`\n                        }, channel).catch(() => { })\n                    }\n                })\n            }\n        }\n\n        invitedBy.findOne({ Guild: member.guild.id }, async (err, data2) => {\n            if (data2) {\n                data2.inviteUser = inviter.id,\n                    data2.User = member.id\n                data2.save();\n            }\n            else {\n                new invitedBy({\n                    Guild: member.guild.id,\n                    inviteUser: inviter.id,\n                    User: member.id\n                }).save();\n            }\n        })\n    }\n};","size_bytes":8209},"src/events/message/messageCreate.js":{"content":"const Discord = require(\"discord.js\");\n\nconst Functions = require(\"../../database/models/functions\");\nconst afk = require(\"../../database/models/afk\");\nconst chatBotSchema = require(\"../../database/models/chatbot-channel\");\nconst messagesSchema = require(\"../../database/models/messages\");\nconst messageSchema = require(\"../../database/models/levelMessages\");\nconst messageRewards = require(\"../../database/models/messageRewards\");\nconst Schema = require(\"../../database/models/stickymessages\");\nconst levelRewards = require(\"../../database/models/levelRewards\");\nconst levelLogs = require(\"../../database/models/levelChannels\");\nconst Commands = require(\"../../database/models/customCommand\");\nconst CommandsSchema = require(\"../../database/models/customCommandAdvanced\");\nconst fetch = require(\"node-fetch\");\n\n/**\n * \n * @param {Discord.Client} client \n * @param {Discord.Message} message \n * @returns \n */\nmodule.exports = async (client, message) => {\n  const dmlog = new Discord.WebhookClient({\n    id: client.webhooks.dmLogs.id,\n    token: client.webhooks.dmLogs.token,\n  });\n\n  if (message.author.bot) return;\n\n  if (message.channel.type === Discord.ChannelType.DM) {\n    let embedLogs = new Discord.EmbedBuilder()\n      .setTitle(`💬・New DM message!`)\n      .setDescription(`Bot has received a new DM message!`)\n      .addFields(\n        { name: \"👤┆Send By\", value: `${message.author} (${message.author.tag})`, inline: true },\n        { name: `💬┆Message`, value: `${message.content || \"None\"}`, inline: true },\n      )\n      .setColor(client.config.colors.normal)\n      .setTimestamp();\n\n    if (message.attachments.size > 0)\n      embedLogs.addFields(\n        { name: `📃┆Attachments`, value: `${message.attachments.first()?.url}`, inline: false },\n      )\n    return dmlog.send({\n      username: \"Bot DM\",\n      embeds: [embedLogs],\n    });\n  }\n\n  // Levels\n  Functions.findOne({ Guild: message.guild.id }, async (err, data) => {\n    if (data) {\n      if (data.Levels == true) {\n        const randomXP = Math.floor(Math.random() * 9) + 1;\n        const hasLeveledUp = await client.addXP(\n          message.author.id,\n          message.guild.id,\n          randomXP\n        );\n\n        if (hasLeveledUp) {\n          const user = await client.fetchLevels(\n            message.author.id,\n            message.guild.id\n          );\n\n          const levelData = await levelLogs.findOne({\n            Guild: message.guild.id,\n          });\n          const messageData = await messageSchema.findOne({\n            Guild: message.guild.id,\n          });\n\n          if (messageData) {\n            var levelMessage = messageData.Message;\n            levelMessage = levelMessage.replace(\n              `{user:username}`,\n              message.author.username\n            );\n            levelMessage = levelMessage.replace(\n              `{user:discriminator}`,\n              message.author.discriminator\n            );\n            levelMessage = levelMessage.replace(\n              `{user:tag}`,\n              message.author.tag\n            );\n            levelMessage = levelMessage.replace(\n              `{user:mention}`,\n              message.author\n            );\n\n            levelMessage = levelMessage.replace(`{user:level}`, user.level);\n            levelMessage = levelMessage.replace(`{user:xp}`, user.xp);\n\n            try {\n              if (levelData) {\n                await client.channels.cache\n                  .get(levelData.Channel)\n                  .send({ content: levelMessage })\n                  .catch(() => { });\n              } else {\n                await message.channel.send({ content: levelMessage });\n              }\n            } catch {\n              await message.channel.send({ content: levelMessage });\n            }\n          } else {\n            try {\n              if (levelData) {\n                await client.channels.cache\n                  .get(levelData.Channel)\n                  .send({\n                    content: `**GG** <@!${message.author.id}>, you are now level **${user.level}**`,\n                  })\n                  .catch(() => { });\n              } else {\n                message.channel.send({\n                  content: `**GG** <@!${message.author.id}>, you are now level **${user.level}**`,\n                });\n              }\n            } catch {\n              message.channel.send({\n                content: `**GG** <@!${message.author.id}>, you are now level **${user.level}**`,\n              });\n            }\n          }\n\n          levelRewards.findOne(\n            { Guild: message.guild.id, Level: user.level },\n            async (err, data) => {\n              if (data) {\n                message.guild.members.cache\n                  .get(message.author.id)\n                  .roles.add(data.Role)\n                  .catch((e) => { });\n              }\n            }\n          );\n        }\n      }\n    }\n  });\n\n  // Message tracker system\n  messagesSchema.findOne(\n    { Guild: message.guild.id, User: message.author.id },\n    async (err, data) => {\n      if (data) {\n        data.Messages += 1;\n        data.save();\n\n        messageRewards.findOne(\n          { Guild: message.guild.id, Messages: data.Messages },\n          async (err, data) => {\n            if (data) {\n              try {\n                message.guild.members.cache\n                  .get(message.author.id)\n                  .roles.add(data.Role);\n              } catch { }\n            }\n          }\n        );\n      } else {\n        new messagesSchema({\n          Guild: message.guild.id,\n          User: message.author.id,\n          Messages: 1,\n        }).save();\n      }\n    }\n  );\n\n  // AFK system\n  afk.findOne(\n    { Guild: message.guild.id, User: message.author.id },\n    async (err, data) => {\n      if (data) {\n        await afk.deleteOne({\n          Guild: message.guild.id,\n          User: message.author.id,\n        });\n\n        client\n          .simpleEmbed(\n            {\n              desc: `${message.author} is no longer afk!`,\n            },\n            message.channel\n          )\n          .then(async (m) => {\n            setTimeout(() => {\n              m.delete();\n            }, 5000);\n          });\n\n        if (message.member.displayName.startsWith(`[AFK] `)) {\n          let name = message.member.displayName.replace(`[AFK] `, ``);\n          message.member.setNickname(name).catch((e) => { });\n        }\n      }\n    }\n  );\n\n  message.mentions.users.forEach(async (u) => {\n    if (\n      !message.content.includes(\"@here\") &&\n      !message.content.includes(\"@everyone\")\n    ) {\n      afk.findOne(\n        { Guild: message.guild.id, User: u.id },\n        async (err, data) => {\n          if (data) {\n            client.simpleEmbed(\n              { desc: `${u} is currently afk! **Reason:** ${data.Message}` },\n              message.channel\n            );\n          }\n        }\n      );\n    }\n  });\n\n  // Chat bot\n  chatBotSchema.findOne({ Guild: message.guild.id }, async (err, data) => {\n    if (!data) return;\n    if (message.channel.id !== data.Channel) return;\n    if (process.env.OPENAI) {\n      fetch(\n        `https://api.openai.com/v1/completions`,\n        {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'Authorization': 'Bearer ' + process.env.OPENAI,\n          },\n          // body: '{\\n  \"model\": \"text-davinci-003\",\\n  \"prompt\": \"What is your name?\",\\n  \"max_tokens\": 4000,\\n  \"temperature\": 0\\n}',\n          body: JSON.stringify({\n            'model': 'text-davinci-003',\n            'prompt': message.content,\n            'temperature': 0,\n            'max_tokens': 256,\n            'top_p': 1,\n            'frequency_penalty': 0,\n            'presence_penalty': 0,\n          })\n        }\n      )\n        .catch(() => {\n        })\n        .then((res) => {\n          res.json().then((data) => {\n            if(data.error) return console.log(data.error);\n            message.reply({ content: data.choices[0].text });\n          });\n        });\n    } else {\n      try {\n        const input = message;\n        try {\n          fetch(\n            `https://api.coreware.nl/fun/chat?msg=${encodeURIComponent(input)}&uid=${message.author.id}`,\n          )\n            .catch(() => { console.log })\n            .then((res) => res.json())\n            .catch(() => { console.log})\n            .then(async (json) => {\n              console.log(json);\n              if (json) {\n                if (\n                  json.response !== \" \" ||\n                  json.response !== undefined ||\n                  json.response !== \"\" ||\n                  json.response !== null\n                ) {\n                  try {\n                    return message\n                      .reply({ content: json.response })\n                      .catch(() => { });\n                  } catch { }\n                }\n              }\n            })\n            .catch(() => { });\n        } catch { }\n      } catch { }\n    }\n  });\n\n  // Sticky messages\n  try {\n    Schema.findOne(\n      { Guild: message.guild.id, Channel: message.channel.id },\n      async (err, data) => {\n        if (!data) return;\n\n        const lastStickyMessage = await message.channel.messages\n          .fetch(data.LastMessage)\n          .catch(() => { });\n        if (!lastStickyMessage) return;\n        await lastStickyMessage.delete({ timeout: 1000 });\n\n        const newMessage = await client.simpleEmbed(\n          { desc: `${data.Content}` },\n          message.channel\n        );\n\n        data.LastMessage = newMessage.id;\n        data.save();\n      }\n    );\n  } catch { }\n\n  // Prefix\n  var guildSettings = await Functions.findOne({ Guild: message.guild.id });\n  if (!guildSettings) {\n    new Functions({\n      Guild: message.guild.id,\n      Prefix: client.config.discord.prefix,\n    }).save();\n\n    guildSettings = await Functions.findOne({ Guild: message.guild.id });\n  }\n\n  if (!guildSettings || !guildSettings.Prefix) {\n    Functions.findOne({ Guild: message.guild.id }, async (err, data) => {\n      data.Prefix = client.config.discord.prefix;\n      data.save();\n    });\n\n    guildSettings = await Functions.findOne({ Guild: message.guild.id });\n  }\n\n  if (!guildSettings || !guildSettings.Prefix) {\n    var prefix = client.config.Discord.prefix;\n  } else {\n    var prefix = guildSettings.Prefix;\n  }\n\n  const escapeRegex = (str) => str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n  const prefixRegex = new RegExp(\n    `^(<@!?${client.user.id}>|${escapeRegex(prefix)})\\\\s*`\n  );\n\n  if (!prefixRegex.test(message.content.toLowerCase())) return;\n  const [, matchedPrefix] = message.content.toLowerCase().match(prefixRegex);\n\n  const args = message.content.slice(matchedPrefix.length).trim().split(/ +/g);\n  const command = args.shift().toLowerCase();\n\n  if (\n    message.mentions.users.first() &&\n    message.mentions.users.first().id == client.user.id &&\n    command.length === 0\n  ) {\n    let row = new Discord.ActionRowBuilder().addComponents(\n      new Discord.ButtonBuilder()\n        .setLabel(\"Invite\")\n        .setURL(\n          client.config.discord.botInvite\n        )\n        .setStyle(Discord.ButtonStyle.Link),\n\n      new Discord.ButtonBuilder()\n        .setLabel(\"Support server\")\n        .setURL(client.config.discord.serverInvite)\n        .setStyle(Discord.ButtonStyle.Link)\n    );\n\n    client\n      .embed(\n        {\n          title: \"Hi, i'm Bot\",\n          desc: `Use with commands via Discord ${client.emotes.normal.slash} commands`,\n          fields: [\n            {\n              name: \"📨┆Invite me\",\n              value: `Invite Bot in your own server! [Click here](${client.config.discord.botInvite})`,\n            },\n            {\n              name: \"❓┇I don't see any slash commands\",\n              value:\n                \"The bot may not have permissions for this. Open the invite link again and select your server. The bot then gets the correct permissions\",\n            },\n            {\n              name: \"❓┆Need support?\",\n              value: `For questions you can join our [support server](${client.config.discord.serverInvite})!`,\n            },\n            {\n              name: \"🐞┆Found a bug?\",\n              value: `Report all bugs via: \\`/report bug\\`!`,\n            },\n          ],\n          components: [row],\n        },\n        message.channel\n      )\n      .catch(() => { });\n  }\n\n  const cmd = await Commands.findOne({\n    Guild: message.guild.id,\n    Name: command,\n  });\n  if (cmd) {\n    return message.channel.send({ content: cmdx.Responce });\n  }\n\n  const cmdx = await CommandsSchema.findOne({\n    Guild: message.guild.id,\n    Name: command,\n  });\n  if (cmdx) {\n    if (cmdx.Action == \"Normal\") {\n      return message.channel.send({ content: cmdx.Responce });\n    } else if (cmdx.Action == \"Embed\") {\n      return client.simpleEmbed(\n        {\n          desc: `${cmdx.Responce}`,\n        },\n        message.channel\n      );\n    } else if (cmdx.Action == \"DM\") {\n      return message.author.send({ content: cmdx.Responce }).catch((e) => {\n        client.errNormal(\n          {\n            error: \"I can't DM you, maybe you have DM turned off!\",\n          },\n          message.channel\n        );\n      });\n    }\n  }\n};\n\n\n","size_bytes":13191},"src/events/message/messageDelete.js":{"content":"const discord = require('discord.js');\n\nmodule.exports = async (client, messageDeleted) => {\n    try {\n        if (!messageDeleted) return;\n        if (messageDeleted.author.bot) return;\n\n        var content = messageDeleted.content;\n        if (!content) content = \"No text to be found\";\n\n        if (messageDeleted.attachments.size > 0) content = messageDeleted.attachments.first()?.url;\n\n        const logsChannel = await client.getLogs(messageDeleted.guild.id);\n        if (!logsChannel) return;\n\n        client.embed({\n            title: `💬・Message deleted`,\n            desc: `A message has been deleted`,\n            fields: [\n                {\n                    name: `> Author`,\n                    value: `- ${messageDeleted.author} (${messageDeleted.author.tag})`\n                },\n                {\n                    name: `> Date`,\n                    value: `- ${messageDeleted.createdAt}`\n                },\n                {\n                    name: `> Channel`,\n                    value: `- ${messageDeleted.channel} (${messageDeleted.channel.name})`\n                },\n                {\n                    name: `> Message`,\n                    value: `\\`\\`\\`${content.replace(/`/g, \"'\")}\\`\\`\\``\n                },\n                {\n                    name: `> Timestamp`,\n                    value: `- <t:${Math.floor(messageDeleted.createdTimestamp / 1000)}:R>`\n                }\n            ]\n        }, logsChannel).catch(() => { })\n    }\n    catch { }\n};","size_bytes":1491},"src/events/message/messageReactionAdd.js":{"content":"const Discord = require(\"discord.js\");\n\nconst StarBoard = require(\"../../database/models/starboardChannels\");\n\nmodule.exports = async (client, reaction, user) => {\n  if (reaction.message.partial) await reaction.message.fetch().catch(() => { });\n  if (reaction.partial) await reaction.fetch().catch(() => { });\n\n  if (reaction.emoji.name === \"⭐\") {\n\tconst data = await StarBoard.findOne({ Guild: reaction.message.guild.id });\n    if (!data) return;\n      \n    if (reaction.message.author.id === user.id)\n      return client.errNormal({\n        error: `You cannot star your own messages\\n\\nMessage: ${reaction.message.cleanContent}`,\n      }, client.users.cache.get(user.id));\n\n    if (reaction.message.author.bot) return client.errNormal({\n      error: `You cannot star bot messages\\n\\nMessage: ${reaction.message.cleanContent}`,\n    }, client.users.cache.get(user.id));\n\n    const starboardChannel = reaction.message.guild.channels.cache.get(data.Channel);\n    if (!starboardChannel) return client.errNormal({\n      error: `No star channel found! Run the channel setup`,\n    }, client.users.cache.get(user.id));\n\n    const fetch = await starboardChannel.messages.fetch({ limit: 100 });\n    const stars = fetch.find(m =>\n      m.embeds[0] &&\n      m.embeds[0].footer &&\n      m.embeds[0].footer.text.endsWith(reaction.message.id)\n    );\n\n    if (stars) {\n      const foundStar = stars.embeds[0];\n      const image = reaction.message.attachments.size > 0 ? await extension(reaction, reaction.message.attachments.first()?.url) : \"\";\n      const starMsg = await starboardChannel.messages.fetch(stars.id);\n      client.embed({\n        title: `⭐・Starboard`,\n        desc: foundStar.description,\n        image: image,\n        fields: [\n          {\n            name: `⭐┇Stars`,\n            value: `${reaction.count}`,\n            inline: true\n          },\n          {\n            name: `🗨️┇Message`,\n            value: `[Jump to the message](${reaction.message.url})`,\n            inline: true\n          },\n          {\n            name: `👤┇Author`,\n            value: `${reaction.message.author} (${reaction.message.author.tag})`,\n            inline: true\n          }\n        ],\n        footer: `${client.config.discord.footer} | ${reaction.message.id}`,\n        type: 'edit'\n      }, starMsg)\n    }\n    if (!stars) {\n      const image = reaction.message.attachments.size > 0 ? await extension(reaction, reaction.message.attachments.first()?.url) : \"\";\n      if (image === \"\" && reaction.message.cleanContent.length < 1) return client.errNormal({\n        error: `You cannot star an empty message`,\n        type: 'ephemeral'\n      }, reaction.message);\n\n      client.embed({\n        title: `⭐・Starboard`,\n        desc: reaction.message.cleanContent,\n        image: image,\n        fields: [\n          {\n            name: `⭐┇Stars`,\n            value: `${reaction.count}`,\n            inline: true\n          },\n          {\n            name: `🗨️┇Message`,\n            value: `[Jump to the message](${reaction.message.url})`,\n            inline: true\n          },\n          {\n            name: `👤┇Author`,\n            value: `${reaction.message.author} (${reaction.message.author.tag})`,\n            inline: true\n          }\n        ],\n        footer: `${client.config.discord.footer} | ${reaction.message.id}`\n      }, starboardChannel)\n    }\n  }\n};\n\nfunction extension(reaction, attachment) {\n  const imageLink = attachment.split(\".\");\n  const typeOfImage = imageLink[imageLink.length - 1];\n  const image = /(jpg|jpeg|png|gif)/gi.test(typeOfImage);\n  if (!image) return \"\";\n  return attachment;\n}\n\n \n","size_bytes":3631},"src/events/message/messageReactionRemove.js":{"content":"const Discord = require(\"discord.js\");\n\nconst StarBoard = require(\"../../database/models/starboardChannels\");\n\nmodule.exports = async (client, reaction, user) => {\n  if (reaction.message.partial) await reaction.message.fetch().catch(() => { });\n  if (reaction.partial) await reaction.fetch().catch(() => { });\n\n  if (reaction.emoji.name === \"⭐\") {\n    if (reaction.message.author.id === user.id) return;\n    if (reaction.message.author.bot) return;\n\n    const data = await StarBoard.findOne({ Guild: reaction.message.guild.id });\n    if (!data) return;\n\n    const starboardChannel = reaction.message.guild.channels.cache.get(data.Channel);\n    if (!starboardChannel) return;\n\n    const fetch = await starboardChannel.messages.fetch({ limit: 100 });\n    const stars = fetch.find(m =>\n      m.embeds[0] &&\n      m.embeds[0].footer &&\n      m.embeds[0].footer.text.endsWith(reaction.message.id)\n    );\n\n    if (stars) {\n      const foundStar = stars.embeds[0];\n      const image = reaction.message.attachments.size > 0 ? await extension(reaction, reaction.message.attachments.first()?.url) : \"\";\n      const starMsg = await starboardChannel.messages.fetch(stars.id);\n      \n      if (reaction.count <= 0) {\n        starMsg.delete();\n      }\n      else {\n        client.embed({\n          title: `⭐・Starboard`,\n          desc: foundStar.description,\n          image: image,\n          fields: [\n            {\n              name: `⭐┇Stars`,\n              value: `${reaction.count}`,\n              inline: true\n            },\n            {\n              name: `🗨️┇Message`,\n              value: `[Jump to the message](${reaction.message.url})`,\n              inline: true\n            },\n            {\n              name: `👤┇Author`,\n              value: `${reaction.message.author} (${reaction.message.author.tag})`,\n              inline: true\n            }\n          ],\n          footer: `${client.config.discord.footer} | ${reaction.message.id}`,\n          type: 'edit'\n        }, starMsg)\n      }\n    }\n  }\n};\n\nfunction extension(reaction, attachment) {\n  const imageLink = attachment.split(\".\");\n  const typeOfImage = imageLink[imageLink.length - 1];\n  const image = /(jpg|jpeg|png|gif)/gi.test(typeOfImage);\n  if (!image) return \"\";\n  return attachment;\n}\n\n \n","size_bytes":2278},"src/events/message/messageUpdate.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, oldMessage, newMessage) => {\n    try {\n        if (!oldMessage.content || !newMessage.content) return;\n        if (oldMessage.content === newMessage.content) return;\n        if (oldMessage.author.bot) return;\n\n        const logsChannel = await client.getLogs(oldMessage.guild.id);\n        if (!logsChannel) return;\n\nlet row = new Discord.ActionRowBuilder()\n                .addComponents(\n                    new Discord.ButtonBuilder()\n                        .setEmoji(\"🔗\")\n                        .setLabel(\"Jump to the Message\")\n                        .setURL(`https://discordapp.com/channels/${newMessage.guild.id}/${newMessage.channel.id}/${newMessage.id}`)\n                        .setStyle(Discord.ButtonStyle.Link),\n                  );\n      \n        client.embed({\n            title: `💬・Message updated`,\n            desc: `A message has been updated`,\n            fields: [\n                {\n                    name: `> Author`,\n                    value: `- ${newMessage.member.user} (${newMessage.member.user.tag})`\n                },\n                {\n                    name: `> Date`,\n                    value: `- ${newMessage.createdAt}`\n                },\n                {\n                    name: `> Channel`,\n                    value: `- ${newMessage.channel} (${newMessage.channel.name})`\n                },\n                {\n                    name: `> Old message`,\n                    value: `\\`\\`\\`${oldMessage.content.replace(/`/g, \"'\")}\\`\\`\\``\n                },\n                {\n                    name: `> New message`,\n                    value: `\\`\\`\\`${newMessage.content.replace(/`/g, \"'\")}\\`\\`\\``\n                },\n                {\n                    name: `> Timestamp`,\n                    value: `- <t:${Math.floor(newMessage.createdTimestamp / 1000)}:R>`\n                }\n            ],\n            components: [row]\n        }, logsChannel).catch(() => { })\n    }\n    catch { }\n};\n","size_bytes":2014},"src/events/music/nodeConnect.js":{"content":"const Discord = require('discord.js');\nconst chalk = require('chalk');\n\nmodule.exports = (client, node) => {\n    console.log(chalk.blue(chalk.bold(`System`)), (chalk.white(`>>`)), chalk.red(`Lavalink`), chalk.green(`connected!`))\n};","size_bytes":232},"src/events/music/nodeError.js":{"content":"const Discord = require('discord.js');\nconst chalk = require('chalk');\n\nmodule.exports = (client, node, error) => {\n    console.log(chalk.red(chalk.bold(`ERROR`)), (chalk.white(`>>`)), chalk.white(`Node`), chalk.red(`${node.options.identifier}`), chalk.white(`had an error:`), chalk.red(`${error.message}`))\n};","size_bytes":310},"src/events/music/playerDisconnect.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = (client, player, track) => {\n    console.log(player)\n    player.destroy();\n\n    const channel = client.channels.cache.get(player.textChannel);\n    client.errNormal({\n        error: \"Music has stopped. I'm disconnected from the channel\"\n    }, channel)\n};","size_bytes":311},"src/events/music/playerMove.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = (client, player, currentChannel, newChannel) => {\n    if (!newChannel) {\n        player.destroy();\n\n        const channel = client.channels.cache.get(player.textChannel);\n        client.errNormal({\n            error: \"Music has stopped. I'm disconnected from the channel\"\n        }, channel)\n    } else {\n        player.set('moved', true)\n        player.setVoiceChannel(newChannel);\n        if (player.paused) return;\n        setTimeout(() => {\n            player.pause(true);\n            setTimeout(() => player.pause(false), client.ws.ping * 2);\n        }, client.ws.ping * 2);\n    }\n};","size_bytes":645},"src/events/music/queueEnd.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = (client, player, track) => {\n    player.destroy(player.guild.id);\n\n    const channel = client.channels.cache.get(player.textChannel);\n    client.errNormal({\n        error: \"Queue is empty, Leaving voice channel\"\n    }, channel)\n};","size_bytes":287},"src/events/music/trackStart.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = (client, player, track) => {\n    let row = new Discord.ActionRowBuilder()\n        .addComponents(\n            new Discord.ButtonBuilder()\n                .setEmoji(client.emotes.music.previous)\n                .setCustomId(\"Bot-musicprev\")\n                .setStyle(Discord.ButtonStyle.Secondary),\n\n            new Discord.ButtonBuilder()\n                .setEmoji(client.emotes.music.pause)\n                .setCustomId(\"Bot-musicpause\")\n                .setStyle(Discord.ButtonStyle.Secondary),\n\n            new Discord.ButtonBuilder()\n                .setEmoji(client.emotes.music.stop)\n                .setCustomId(\"Bot-musicstop\")\n                .setStyle(Discord.ButtonStyle.Secondary),\n\n            new Discord.ButtonBuilder()\n                .setEmoji(client.emotes.music.next)\n                .setCustomId(\"Bot-musicnext\")\n                .setStyle(Discord.ButtonStyle.Secondary),\n        );\n\n    const channel = client.channels.cache.get(player.textChannel);\n\n    client.embed({\n        title: `${client.emotes.normal.music}・${track.title}`,\n        url: track.uri,\n        desc: `Music started in <#${player.voiceChannel}>!`,\n        thumbnail: track.thumbnail,\n        fields: [\n            {\n                name: `👤┆Requested By`,\n                value: `${track.requester}`,\n                inline: true\n            },\n            {\n                name: `${client.emotes.normal.clock}┆Ends at`,\n                value: `<t:${((Date.now() / 1000) + (track.duration / 1000)).toFixed(0)}:f>`,\n                inline: true\n            },\n            {\n                name: `🎬┆Author`,\n                value: `${track.author}`,\n                inline: true\n            }\n        ],\n        components: [row],\n    }, channel)\n};","size_bytes":1810},"src/events/role/roleColorUpdate.js":{"content":"const discord = require('discord.js');\n\nmodule.exports = async (client, role, oldColor, newColor) => {\n    const logsChannel = await client.getLogs(role.guild.id);\n    if (!logsChannel) return;\n\n    client.embed({\n        title: `🧻・Role color updated`,\n        desc: `A role has been updated`,\n        fields: [\n            {\n                name: `> Role`,\n                value: `- ${role}`\n            },\n            {\n                name: `> Before`,\n                value: `- #${oldColor.toString(16)}`\n            },\n            {\n                name: `> After`,\n                value: `- #${newColor.toString(16)}`\n            },\n            {\n                name: `> ID`,\n                value: `${role.id}`\n            },\n            {\n                name: `> Timestamp`,\n                value: `- <t:${Math.floor(Date.now() / 1000)}:R>`\n            }\n        ]\n    }, logsChannel).catch(() => { })\n};","size_bytes":919},"src/events/role/roleCreate.js":{"content":"const discord = require('discord.js');\n\nmodule.exports = async (client, role) => {\n    const logsChannel = await client.getLogs(role.guild.id);\n    if (!logsChannel) return;\n\n    client.embed({\n        title: `🧻・Role created`,\n        desc: `A role has been created`,\n        fields: [\n            {\n                name: `> Role`,\n                value: `- ${role}`\n            },\n            {\n                name: `> Name`,\n                value: `- ${role.name}`\n            },\n            {\n                name: `> ID`,\n                value: `- ${role.id}`\n            },\n            {\n                name: `> Color`,\n                value: `${role.hexColor}`\n            },\n            {\n                name: `> Position`,\n                value: `${role.position}`\n            },\n            {\n                name: `> Timestamp`,\n                value: `- <t:${Math.floor(Date.now() / 1000)}:R>`\n            }\n        ]\n    }, logsChannel).catch(() => { })\n\n};","size_bytes":977},"src/events/role/roleDelete.js":{"content":"const discord = require('discord.js');\n\nmodule.exports = async (client, role) => {\n    const logsChannel = await client.getLogs(role.guild.id);\n    if (!logsChannel) return;\n\n    client.embed({\n        title: `🧻・Role deleted`,\n        desc: `A role has been deleted`,\n        fields: [\n            {\n                name: `> Role`,\n                value: `- ${role}`\n            },\n            {\n                name: `> Name`,\n                value: `- ${role.name}`\n            },\n            {\n                name: `> ID`,\n                value: `- ${role.id}`\n            },\n            {\n                name: `> Color`,\n                value: `${role.hexColor}`\n            },\n            {\n                name: `> Position`,\n                value: `${role.position}`\n            },\n            {\n                name: `> Timestamp`,\n                value: `- <t:${Math.floor(Date.now() / 1000)}:R>`\n            }\n        ]\n    }, logsChannel).catch(() => { })\n};","size_bytes":976},"src/events/role/roleNameUpdate.js":{"content":"const discord = require('discord.js');\n\nmodule.exports = async (client, role, oldName, newName) => {\n    const logsChannel = await client.getLogs(role.guild.id);\n    if (!logsChannel) return;\n\n    client.embed({\n        title: `🧻・Role name updated`,\n        desc: `A role has been updated`,\n        fields: [\n            {\n                name: `> Role`,\n                value: `- ${role}`\n            },\n            {\n                name: `> Before`,\n                value: `- ${oldName}`\n            },\n            {\n                name: `> After`,\n                value: `- ${newName}`\n            },\n            {\n                name: `> ID`,\n                value: `${role.id}`\n            },\n            {\n                name: `> Timestamp`,\n                value: `- <t:${Math.floor(Date.now() / 1000)}:R>`\n            }\n        ]\n    }, logsChannel).catch(() => { })\n};","size_bytes":886},"src/events/role/rolePermissionsUpdate.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client, role, oldPerms, newPerms) => {\n\n    const logsChannel = await client.getLogs(role.guild.id);\n    if (!logsChannel) return;\n\n    client.embed({\n        title: `🧻・Role permissions updated`,\n        desc: `A role has been updated`,\n        fields: [\n            {\n                name: `> Role`,\n                value: `- ${role}`\n            },\n            {\n                name: `> Before`,\n                value: `- ${new Discord.PermissionsBitField(oldPerms).toArray().toLocaleString().split(',').join(', ') || 'None'}`\n            },\n            {\n                name: `> After`,\n                value: `- ${new Discord.PermissionsBitField(newPerms).toArray().toLocaleString().split(',').join(', ') || 'None'}`\n            },\n            {\n                name: `> ID`,\n                value: `${role.id}`\n            },\n            {\n                name: `> Timestamp`,\n                value: `<t:${Math.floor(Date.now() / 1000)}:R>`\n            }\n        ]\n    }, logsChannel).catch(() => { })\n};","size_bytes":1080},"src/events/stats/updateAEmojis.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/stats\");\n\nmodule.exports = async (client, emoji, guild) => {\n    if (emoji.animated) {\n        try {\n            let Animated = 0;\n\n            function Emoji(id) {\n                return client.emojis.cache.get(id).toString();\n            }\n\n            guild.emojis.cache.forEach((emoji) => {\n                if (emoji.animated) {\n                    Animated++;\n                }\n            });\n\n            var channelName = await client.getTemplate(guild);\n            channelName = channelName.replace(`{emoji}`, \"🤡\")\n            channelName = channelName.replace(`{name}`, `Animated Emojis: ${Animated || '0'}`)\n\n            const data = await Schema.findOne({ Guild: guild.id });\n            const channel = guild.channels.cache.get(data.AnimatedEmojis)\n            await channel.setName(channelName)\n        }\n        catch { }\n    }\n};","size_bytes":935},"src/events/stats/updateBoosts.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/stats\");\n\nmodule.exports = async (client, guild) => {\n    try {\n        var channelName = await client.getTemplate(guild);\n        channelName = channelName.replace(`{emoji}`, \"💎\")\n        channelName = channelName.replace(`{name}`, `Boosts: ${guild.premiumSubscriptionCount || '0'}`)\n\n        const data = await Schema.findOne({ Guild: guild.id });\n        const channel = guild.channels.cache.get(data.Boost)\n        await channel.setName(channelName)\n    }\n    catch { }\n};","size_bytes":565},"src/events/stats/updateBots.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/stats\");\n\nmodule.exports = async (client, guild) => {\n    try {\n        const members = await guild.members.fetch();\n\n        var channelName = await client.getTemplate(guild);\n        channelName = channelName.replace(`{emoji}`, \"🤖\")\n        channelName = channelName.replace(`{name}`, `Bots: ${members.filter(member => member.user.bot).size || 0}`)\n\n        const data = await Schema.findOne({ Guild: guild.id });\n        const channel = guild.channels.cache.get(data.Bots)\n        await channel.setName(channelName)\n    }\n    catch { }\n};","size_bytes":630},"src/events/stats/updateChannels.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/stats\");\n\nmodule.exports = async (client, channel) => {\n    try {\n        var channelName = await client.getTemplate(channel.guild);\n        channelName = channelName.replace(`{emoji}`, \"🔧\")\n        channelName = channelName.replace(`{name}`, `Channels: ${channel.guild.channels.cache.size.toLocaleString()}`)\n\n        const data = await Schema.findOne({ Guild: channel.guild.id });\n        const changeChannel = channel.guild.channels.cache.get(data.Channels)\n        await changeChannel.setName(channelName)\n    }\n    catch { }\n};","size_bytes":621},"src/events/stats/updateClock.js":{"content":"const Discord = require('discord.js');\nconst moment = require('moment');\nconst tz = require('moment-timezone');\n\nconst Schema = require(\"../../database/models/stats\");\n\nmodule.exports = async (client) => {\n    try {\n        setInterval(async () => {\n            const data = await Schema.find();\n\n            if (data) {\n                data.forEach(async d => {\n                    if (!d.TimeZone || !d.Time) return;\n                    try {\n                        const timeNow = moment().tz(d.TimeZone).format(\"HH:mm (z)\");\n                        const guild = client.guilds.cache.get(d.Guild);\n\n                        var channelName = await client.getTemplate(guild);\n                        channelName = channelName.replace(`{emoji}`, \"⏰\")\n                        channelName = channelName.replace(`{name}`, `${timeNow}`)\n\n                        const channel = guild.channels.cache.get(d.Time)\n                        await channel.setName(channelName)\n                    }\n                    catch (e) { }\n                })\n            }\n        }, 600000);\n    }\n    catch (err) { }\n};","size_bytes":1106},"src/events/stats/updateEmojis.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/stats\");\n\nmodule.exports = async (client, emoji, guild) => {\n    try {\n        var channelName = await client.getTemplate(guild);\n        channelName = channelName.replace(`{emoji}`, \"😛\")\n        channelName = channelName.replace(`{name}`, `Emojis: ${guild.emojis.cache.size || '0'}`)\n\n        const data = await Schema.findOne({ Guild: guild.id });\n        const channel = guild.channels.cache.get(data.Emojis)\n        await channel.setName(channelName)\n    }\n    catch { }\n};","size_bytes":566},"src/events/stats/updateMembers.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/stats\");\n\nmodule.exports = async (client, guild) => {\n    try {\n        var channelName = await client.getTemplate(guild);\n        channelName = channelName.replace(`{emoji}`, \"👤\")\n        channelName = channelName.replace(`{name}`, `Members: ${guild.memberCount.toLocaleString()}`)\n\n        const data = await Schema.findOne({ Guild: guild.id });\n        const channel = guild.channels.cache.get(data.Members)\n        await channel.setName(channelName)\n    }\n    catch { }\n};","size_bytes":565},"src/events/stats/updateNewsChannels.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/stats\");\n\nmodule.exports = async (client, channel, guild) => {\n    if (channel.type ==  Discord.ChannelType.GuildAnnouncement) {\n        try {\n            var channelName = await client.getTemplate(guild);\n            channelName = channelName.replace(`{emoji}`, \"📢\")\n            channelName = channelName.replace(`{name}`, `News Channels: ${guild.channels.cache.filter(channel => channel.type ===  Discord.ChannelType.GuildAnnouncement).size || 0}`)\n\n            const data = await Schema.findOne({ Guild: guild.id });\n            const changeChannel = guild.channels.cache.get(data.NewsChannels)\n            await changeChannel.setName(channelName)\n        }\n        catch { }\n    }\n};","size_bytes":776},"src/events/stats/updateRoles.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/stats\");\n\nmodule.exports = async (client, guild) => {\n    try {\n        var channelName = await client.getTemplate(guild);\n        channelName = channelName.replace(`{emoji}`, \"👔\")\n        channelName = channelName.replace(`{name}`, `Roles: ${guild.roles.cache.size}`)\n\n        const data = await Schema.findOne({ Guild: guild.id });\n        const channel = guild.channels.cache.get(data.Roles)\n        await channel.setName(channelName)\n    }\n    catch { }\n};","size_bytes":549},"src/events/stats/updateSEmojis.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/stats\");\n\nmodule.exports = async (client, emoji, guild) => {\n    if (!emoji.animated) {\n        try {\n            let EmojiCount = 0;\n\n            function Emoji(id) {\n                return client.emojis.cache.get(id).toString();\n            }\n\n            guild.emojis.cache.forEach((emoji) => {\n                if (!emoji.animated) {\n                    EmojiCount++;\n                }\n            });\n\n            var channelName = await client.getTemplate(guild);\n            channelName = channelName.replace(`{emoji}`, \"🤡\")\n            channelName = channelName.replace(`{name}`, `Animated Emojis: ${Animated || '0'}`)\n\n            const data = await Schema.findOne({ Guild: guild.id });\n            const channel = guild.channels.cache.get(data.StaticEmojis)\n            await channel.setName(channelName)\n        }\n        catch { }\n    }\n};","size_bytes":939},"src/events/stats/updateStageChannels.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/stats\");\n\nmodule.exports = async (client, channel, guild) => {\n    if (channel.type ==  Discord.ChannelType.GuildStageVoice) {\n        try {\n            var channelName = await client.getTemplate(guild);\n            channelName = channelName.replace(`{emoji}`, \"🎤\")\n            channelName = channelName.replace(`{name}`, `Stage Channels: ${guild.channels.cache.filter(channel => channel.type ===  Discord.ChannelType.GuildStageVoice).size || 0}`)\n\n            const data = await Schema.findOne({ Guild: guild.id });\n            const changeChannel = guild.channels.cache.get(data.StageChannels)\n            await changeChannel.setName(channelName)\n        }\n        catch { }\n    }\n};","size_bytes":774},"src/events/stats/updateTextChannels.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/stats\");\n\nmodule.exports = async (client, channel, guild) => {\n    if (channel.type == Discord.ChannelType.GuildText) {\n        try {\n            var channelName = await client.getTemplate(guild);\n            channelName = channelName.replace(`{emoji}`, \"💬\")\n            channelName = channelName.replace(`{name}`, `Text Channels: ${guild.channels.cache.filter(channel => channel.type === Discord.ChannelType.GuildText).size || 0}`)\n\n            const data = await Schema.findOne({ Guild: guild.id });\n            const changeChannel = guild.channels.cache.get(data.TextChannels)\n            await changeChannel.setName(channelName)\n        }\n        catch { }\n    }\n};","size_bytes":758},"src/events/stats/updateTier.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/stats\");\n\nmodule.exports = async (client, guild) => {\n    let tier = {\n        \"TIER_1\": `1`,\n        \"TIER_2\": `2`,\n        \"TIER_3\": `3`,\n        \"NONE\": `0`,\n    }\n\n    try {\n        var channelName = await client.getTemplate(guild);\n        channelName = channelName.replace(`{emoji}`, \"🥇\")\n        channelName = channelName.replace(`{name}`, `Tier: ${tier[guild.premiumTier] || '0'}`)\n\n        const data = await Schema.findOne({ Guild: guild.id });\n        const channel = guild.channels.cache.get(data.BoostTier)\n        await channel.setName(channelName)\n    }\n    catch { }\n};","size_bytes":674},"src/events/stats/updateVoiceChannels.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/stats\");\n\nmodule.exports = async (client, channel, guild) => {\n    if (channel.type ==  Discord.ChannelType.GuildVoice) {\n        try {\n            var channelName = await client.getTemplate(guild);\n            channelName = channelName.replace(`{emoji}`, \"🔊\")\n            channelName = channelName.replace(`{name}`, `Voice Channels: ${guild.channels.cache.filter(channel => channel.type ===  Discord.ChannelType.GuildVoice).size || 0}`)\n\n            const data = await Schema.findOne({ Guild: guild.id });\n            const changeChannel = guild.channels.cache.get(data.VoiceChannels)\n            await changeChannel.setName(channelName)\n        }\n        catch { }\n    }\n};","size_bytes":764},"src/events/sticker/stickerCreate.js":{"content":"const discord = require('discord.js');\n\nmodule.exports = async (client, sticker) => {\n    const logsChannel = await client.getLogs(sticker.guild.id);\n    if (!logsChannel) return;\n\n    client.embed({\n        title: `😜・Sticker created`,\n        desc: `A sticker has been created`,\n        fields: [\n            {\n                name: `> Name`,\n                value: `- ${sticker.name}`\n            },\n            {\n                name: `> ID`,\n                value: `- ${sticker.id}`\n            },\n            {\n                name: `> Url`,\n                value: `${sticker.url}`\n            }\n        ]\n    }, logsChannel).catch(() => { })\n};","size_bytes":655},"src/events/sticker/stickerDelete.js":{"content":"const discord = require('discord.js');\n\nmodule.exports = async (client, sticker) => {\n    const logsChannel = await client.getLogs(sticker.guild.id);\n    if (!logsChannel) return;\n\n    client.embed({\n        title: `😜・Sticker deleted`,\n        desc: `A sticker has been deleted`,\n        fields: [\n            {\n                name: `> Name`,\n                value: `- ${sticker.name}`\n            },\n            {\n                name: `> ID`,\n                value: `- ${sticker.id}`\n            }\n        ]\n    }, logsChannel).catch(() => { })\n};","size_bytes":555},"src/events/sticker/stickerUpdate.js":{"content":"const discord = require('discord.js');\n\nmodule.exports = async (client, oldSticker, newSticker) => {\n    const logsChannel = await client.getLogs(newSticker.guild.id);\n    if (!logsChannel) return;\n\n    client.embed({\n        title: `😜・Sticker updated`,\n        desc: `A sticker has been updated`,\n        fields: [\n            {\n                name: `> Before`,\n                value: `- ${oldSticker.name}`\n            },\n            {\n                name: `> After`,\n                value: `- ${newSticker.name}`\n            },\n            {\n                name: `> ID`,\n                value: `- ${newSticker.id}`\n            }\n        ]\n    }, logsChannel).catch(() => { })\n};","size_bytes":689},"src/events/thread/threadCreate.js":{"content":"const discord = require('discord.js');\n\nmodule.exports = async (client, channel) => {\n    let types = {\n        10: \"News Thread\",\n        11: \"Public Thread\",\n        12: \"Private Thread\",\n    }\n\n    const logsChannel = await client.getLogs(channel.guild.id);\n    if (!logsChannel) return;\n\n    client.embed({\n        title: `📖・Thread created`,\n        desc: `A thread has been created`,\n        fields: [\n            {\n                name: `> Name`,\n                value: `- ${channel.name}`\n            },\n            {\n                name: `> ID`,\n                value: `- ${channel.id}`\n            },\n            {\n                name: `> Category`,\n                value: `${channel.parent}`\n            },\n            {\n                name: `> Channel`,\n                value: `<#${channel.id}>`\n            },\n            {\n                name: `> Type`,\n                value: `${types[channel.type]}`\n            }\n        ]\n    }, logsChannel).catch(() => { })\n};","size_bytes":987},"src/events/thread/threadDelete.js":{"content":"const discord = require('discord.js');\n\nmodule.exports = async (client, channel) => {\n    let types = {\n        10: \"News Thread\",\n        11: \"Public Thread\",\n        12: \"Private Thread\",\n    }\n\n    const logsChannel = await client.getLogs(channel.guild.id);\n    if (!logsChannel) return;\n\n    client.embed({\n        title: `📖・Thread deleted`,\n        desc: `A thread has been deleted`,\n        fields: [\n            {\n                name: `> Name`,\n                value: `- ${channel.name}`\n            },\n            {\n                name: `> ID`,\n                value: `- ${channel.id}`\n            },\n            {\n                name: `> Category`,\n                value: `${channel.parent}`\n            },\n            {\n                name: `> Type`,\n                value: `${types[channel.type]}`\n            }\n        ]\n    }, logsChannel).catch(() => { })\n};","size_bytes":881},"src/events/thread/threadUpdate.js":{"content":"const discord = require('discord.js');\n\nmodule.exports = async (client, oldChannel, newChannel) => {\n    let types = {\n        10: \"News Thread\",\n        11: \"Public Thread\",\n        12: \"Private Thread\",\n    }\n\n    const logsChannel = await client.getLogs(newChannel.guild.id);\n    if (!logsChannel) return;\n\n    client.embed({\n        title: `📖・Thread created`,\n        desc: `A thread has been created`,\n        fields: [\n            {\n                name: `> Old name`,\n                value: `- ${oldChannel.name}`\n            },\n            {\n                name: `> New name`,\n                value: `- ${newChannel.name}`\n            },\n            {\n                name: `> ID`,\n                value: `- ${newChannel.id}`\n            },\n            {\n                name: `> Category`,\n                value: `${newChannel.parent}`\n            },\n            {\n                name: `> Channel`,\n                value: `<#${newChannel.id}>`\n            },\n            {\n                name: `> Type`,\n                value: `${types[newChannel.type]}`\n            }\n        ]\n    }, logsChannel).catch(() => { })\n};","size_bytes":1135},"src/events/voice/voiceError.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = (client, error) => {\n    if (error.message == undefined) {\n        console.log(error);\n        error.message = \"Send to console!\";\n    }\n    const errorlog = new Discord.WebhookClient({\n        id: client.webhooks.voiceErrorLogs.id,\n        token: client.webhooks.voiceErrorLogs.token,\n    });\n\n    let embed = new Discord.EmbedBuilder()\n        .setTitle(`🚨・Voice error`)\n        .addFields(\n            { name: \"Error\", value: `\\`\\`\\`${error.message}\\`\\`\\``},\n            { name: `Stack error`, value: `\\`\\`\\`${error.stack.substr(0, 1018)}\\`\\`\\``},\n        )\n        .setColor(client.config.colors.normal)\n    errorlog.send({\n        username: `Bot errors`,\n        embeds: [embed],\n\n    }).catch(error => { console.log(error) })\n};","size_bytes":796},"src/events/voice/voiceStateUpdate.js":{"content":"const Discord = require('discord.js');\nconst voiceSchema = require(\"../../database/models/voice\");\nconst channelSchema = require(\"../../database/models/voiceChannels\");\n\nmodule.exports = (client, oldState, newState) => {\n    if (oldState.channelId == newState.channelId) {\n        if (oldState.serverDeaf == false && newState.selfDeaf == true) return;\n        if (oldState.serverDeaf == true && newState.selfDeaf == false) return;\n        if (oldState.serverMute == false && newState.serverMute == true) return;\n        if (oldState.serverMute == true && newState.serverMute == false) return;\n        if (oldState.selfDeaf == false && newState.selfDeaf == true) return;\n        if (oldState.selfDeaf == true && newState.selfDeaf == false) return;\n        if (oldState.selfMute == false && newState.selfMute == true) return;\n        if (oldState.selfMute == true && newState.selfMute == false) return;\n        if (oldState.selfVideo == false && newState.selfVideo == true) return;\n        if (oldState.selfVideo == true && newState.selfVideo == false) return;\n        if (oldState.streaming == false && newState.streaming == true) return;\n        if (oldState.streaming == true && newState.streaming == false) return;\n    }\n\n    var guildID = newState.guild.id || oldState.guild.id;\n\n    voiceSchema.findOne({ Guild: guildID }, async (err, data) => {\n        if (data) {\n            channelSchema.findOne({ Guild: guildID, Channel: oldState.channelId }, async (err, data2) => {\n                if (data2) {\n                    let channel = client.channels.cache.get(data2.Channel);\n                    let memberCount = channel.members.size;\n\n                    if (memberCount < 1 || memberCount == 0) {\n                        if (data.ChannelCount) {\n                            try {\n                                try {\n                                    data.ChannelCount -= 1;\n                                    data.save().catch(e => { });\n                                }\n                                catch { }\n                            }\n                            catch { }\n                        }\n\n                        try {\n                            var remove = await channelSchema.deleteOne({ Channel: oldState.channelID });\n                            return oldState.channel.delete().catch(e => { });\n                        }\n                        catch { }\n                    }\n                }\n            })\n\n            const user = await client.users.fetch(newState.id);\n            const member = newState.guild.members.cache.get(user.id);\n\n            try {\n                if (newState.channel.id === data.Channel) {\n                    channelSchema.findOne({ Guild: guildID, Channel: oldState.channelId }, async (err, data2) => {\n                        if (data2) {\n                            let channel = client.channels.cache.get(data2.Channel);\n                            let memberCount = channel.members.size;\n\n                            if (memberCount < 1 || memberCount == 0) {\n                                if (data.ChannelCount) {\n                                    try {\n                                        data.ChannelCount -= 1;\n                                        data.save().catch(e => { });\n                                    }\n                                    catch { }\n                                }\n\n                                try {\n                                    var remove = await channelSchema.deleteOne({ Channel: oldState.channelId });\n                                    return oldState.channel.delete().catch(e => { });\n                                }\n                                catch { }\n                            }\n                        }\n                    })\n\n                    if (data.ChannelCount) {\n                        data.ChannelCount += 1;\n                        data.save();\n                    }\n                    else {\n                        data.ChannelCount = 1;\n                        data.save();\n                    }\n\n                    let channelName = data.ChannelName;\n                    channelName = channelName.replace(`{emoji}`, \"🔊\")\n                    channelName = channelName.replace(`{channel name}`, `Voice ${data.ChannelCount}`)\n                    channelName = channelName.replace(`{channel count}`, `${data.ChannelCount}`)\n                    channelName = channelName.replace(`{member}`, `${user.username}`)\n                    channelName = channelName.replace(`{member tag}`, `${user.tag}`)\n\n                    const channel = await newState.guild.channels.create({\n                        name: \"⌛\",\n                        type:  Discord.ChannelType.GuildVoice,\n                        parent: data.Category,\n                    });\n\n                    if (member.voice.setChannel(channel)) {\n                        channel.edit({ name: channelName })\n                    }\n\n                    new channelSchema({\n                        Guild: guildID,\n                        Channel: channel.id,\n                    }).save();\n                }\n                else {\n                    channelSchema.findOne({ Guild: guildID, Channel: oldState.channelID }, async (err, data2) => {\n                        if (data2) {\n                            let channel = client.channels.cache.get(data2.Channel);\n                            let memberCount = channel.members.size;\n\n                            if (memberCount < 1 || memberCount == 0) {\n                                if (data.ChannelCount) {\n                                    try {\n                                        data.ChannelCount -= 1;\n                                        data.save().catch(e => { });\n                                    }\n                                    catch { }\n                                }\n\n                                try {\n                                    var remove = await channelSchema.deleteOne({ Channel: oldState.channelID });\n                                    return oldState.channel.delete().catch(e => { });\n                                }\n                                catch { }\n                            }\n                        }\n                    })\n                }\n            }\n            catch { }\n        }\n    })\n}","size_bytes":6349},"src/events/warn/warnAdd.js":{"content":"const discord = require('discord.js');\n\n/**\n * @param {discord.Client} client \n * @param {discord.GuildMember} user \n * @param {discord.User} mod \n * @param {string} reason \n * @returns\n */\nmodule.exports = async (client, user, mod, reason) => {\n    const logsChannel = await client.getLogs(user.guild.id);\n    if (!logsChannel) return;\n\n    client.embed({\n        title: `🔨・Member warned`,\n        desc: `A user has been warned`,\n        fields: [\n            {\n                name: `> User`,\n                value: `- ${user}`\n            },\n            {\n                name: `> Tag`,\n                value: `- ${user.user.username}#${user.user.discriminator}`\n            },\n            {\n                name: `> ID`,\n                value: `${user.id}`\n            },\n            {\n                name: `> Moderator`,\n                value: `${mod} (${mod.id})`\n            },\n            {\n                name: `> Reason`,\n                value: `${reason}`\n            }\n        ]\n    }, logsChannel).catch(() => {\n        console.log\n     })\n};","size_bytes":1062},"src/events/warn/warnRemove.js":{"content":"const discord = require('discord.js');\n\nmodule.exports = async (client, user, mod) => {\n    const logsChannel = await client.getLogs(user.guild.id);\n    if (!logsChannel) return;\n\n    client.embed({\n        title: `🔨・Member unwarned`,\n        desc: `A user has been unwarned`,\n        fields: [\n            {\n                name: `> User`,\n                value: `- ${user}`\n            },\n            {\n                name: `> Tag`,\n                value: `- ${user.user.username}#${user.user.discriminator}`\n            },\n            {\n                name: `> ID`,\n                value: `${user.id}`\n            },\n            {\n                name: `> Moderator`,\n                value: `${mod} (${mod.id})`\n            }\n        ]\n    }, logsChannel).catch(() => { })\n};","size_bytes":785},"src/handlers/audio/music.js":{"content":"const Discord = require('discord.js');\nconst Voice = require('@discordjs/voice');\n\nmodule.exports = (client) => {\n    client.on(Discord.Events.InteractionCreate, async (interaction) => {\n        if (interaction.isButton()) {\n            if (interaction.customId == \"Bot-musicpause\") {\n                interaction.deferUpdate();\n\n                const player = client.player.players.get(interaction.guild.id);\n                if (!player) return;\n\n                player.pause(true)\n\n                const embedData = interaction.message.embeds[0];\n\n                let row = new Discord.ActionRowBuilder()\n                    .addComponents(\n                        new Discord.ButtonBuilder()\n                            .setEmoji(client.emotes.music.previous)\n                            .setCustomId(\"Bot-musicprev\")\n                            .setStyle(Discord.ButtonStyle.Secondary),\n\n                        new Discord.ButtonBuilder()\n                            .setEmoji(client.emotes.music.play)\n                            .setCustomId(\"Bot-musicstart\")\n                            .setStyle(Discord.ButtonStyle.Secondary),\n\n                        new Discord.ButtonBuilder()\n                            .setEmoji(client.emotes.music.stop)\n                            .setCustomId(\"Bot-musicstop\")\n                            .setStyle(Discord.ButtonStyle.Secondary),\n\n                        new Discord.ButtonBuilder()\n                            .setEmoji(client.emotes.music.next)\n                            .setCustomId(\"Bot-musicnext\")\n                            .setStyle(Discord.ButtonStyle.Secondary),\n                    );\n\n                client.embed({\n                    title: embedData.title,\n                    url: embedData.url,\n                    desc: `Music is currently paused`,\n                    thumbnail: embedData.thumbnail.url,\n                    fields: embedData.fields,\n                    components: [row],\n                    color: client.config.colors.error,\n                    type: 'edit'\n                }, interaction.message)\n            }\n\n            if (interaction.customId == \"Bot-musicstart\") {\n                interaction.deferUpdate();\n\n                const player = client.player.players.get(interaction.guild.id);\n                if (!player) return;\n\n                player.pause(false)\n\n                const embedData = interaction.message.embeds[0];\n\n                let row = new Discord.ActionRowBuilder()\n                    .addComponents(\n                        new Discord.ButtonBuilder()\n                            .setEmoji(client.emotes.music.previous)\n                            .setCustomId(\"Bot-musicprev\")\n                            .setStyle(Discord.ButtonStyle.Secondary),\n\n                        new Discord.ButtonBuilder()\n                            .setEmoji(client.emotes.music.pause)\n                            .setCustomId(\"Bot-musicpause\")\n                            .setStyle(Discord.ButtonStyle.Secondary),\n\n                        new Discord.ButtonBuilder()\n                            .setEmoji(client.emotes.music.stop)\n                            .setCustomId(\"Bot-musicstop\")\n                            .setStyle(Discord.ButtonStyle.Secondary),\n\n                        new Discord.ButtonBuilder()\n                            .setEmoji(client.emotes.music.next)\n                            .setCustomId(\"Bot-musicnext\")\n                            .setStyle(Discord.ButtonStyle.Secondary),\n                    );\n\n                client.embed({\n                    title: embedData.title,\n                    url: embedData.url,\n                    desc: `Music is currently resumed`,\n                    thumbnail: embedData.thumbnail.url,\n                    fields: embedData.fields,\n                    components: [row],\n                    type: 'edit'\n                }, interaction.message)\n            }\n\n            if (interaction.customId == \"Bot-musicstop\") {\n                interaction.deferUpdate();\n\n                const player = client.player.players.get(interaction.guild.id);\n                if (!player) return;\n\n                player.destroy();\n\n                client.embed({\n                    desc: `Music is currently stopped`,\n                    color: client.config.colors.error,\n                    components: [],\n                    type: 'edit'\n                }, interaction.message)\n            }\n\n            if (interaction.customId == \"Bot-musicnext\") {\n                interaction.deferUpdate();\n\n                const player = client.player.players.get(interaction.guild.id);\n                if (!player) return;\n\n                player.stop();\n\n                const track = player.queue.current;\n\n                let row = new Discord.ActionRowBuilder()\n                    .addComponents(\n                        new Discord.ButtonBuilder()\n                            .setEmoji(\"⏮️\")\n                            .setCustomId(\"Bot-musicprev\")\n                            .setStyle(Discord.ButtonStyle.Primary),\n\n                        new Discord.ButtonBuilder()\n                            .setEmoji(\"⏸️\")\n                            .setCustomId(\"Bot-musicpause\")\n                            .setStyle(Discord.ButtonStyle.Primary),\n\n                        new Discord.ButtonBuilder()\n                            .setEmoji(\"⏹️\")\n                            .setCustomId(\"Bot-musicstop\")\n                            .setStyle(Discord.ButtonStyle.Primary),\n\n                        new Discord.ButtonBuilder()\n                            .setEmoji(\"⏭️\")\n                            .setCustomId(\"Bot-musicnext\")\n                            .setStyle(Discord.ButtonStyle.Primary),\n                    );\n\n                client.embed({\n                    title: `${client.emotes.normal.music}・${track.title}`,\n                    url: track.uri,\n                    desc: `Music started in <#${player.voiceChannel}>!`,\n                    thumbnail: track.thumbnail,\n                    fields: [\n                        {\n                            name: `👤┆Requested By`,\n                            value: `${track.requester}`,\n                            inline: true\n                        },\n                        {\n                            name: `${client.emotes.normal.clock}┆Ends at`,\n                            value: `<t:${((Date.now() / 1000) + (track.duration / 1000)).toFixed(0)}:f>`,\n                            inline: true\n                        },\n                        {\n                            name: `🎬┆Author`,\n                            value: `${track.author}`,\n                            inline: true\n                        }\n                    ],\n                    components: [row],\n                    type: 'edit'\n                }, interaction.message)\n            }\n\n            if (interaction.customId == \"Bot-musicprev\") {\n                interaction.deferUpdate();\n\n                const player = client.player.players.get(interaction.guild.id);\n                if (!player || !player.queue.previous) return;\n\n                const track = player.queue.previous;\n\n                let row = new Discord.ActionRowBuilder()\n                    .addComponents(\n                        new Discord.ButtonBuilder()\n                            .setEmoji(\"⏮️\")\n                            .setCustomId(\"Bot-musicprev\")\n                            .setStyle(Discord.ButtonStyle.Primary),\n\n                        new Discord.ButtonBuilder()\n                            .setEmoji(\"⏸️\")\n                            .setCustomId(\"Bot-musicpause\")\n                            .setStyle(Discord.ButtonStyle.Primary),\n\n                        new Discord.ButtonBuilder()\n                            .setEmoji(\"⏹️\")\n                            .setCustomId(\"Bot-musicstop\")\n                            .setStyle(Discord.ButtonStyle.Primary),\n\n                        new Discord.ButtonBuilder()\n                            .setEmoji(\"⏭️\")\n                            .setCustomId(\"Bot-musicnext\")\n                            .setStyle(Discord.ButtonStyle.Primary),\n                    );\n\n                client.embed({\n                    title: `${client.emotes.normal.music}・${track.title}`,\n                    url: track.uri,\n                    desc: `Music started in <#${player.voiceChannel}>!`,\n                    thumbnail: track.thumbnail,\n                    fields: [\n                        {\n                            name: `👤┆Requested By`,\n                            value: `${track.requester}`,\n                            inline: true\n                        },\n                        {\n                            name: `${client.emotes.normal.clock}┆Ends at`,\n                            value: `<t:${((Date.now() / 1000) + (track.duration / 1000)).toFixed(0)}:f>`,\n                            inline: true\n                        },\n                        {\n                            name: `🎬┆Author`,\n                            value: `${track.author}`,\n                            inline: true\n                        }\n                    ],\n                    components: [row],\n                    type: 'edit'\n                }, interaction.message)\n\n                player.play(player.queue.previous)\n            }\n        }\n    }).setMaxListeners(0);\n}\n\n ","size_bytes":9458},"src/handlers/audio/radio.js":{"content":"const Discord = require('discord.js');\nconst Voice = require('@discordjs/voice');\n\nconst Schema = require(\"../../database/models/music\");\n\nconst player = Voice.createAudioPlayer({\n    behaviors: {\n        noSubscriber: Voice.NoSubscriberBehavior.Play\n    },\n});\n\nmodule.exports = (client) => {\n\n    client.startStream = async function (url) {\n        const resource = Voice.createAudioResource(url, {\n            inputType: Voice.StreamType.Arbitrary,\n        });\n\n        player.play(resource);\n\n        return Voice.entersState(player, Voice.AudioPlayerStatus.Playing, 5e3).catch(() => { });\n    }\n\n    client.connectToChannel = async function (channel = Discord.VoiceChannel) {\n        const connection = Voice.joinVoiceChannel({\n            channelId: channel.id,\n            guildId: channel.guild.id,\n            adapterCreator: channel.guild.voiceAdapterCreator,\n        });\n\n        setTimeout(() => {\n            if (channel.type ==  Discord.ChannelType.GuildStageVoice) {\n                channel.guild.me.voice.setSuppressed(false).catch(() => { });\n            }\n        }, 500)\n\n        try {\n            await Voice.entersState(connection, Voice.VoiceConnectionStatus.Ready, 5e3).catch(() => { });\n            return connection;\n        } catch (error) {\n            connection.destroy();\n            client.emit(\"voiceError\", error);\n        }\n    }\n\n    client.radioStart = async function (channel) {\n        try {\n            const connection = await client.connectToChannel(channel);\n            connection.subscribe(player);\n        }\n        catch { }\n    }\n\n    client.radioStop = async function (channel) {\n        const connection = Voice.joinVoiceChannel({\n            channelId: channel.id,\n            guildId: channel.guild.id,\n            adapterCreator: channel.guild.voiceAdapterCreator,\n        });\n\n        connection.destroy();\n    }\n\n\n    player.on('stateChange', (oldState, newState) => {\n        if (newState.status === Voice.AudioPlayerStatus.Idle) {\n            client.startStream(process.env.RADIO || \"https://playerservices.streamtheworld.com/api/livestream-redirect/RADIO538\")\n        }\n    });\n\n    player.on('error', error => {\n        client.emit(\"voiceError\", error);\n        client.startStream(process.env.RADIO || \"https://playerservices.streamtheworld.com/api/livestream-redirect/RADIO538\");\n    });\n\n    client.on(Discord.Events.ClientReady, async () => {\n        client.startStream(process.env.RADIO || \"https://playerservices.streamtheworld.com/api/livestream-redirect/RADIO538\");\n        \n        Schema.find(async (err, data) => {\n            if (data) {\n                for (var i = 0; i < data.length; i++) {\n                    try {\n                        const channel = await client.channels.fetch(data[i].Channel)\n\n                        if (channel) {\n                            client.radioStart(channel);\n                        }\n                    }\n                    catch { }\n                }\n            }\n        })\n    });\n}\n\n ","size_bytes":3003},"src/handlers/components/button.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = (client) => {\n    client.buttonReactions = async function (id, reactions) {\n        var labels = [];\n        var sendComponents = [];\n\n        reactions.map((emoji) => {\n            let btn = new Discord.ButtonBuilder()\n                .setStyle(Discord.ButtonStyle.Primary)\n                .setEmoji(`${emoji}`)\n                .setCustomId(`reaction_button-${emoji}`);\n            return labels.push(btn);\n        })\n\n        if (labels.length < 5 || labels.length == 5) {\n            const row = new Discord.ActionRowBuilder()\n\n            row.addComponents(labels.slice(0, 5))\n\n            sendComponents = [row];\n        }\n\n        if (labels.length < 10 && labels.length > 5 || labels.length == 10) {\n            const row = new Discord.ActionRowBuilder()\n            const row2 = new Discord.ActionRowBuilder()\n\n            row.addComponents(labels.slice(0, 5))\n            row2.addComponents(labels.slice(5, 10))\n\n            sendComponents = [row, row2];\n        }\n\n        if (labels.length < 15 && labels.length > 10 || labels.length == 15) {\n            const row = new Discord.ActionRowBuilder()\n            const row2 = new Discord.ActionRowBuilder()\n            const row3 = new Discord.ActionRowBuilder()\n\n            row.addComponents(labels.slice(0, 5))\n            row2.addComponents(labels.slice(5, 10))\n            row3.addComponents(labels.slice(10, 15))\n\n            sendComponents = [row, row2, row3];\n        }\n\n        if (labels.length < 20 && labels.length > 15 || labels.length == 20) {\n            const row = new Discord.ActionRowBuilder()\n            const row2 = new Discord.ActionRowBuilder()\n            const row3 = new Discord.ActionRowBuilder()\n            const row4 = new Discord.ActionRowBuilder()\n\n            row.addComponents(labels.slice(0, 5))\n            row2.addComponents(labels.slice(5, 10))\n            row3.addComponents(labels.slice(10, 15))\n            row4.addComponents(labels.slice(15, 20))\n\n            sendComponents = [row, row2, row3, row4];\n        }\n\n        if (labels.length < 25 && labels.length > 20 || labels.length == 25) {\n            const row = new Discord.ActionRowBuilder()\n            const row2 = new Discord.ActionRowBuilder()\n            const row3 = new Discord.ActionRowBuilder()\n            const row4 = new Discord.ActionRowBuilder()\n            const row5 = new Discord.ActionRowBuilder()\n\n            row.addComponents(labels.slice(0, 5))\n            row2.addComponents(labels.slice(5, 10))\n            row3.addComponents(labels.slice(10, 15))\n            row4.addComponents(labels.slice(15, 20))\n            row5.addComponents(labels.slice(20, 25))\n\n            sendComponents = [row, row2, row3, row4, row5];\n        }\n\n        return await sendComponents;\n    }\n}","size_bytes":2807},"src/handlers/components/customEvents.js":{"content":"const Schema = require(\"../../database/models/logChannels\");\nconst Discord = require('discord.js');\n\nmodule.exports = async (client) => {\n    client.getLogs = async function (guildId) {\n        const data = await Schema.findOne({ Guild: guildId });\n        if (data && data.Channel) {\n            const channel = client.channels.cache.get(data.Channel);\n            return channel;\n        }\n        else {\n            return false;\n        }\n    }\n\n    client.on(Discord.Events.GuildMemberUpdate, (oldMember, newMember) => {\n        if (!oldMember.premiumSince && newMember.premiumSince) {\n            client.emit('guildMemberBoost', newMember);\n        }\n\n        if (oldMember.premiumSince && !newMember.premiumSince) {\n            client.emit('guildMemberUnboost', newMember);\n        }\n    })\n\n    client.on(Discord.Events.GuildUpdate, (oldGuild, newGuild) => {\n        if (oldGuild.premiumTier < newGuild.premiumTier) {\n            client.emit('guildBoostLevelUp', newGuild, oldGuild.premiumTier, newGuild.premiumTier);\n        }\n\n        if (oldGuild.premiumTier > newGuild.premiumTier) {\n            client.emit('guildBoostLevelDown', newGuild, oldGuild.premiumTier, newGuild.premiumTier);\n        }\n\n        if (!oldGuild.banner && newGuild.banner) {\n            client.emit('guildBannerAdd', newGuild, newGuild.bannerURL({ size: 1024 }));\n        }\n\n        if (!oldGuild.afkChannel && newGuild.afkChannel) {\n            client.emit('guildAfkChannelAdd', newGuild, newGuild.afkChannel);\n        }\n\n        if (!oldGuild.vanityURLCode && newGuild.vanityURLCode) {\n            client.emit('guildVanityURLAdd', newGuild, newGuild.vanityURLCode);\n        }\n\n        if (oldGuild.vanityURLCode && !newGuild.vanityURLCode) {\n            client.emit('guildVanityURLRemove', newGuild, oldGuild.vanityURLCode);\n        }\n\n        if (oldGuild.vanityURLCode !== newGuild.vanityURLCode) {\n            client.emit('guildVanityURLUpdate', newGuild, oldGuild.vanityURLCode, newGuild.vanityURLCode);\n        }\n    })\n\n    client.on(Discord.Events.GuildRoleUpdate, (oldRole, newRole) => {\n        if (oldRole.rawPosition !== newRole.rawPosition) {\n            client.emit('rolePositionUpdate', newRole, oldRole.rawPosition, newRole.rawPosition);\n        }\n\n        if (oldRole.permissions.bitfield !== newRole.permissions.bitfield) {\n            client.emit('rolePermissionsUpdate', newRole, oldRole.permissions.bitfield, newRole.permissions.bitfield);\n        }\n\n        if (oldRole.color !== newRole.color) {\n            client.emit('roleColorUpdate', newRole, oldRole.color, newRole.color);\n        }\n\n        if (oldRole.name !== newRole.name) {\n            client.emit('roleNameUpdate', newRole, oldRole.name, newRole.name);\n        }\n    })\n\n    client.on(Discord.Events.ChannelUpdate, (oldChannel, newChannel) => {\n        if (oldChannel.type === Discord.ChannelType.GuildText && oldChannel.topic !== newChannel.topic) {\n            client.emit('channelTopicUpdate', newChannel, oldChannel.topic, newChannel.topic);\n        }\n\n        if (oldChannel.name !== newChannel.name) {\n            client.emit('channelNameUpdate', newChannel, oldChannel.name, newChannel.name);\n        }\n    })\n}\n\n ","size_bytes":3192},"src/handlers/components/embed.js":{"content":"const Discord = require('discord.js');\n\n/** \n * Easy to send errors because im lazy to do the same things :p\n * @param {String} text - Message which is need to send\n * @param {TextChannel} channel - A Channel to send error\n */\n\nconst Schema = require(\"../../database/models/functions\");\n\nmodule.exports = (client) => {\n    client.templateEmbed = function () {\n        return new Discord.EmbedBuilder()\n            .setAuthor({\n                name: client.user.username,\n                iconURL: client.user.avatarURL({ size: 1024 })\n            })\n            .setColor(client.config.colors.normal)\n            .setFooter({\n                text: client.config.discord.footer,\n                iconURL: client.user.avatarURL({ size: 1024 })\n            })\n            .setTimestamp();\n    }\n\n    //----------------------------------------------------------------//\n    //                        ERROR MESSAGES                          //\n    //----------------------------------------------------------------//\n\n    // Normal error \n    client.errNormal = async function ({\n        embed: embed = client.templateEmbed(),\n        error: error,\n        type: type,\n        content: content,\n        components: components\n    }, interaction) {\n        embed.setTitle(`${client.emotes.normal.error}・Error!`)\n        embed.setDescription(`Something went wrong!`)\n        embed.addFields( \n            { name: \"💬┆Error comment\", value: `\\`\\`\\`${error}\\`\\`\\``},\n        )\n        embed.setColor(client.config.colors.error)\n\n        return client.sendEmbed({\n            embeds: [embed],\n            content: content,\n            components: components,\n            type: type\n        }, interaction)\n    }\n\n    // Missing args\n    client.errUsage = async function ({\n        embed: embed = client.templateEmbed(),\n        usage: usage,\n        type: type,\n        content: content,\n        components: components\n    }, interaction) {\n        embed.setTitle(`${client.emotes.normal.error}・Error!`)\n        embed.setDescription(`You did not provide the correct arguments`)\n        embed.addFields(\n            { name: \"💬┆Required arguments\", value: `\\`\\`\\`${usage}\\`\\`\\``},    \n        )\n        embed.setColor(client.config.colors.error)\n\n        return client.sendEmbed({\n            embeds: [embed],\n            content: content,\n            components: components,\n            type: type\n        }, interaction)\n    }\n\n    // Missing perms\n\n    client.errMissingPerms = async function ({\n        embed: embed = client.templateEmbed(),\n        perms: perms,\n        type: type,\n        content: content,\n        components: components\n    }, interaction) {\n        embed.setTitle(`${client.emotes.normal.error}・Error!`)\n        embed.setDescription(`You don't have the right permissions`)\n        embed.addFields(\n            { name: \"🔑┆Required Permission\", value: `\\`\\`\\`${perms}\\`\\`\\``},\n        )\n        embed.setColor(client.config.colors.error)\n\n        return client.sendEmbed({\n            embeds: [embed],\n            content: content,\n            components: components,\n            type: type\n        }, interaction)\n    }\n\n    // No bot perms\n\n    client.errNoPerms = async function ({\n        embed: embed = client.templateEmbed(),\n        perms: perms,\n        type: type,\n        content: content,\n        components: components\n    }, interaction) {\n        embed.setTitle(`${client.emotes.normal.error}・Error!`)\n        embed.setDescription(`I don't have the right permissions`)\n        embed.addFields(\n            { name: \"🔑┆Required Permission\", value: `\\`\\`\\`${perms}\\`\\`\\``},\n        )\n        embed.setColor(client.config.colors.error)\n\n        return client.sendEmbed({\n            embeds: [embed],\n            content: content,\n            components: components,\n            type: type\n        }, interaction)\n    }\n\n    // Wait error\n\n    client.errWait = async function ({\n        embed: embed = client.templateEmbed(),\n        time: time,\n        type: type,\n        content: content,\n        components: components\n    }, interaction) {\n        embed.setTitle(`${client.emotes.normal.error}・Error!`)\n        embed.setDescription(`You've already done this once`)\n        embed.addFields(\n            { name: \"⏰┆Try again on\", value: `<t:${time}:f>`},\n        )\n        embed.setColor(client.config.colors.error)\n\n        return client.sendEmbed({\n            embeds: [embed],\n            content: content,\n            components: components,\n            type: type\n        }, interaction)\n    }\n\n    //----------------------------------------------------------------//\n    //                        SUCCES MESSAGES                         //\n    //----------------------------------------------------------------//\n\n    // Normal succes\n    client.succNormal = async function ({\n        embed: embed = client.templateEmbed(),\n        text: text,\n        fields: fields,\n        type: type,\n        content: content,\n        components: components\n    }, interaction) {\n        embed.setTitle(`${client.emotes.normal.check}・Success!`)\n        embed.setDescription(`${text}`)\n        embed.setColor(client.config.colors.succes)\n\n        if (fields) embed.addFields(fields);\n\n        return client.sendEmbed({\n            embeds: [embed],\n            content: content,\n            components: components,\n            type: type\n        }, interaction)\n    }\n\n    //----------------------------------------------------------------//\n    //                        BASIC MESSAGES                          //\n    //----------------------------------------------------------------//\n\n    // Default\n    client.embed = async function ({\n        embed: embed = client.templateEmbed(),\n        title: title,\n        desc: desc,\n        color: color,\n        image: image,\n        author: author,\n        url: url,\n        footer: footer,\n        thumbnail: thumbnail,\n        fields: fields,\n        content: content,\n        components: components,\n        type: type\n    }, interaction) {\n        if (interaction.guild == undefined) interaction.guild = { id: \"0\" };\n        const functiondata = await Schema.findOne({ Guild: interaction.guild.id })\n\n        if (title) embed.setTitle(title);\n        if (desc && desc.length >= 2048) embed.setDescription(desc.substr(0, 2044) + \"...\");\n        else if (desc) embed.setDescription(desc);\n        if (image) embed.setImage(image);\n        if (thumbnail) embed.setThumbnail(thumbnail);\n        if (fields) embed.addFields(fields);\n        if (author) embed.setAuthor(author);\n        if (url) embed.setURL(url);\n        if (footer) embed.setFooter({ text: footer });\n        if (color) embed.setColor(color);\n        if (functiondata && functiondata.Color && !color) embed.setColor(functiondata.Color)\n        return client.sendEmbed({\n            embeds: [embed],\n            content: content,\n            components: components,\n            type: type\n        }, interaction)\n    }\n\n    client.simpleEmbed = async function ({\n        title: title,\n        desc: desc,\n        color: color,\n        image: image,\n        author: author,\n        thumbnail: thumbnail,\n        fields: fields,\n        url: url,\n        content: content,\n        components: components,\n        type: type\n    }, interaction) {\n        const functiondata = await Schema.findOne({ Guild: interaction.guild.id })\n\n        let embed = new Discord.EmbedBuilder()\n            .setColor(client.config.colors.normal)\n\n        if (title) embed.setTitle(title);\n        if (desc && desc.length >= 2048) embed.setDescription(desc.substr(0, 2044) + \"...\");\n        else if (desc) embed.setDescription(desc);\n        if (image) embed.setImage(image);\n        if (thumbnail) embed.setThumbnail(thumbnail);\n        if (fields) embed.addFields(fields);\n        if (author) embed.setAuthor(author[0], author[1]);\n        if (url) embed.setURL(url);\n        if (color) embed.setColor(color);\n        if (functiondata && functiondata.Color && !color) embed.setColor(functiondata.Color)\n\n        return client.sendEmbed({\n            embeds: [embed],\n            content: content,\n            components: components,\n            type: type\n        }, interaction)\n    }\n\n    client.sendEmbed = async function ({\n        embeds: embeds,\n        content: content,\n        components: components,\n        type: type\n    }, interaction) {\n        if (type && type.toLowerCase() == \"edit\") {\n            return await interaction.edit({\n                embeds: embeds,\n                content: content,\n                components: components,\n                fetchReply: true\n            }).catch(e => { });\n        }\n        else if (type && type.toLowerCase() == \"editreply\") {\n            return await interaction.editReply({\n                embeds: embeds,\n                content: content,\n                components: components,\n                fetchReply: true\n            }).catch(e => { });\n        }\n        else if (type && type.toLowerCase() == \"reply\") {\n            return await interaction.reply({\n                embeds: embeds,\n                content: content,\n                components: components,\n                fetchReply: true\n            }).catch(e => { });\n        }\n        else if (type && type.toLowerCase() == \"update\") {\n            return await interaction.update({\n                embeds: embeds,\n                content: content,\n                components: components,\n                fetchReply: true\n            }).catch(e => { });\n        }\n        else if (type && type.toLowerCase() == \"ephemeraledit\") {\n            return await interaction.editReply({\n                embeds: embeds,\n                content: content,\n                components: components,\n                fetchReply: true,\n                ephemeral: true\n            }).catch(e => { });\n        }\n        else if (type && type.toLowerCase() == \"ephemeral\") {\n            return await interaction.reply({\n                embeds: embeds,\n                content: content,\n                components: components,\n                fetchReply: true,\n                ephemeral: true\n            }).catch(e => { });\n        }\n        else {\n            return await interaction.send({\n                embeds: embeds,\n                content: content,\n                components: components,\n                fetchReply: true\n            }).catch(e => { });\n        }\n    }\n}\n\n ","size_bytes":10434},"src/handlers/components/select.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = (client) => {\n    client.generateSelect = async function (id, labels) {\n        let sendComponents = [];\n\n        let row = new Discord.ActionRowBuilder();\n        let row2 = new Discord.ActionRowBuilder();\n        let row3 = new Discord.ActionRowBuilder();\n        let row4 = new Discord.ActionRowBuilder();\n        let row5 = new Discord.ActionRowBuilder();\n\n        if (labels.length < 25 || labels.length == 25) {\n            const menu = new Discord.StringSelectMenuBuilder()\n                .setCustomId(`${id}-1`)\n                .setPlaceholder('❌┇Nothing selected')\n                .addOptions(labels.slice(0, 25));\n\n            row.addComponents(menu)\n\n            sendComponents = row;\n        }\n\n        if (labels.length < 50 && labels.length > 25 || labels.length == 50) {\n            const menu = new Discord.StringSelectMenuBuilder()\n                .setCustomId(`${id}-1`)\n                .setPlaceholder('❌┇Nothing selected')\n                .addOptions(labels.slice(0, 25));\n\n            const menu2 = new Discord.StringSelectMenuBuilder()\n                .setCustomId(`${id}-2`)\n                .setPlaceholder('❌┇Nothing selected')\n                .addOptions(labels.slice(25, 50));\n\n            row.addComponents(menu)\n            row2.addComponents(menu2)\n\n            sendComponents = row, row2;\n        }\n\n        if (labels.length < 75 && labels.length > 50 || labels.length == 75) {\n            const menu = new Discord.StringSelectMenuBuilder()\n                .setCustomId(`${id}-1`)\n                .setPlaceholder('❌┇Nothing selected')\n                .addOptions(labels.slice(0, 25));\n\n            const menu2 = new Discord.StringSelectMenuBuilder()\n                .setCustomId(`${id}-2`)\n                .setPlaceholder('❌┇Nothing selected')\n                .addOptions(labels.slice(25, 50));\n\n            const menu3 = new Discord.StringSelectMenuBuilder()\n                .setCustomId(`${id}-3`)\n                .setPlaceholder('❌┇Nothing selected')\n                .addOptions(labels.slice(50, 75));\n\n            row.addComponents(menu)\n            row2.addComponents(menu2)\n            row3.addComponents(menu3)\n\n            sendComponents = row, row2, row3;\n        }\n\n        if (labels.length < 100 && labels.length > 75 || labels.length == 100) {\n            const menu = new Discord.StringSelectMenuBuilder()\n                .setCustomId(`${id}-1`)\n                .setPlaceholder('❌┇Nothing selected')\n                .addOptions(labels.slice(0, 25));\n\n            const menu2 = new Discord.StringSelectMenuBuilder()\n                .setCustomId(`${id}-2`)\n                .setPlaceholder('❌┇Nothing selected')\n                .addOptions(labels.slice(25, 50));\n\n            const menu3 = new Discord.StringSelectMenuBuilder()\n                .setCustomId(`${id}-3`)\n                .setPlaceholder('❌┇Nothing selected')\n                .addOptions(labels.slice(50, 75));\n\n            const menu4 = new Discord.StringSelectMenuBuilder()\n                .setCustomId(`${id}-4`)\n                .setPlaceholder('❌┇Nothing selected')\n                .addOptions(labels.slice(75, 100));\n\n            row.addComponents(menu)\n            row2.addComponents(menu2)\n            row3.addComponents(menu3)\n            row4.addComponents(menu4)\n\n            sendComponents = row, row2, row3, row4;\n        }\n\n        if (labels.length < 125 && labels.length > 100 || labels.length == 125) {\n            const menu = new Discord.StringSelectMenuBuilder()\n                .setCustomId(`${id}-1`)\n                .setPlaceholder('❌┇Nothing selected')\n                .addOptions(labels.slice(0, 25));\n\n            const menu2 = new Discord.StringSelectMenuBuilder()\n                .setCustomId(`${id}-2`)\n                .setPlaceholder('❌┇Nothing selected')\n                .addOptions(labels.slice(25, 50));\n\n            const menu3 = new Discord.StringSelectMenuBuilder()\n                .setCustomId(`${id}-3`)\n                .setPlaceholder('❌┇Nothing selected')\n                .addOptions(labels.slice(50, 75));\n\n            const menu4 = new Discord.StringSelectMenuBuilder()\n                .setCustomId(`${id}-4`)\n                .setPlaceholder('❌┇Nothing selected')\n                .addOptions(labels.slice(75, 100));\n\n            const menu5 = new Discord.StringSelectMenuBuilder()\n                .setCustomId(`${id}-5`)\n                .setPlaceholder('❌┇Nothing selected')\n                .addOptions(labels.slice(100, 125));\n\n            row.addComponents(menu)\n            row2.addComponents(menu2)\n            row3.addComponents(menu3)\n            row4.addComponents(menu4)\n            row5.addComponents(menu5)\n\n            sendComponents = row, row2, row3, row4, row5;\n        }\n\n        return await sendComponents;\n    }\n}","size_bytes":4894},"src/handlers/functions/birthdays.js":{"content":"const Schema = require(\"../../database/models/birthday\");\nconst Devs = require(\"../../database/models/developers\");\nconst birthdayChannel = require(\"../../database/models/birthdaychannels\");\n\nmodule.exports = (client) => {\n    const checkBirthdays = async () => {\n        const now = new Date();\n        const getLastDate = await Devs.findOne({ Action: \"Birthday\" }).exec();\n\n        let month = now.getMonth() + 1;\n        let day = now.getDate();\n\n        let dateNow = `${day} - ${month}`;\n\n        if (getLastDate) {\n            const lastDate = getLastDate.Date;\n\n            if (lastDate == dateNow) return;\n\n            getLastDate.Date = dateNow;\n            getLastDate.save();\n        }\n        else {\n            new Devs({\n                Action: \"Birthday\",\n                Date: dateNow,\n            }).save();\n        }\n\n        const months = {\n            1: \"January\",\n            2: \"February\",\n            3: \"March\",\n            4: \"April\",\n            5: \"May\",\n            6: \"June\",\n            7: \"July\",\n            8: \"August\",\n            9: \"September\",\n            10: \"October\",\n            11: \"November\",\n            12: \"December\"\n        };\n\n        const convertedDay = suffixes(day);\n        const convertedMonth = months[month];\n        const birthdayString = `${convertedDay} of ${convertedMonth}`;\n\n        const results = await Schema.find({ Birthday: birthdayString })\n\n        if (results) {\n            for (const result of results) {\n                const { Guild, User } = result;\n\n                const finalGuild = client.guilds.cache.get(Guild)\n                if (finalGuild) {\n                    birthdayChannel.findOne({ Guild: finalGuild.id }, async (err, data) => {\n                        if (data) {\n                            const channel = finalGuild.channels.cache.get(data.Channel);\n                            \n                            client.embed({ \n                                title: `${client.emotes.normal.birthday}・Birthday`,\n                                desc: `Happy birthday to <@!${User}>!`\n                            }, channel)\n                        }\n                    })\n                }\n            }\n        }\n\n        setTimeout(checkBirthdays, 1000 * 10)\n    }\n\n    checkBirthdays()\n}\n\nfunction suffixes(number) {\n    const converted = number.toString();\n\n    const lastChar = converted.charAt(converted.length - 1);\n\n    return lastChar == \"1\" ?\n        `${converted}st` : lastChar == \"2\" ?\n            `${converted}nd` : lastChar == '3'\n                ? `${converted}rd` : `${converted}th`\n}\n\n ","size_bytes":2596},"src/handlers/functions/databaseFunctions.js":{"content":"module.exports = (client) => {\n    client.createChannelSetup = async function (Schema, channel, interaction) {\n        Schema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n            if (data) {\n                data.Channel = channel.id;\n                data.save();\n            }\n            else {\n                new Schema({\n                    Guild: interaction.guild.id,\n                    Channel: channel.id\n                }).save();\n            }\n        });\n\n        client.succNormal({\n            text: `Channel has been set up successfully!`,\n            fields: [\n                {\n                    name: `📘┆Channel`,\n                    value: `${channel} (${channel.id})`\n                }\n            ],\n            type: 'editreply'\n        }, interaction);\n    }\n\n    client.createRoleSetup = async function (Schema, role, interaction) {\n        Schema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n            if (data) {\n                data.Role = role.id;\n                data.save();\n            }\n            else {\n                new Schema({\n                    Guild: interaction.guild.id,\n                    Role: role.id\n                }).save();\n            }\n        });\n\n        client.succNormal({\n            text: `Role has been set up successfully!`,\n            fields: [\n                {\n                    name: `📘┆Role`,\n                    value: `${role} (${role.id})`\n                }\n            ],\n            type: 'editreply'\n        }, interaction);\n    }\n}","size_bytes":1565},"src/handlers/functions/functions.js":{"content":"const Discord = require('discord.js');\nconst fetch = require(\"node-fetch\");\n\nconst Functions = require(\"../../database/models/functions\");\nconst VoiceSchema = require(\"../../database/models/voiceChannels\");\n\nmodule.exports = async (client) => {\n    //----------------------------------------------------------------//\n    //                         Permissions                            //\n    //----------------------------------------------------------------//\n    // All bitfields to name\n    client.bitfieldToName = function (bitfield) {\n        const permissions = new Discord.PermissionsBitField(bitfield);\n        return permissions.toArray();\n    }\n    client.checkPerms = async function ({\n        flags: flags,\n        perms: perms\n    }, interaction) {\n        for (let i = 0; i < flags.length; i++) {\n            if (!interaction.member.permissions.has(flags[i])) {\n                client.errMissingPerms({\n                    perms: client.bitfieldToName(flags[i]) || flags[i],\n                    type: 'editreply'\n                }, interaction);\n\n                return false\n            }\n            if (!interaction.guild.members.me.permissions.has(flags[i])) {\n                client.errNoPerms({\n                    perms: client.bitfieldToName(flags[i]) || flags[i],\n                    type: 'editreply'\n                }, interaction);\n\n                return false\n            }\n        }\n    }\n    client.checkBotPerms = async function ({\n        flags: flags,\n        perms: perms\n    }, interaction) {\n        for (let i = 0; i < flags.length; i++) {\n             if (!interaction.guild.members.me.permissions.has(flags[i])) {\n                client.errNoPerms({\n                    perms: client.bitfieldToName(flags[i]) || flags[i],\n                    type: 'editreply'\n                }, interaction);\n\n                return false\n            }\n        }\n    }\n    client.checkUserPerms = async function ({\n        flags: flags,\n        perms: perms\n    }, interaction) {\n        for (let i = 0; i < flags.length; i++) {\n            if (!interaction.member.permissions.has(flags[i])) {\n                client.errMissingPerms({\n                    perms: client.bitfieldToName(flags[i]) || flags[i],\n                    type: 'editreply'\n                }, interaction);\n\n                return false\n            }\n        }\n    }\n\n    client.getChannel = function (channel, message) {\n        return message.mentions.channels.first() || message.guild.channels.cache.get(channel) || message.guild.channels.cache.find(c => c.name == channel);\n    }\n\n    client.removeMentions = function (str) {\n        return str.replaceAll('@', '@\\u200b');\n    }\n\n    client.loadSubcommands = async function (client, interaction, args) {\n        try {\n            const data = await Functions.findOne({ Guild: interaction.guild.id });\n\n            if (data.Beta == true) {\n                return require(`${process.cwd()}/src/commands/${interaction.commandName}/${interaction.options.getSubcommand()}-beta`)(client, interaction, args).catch(err => {\n                    client.emit(\"errorCreate\", err, interaction.commandName, interaction)\n                })\n            }\n            else {\n                return require(`${process.cwd()}/src/commands/${interaction.commandName}/${interaction.options.getSubcommand()}`)(client, interaction, args).catch(err => {\n                    client.emit(\"errorCreate\", err, interaction.commandName, interaction)\n                })\n            }\n        }\n        catch {\n            return require(`${process.cwd()}/src/commands/${interaction.commandName}/${interaction.options.getSubcommand()}`)(client, interaction, args).catch(err => {\n                client.emit(\"errorCreate\", err, interaction.commandName, interaction)\n            })\n        }\n    }\n\n    client.checkVoice = async function (guild, channel) {\n        const data = await VoiceSchema.findOne({ Guild: guild.id, Channel: channel.id });\n        if (data) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n\n    client.generateEmbed = async function (start, end, lb, title, interaction) {\n        const current = lb.slice(start, end + 10);\n        const result = current.join(\"\\n\");\n\n        let embed = client.templateEmbed()\n            .setTitle(`${title}`)\n            .setDescription(`${result.toString()}`)\n\n        const functiondata = await Functions.findOne({ Guild: interaction.guild.id });\n\n        if (functiondata && functiondata.Color) {\n            embed.setColor(functiondata.Color)\n        }\n\n        return embed;\n    }\n\n    client.createLeaderboard = async function (title, lb, interaction) {\n        interaction.editReply({ embeds: [await client.generateEmbed(0, 0, lb, title, interaction)], fetchReply: true }).then(async msg => {\n            if (lb.length <= 10) return;\n\n            let button1 = new Discord.ButtonBuilder()\n                .setCustomId('back_button')\n                .setEmoji('⬅️')\n                .setStyle(Discord.ButtonStyle.Primary)\n                .setDisabled(true);\n\n            let button2 = new Discord.ButtonBuilder()\n                .setCustomId('forward_button')\n                .setEmoji('➡️')\n                .setStyle(Discord.ButtonStyle.Primary);\n\n            let row = new Discord.ActionRowBuilder()\n                .addComponents(button1, button2);\n\n            msg.edit({ embeds: [await client.generateEmbed(0, 0, lb, title, interaction)], components: [row] })\n\n            let currentIndex = 0;\n            const collector = interaction.channel.createMessageComponentCollector({ componentType: Discord.ComponentType.Button, time: 60000 });\n\n            collector.on('collect', async (btn) => {\n                if (btn.user.id == interaction.user.id && btn.message.id == msg.id) {\n                    btn.customId === \"back_button\" ? currentIndex -= 10 : currentIndex += 10;\n\n                    let btn1 = new Discord.ButtonBuilder()\n                        .setCustomId('back_button')\n                        .setEmoji('⬅️')\n                        .setStyle(Discord.ButtonStyle.Primary)\n                        .setDisabled(true);\n\n                    let btn2 = new Discord.ButtonBuilder()\n                        .setCustomId('forward_button')\n                        .setEmoji('➡️')\n                        .setStyle(Discord.ButtonStyle.Primary)\n                        .setDisabled(true);\n\n                    if (currentIndex !== 0) btn1.setDisabled(false);\n                    if (currentIndex + 10 < lb.length) btn2.setDisabled(false);\n\n                    let row2 = new Discord.ActionRowBuilder()\n                        .addComponents(btn1, btn2);\n\n                    msg.edit({ embeds: [await client.generateEmbed(currentIndex, currentIndex, lb, title, interaction)], components: [row2] });\n                    btn.deferUpdate();\n                }\n            })\n\n            collector.on('end', async (btn) => {\n                let btn1Disable = new Discord.ButtonBuilder()\n                    .setCustomId('back_button')\n                    .setEmoji('⬅️')\n                    .setStyle(Discord.ButtonStyle.Primary)\n                    .setDisabled(true);\n\n                let btn2Disable = new Discord.ButtonBuilder()\n                    .setCustomId('forward_button')\n                    .setEmoji('➡️')\n                    .setStyle(Discord.ButtonStyle.Primary)\n                    .setDisabled(true);\n\n                let rowDisable = new Discord.ActionRowBuilder()\n                    .addComponents(btn1Disable, btn2Disable);\n\n                msg.edit({ embeds: [await client.generateEmbed(currentIndex, currentIndex, lb, title, interaction)], components: [rowDisable] });\n            })\n        })\n    }\n\n    client.generateActivity = function (id, name, channel, interaction) {\n        fetch(`https://discord.com/api/v10/channels/${channel.id}/invites`, {\n            method: \"POST\",\n            body: JSON.stringify({\n                max_age: 86400,\n                max_uses: 0,\n                target_application_id: id,\n                target_type: 2,\n                temporary: false,\n                validate: null\n            }),\n            headers: {\n                \"Authorization\": `Bot ${client.token}`,\n                \"Content-Type\": \"application/json\"\n            }\n        }).then(res => res.json())\n            .then(invite => {\n                if (invite.error || !invite.code) return client.errNormal({ \n                    error: `Could not start **${name}**!`, \n                    type: 'editreply'\n                }, interaction);\n\n                const row = new Discord.ActionRowBuilder()\n                    .addComponents(\n                        new Discord.ButtonBuilder()\n                            .setLabel(\"Start activity\")\n                            .setURL(`https://discord.gg/${invite.code}`)\n                            .setStyle(Discord.ButtonStyle.Link),\n                    );\n\n                client.embed({\n                    title: `${client.emotes.normal.tv}・Activities`,\n                    desc: `Click on the **button** to start **${name}** in **${channel.name}**`,\n                    components: [row],\n                    type: 'editreply'\n                }, interaction)\n            })\n            .catch(e => {\n                console.log(e)\n                client.errNormal({\n                    error: `Could not start **${name}**!`,\n                    type: 'editreply'\n                }, interaction);\n            })\n    }\n}\n\n ","size_bytes":9567},"src/handlers/functions/giveaway.js":{"content":"const { GiveawaysManager } = require(\"discord-giveaways\");\nconst Discord = require(\"discord.js\");\nconst fs = require('fs');\n\nconst giveawayModel = require(\"../../database/models/giveaways\");\n\nmodule.exports = (client) => {\n    const GiveawayManagerWithOwnDatabase = class extends GiveawaysManager {\n        async getAllGiveaways() {\n            return await giveawayModel.find().lean().exec();\n        }\n\n        async saveGiveaway(messageId, giveawayData) {\n            await giveawayModel.create(giveawayData);\n            return true;\n        }\n\n        async editGiveaway(messageId, giveawayData) {\n            await giveawayModel.updateOne({ messageId }, giveawayData, { omitUndefined: true }).exec();\n            return true;\n        }\n\n        async deleteGiveaway(messageId) {\n            await giveawayModel.deleteOne({ messageId }).exec();\n            return true;\n        }\n\n        async refreshStorage() {\n            return client.shard.broadcastEval(() => this.giveawaysManager.getAllGiveaways());\n        }\n    };\n\n    const manager = new GiveawayManagerWithOwnDatabase(client, {\n        default: {\n            botsCanWin: false,\n            embedColor: client.config.colors.normal,\n            embedColorEnd: client.config.colors.error,\n            reaction: '🥳'\n        }\n    }, true);\n\n    client.giveawaysManager = manager;\n\n    const events = fs.readdirSync(`./src/events/giveaway`).filter(files => files.endsWith('.js'));\n\n    for (const file of events) {\n        const event = require(`../../events/giveaway/${file}`);\n        manager.on(file.split(\".\")[0], event.bind(null, client)).setMaxListeners(0);\n    };\n}","size_bytes":1638},"src/handlers/functions/inviteTracker.js":{"content":"const Discord = require(\"discord.js\");\n\nmodule.exports = async (client) => {\n    const guildInvites = new Map();\n\n    client.on(Discord.Events.InviteCreate, async invite => {\n        try {\n            const invites = await invite.guild.invites.fetch().catch(() => { });\n\n            const codeUses = new Map();\n            await invites.each(inv => codeUses.set(inv.code, inv.uses));\n\n            await guildInvites.set(invite.guild.id, codeUses);\n        }\n        catch { }\n    })\n\n    client.once(Discord.Events.ClientReady, async () => {\n        setTimeout(() => {\n            try {\n                client.guilds.cache.forEach(async (guild) => {\n                    if (!guild || !guild.invites) return;\n\n                    guild.invites.fetch().then(rawGuildInvites => {\n                        const codeUses = new Map();\n                        Array.from(rawGuildInvites).forEach(i => {\n                            codeUses.set(i[1].code, i[1].uses);\n                        })\n                        guildInvites.set(guild.id, codeUses);\n                    }).catch(() => { console.log });\n                });\n            } catch (e) { }\n        }, 1000);\n    });\n\n    client.on(Discord.Events.GuildCreate, async guild => {\n        try {\n            if (!guild || !guild.invites) return;\n\n            guild.invites.fetch().then(rawGuildInvites => {\n                const codeUses = new Map();\n                Array.from(rawGuildInvites).forEach(i => {\n                    codeUses.set(i[1].code, i[1].uses);\n                })\n                guildInvites.set(guild.id, codeUses);\n            }).catch(() => { });\n        } catch (e) { }\n    });\n\n    client.on(Discord.Events.GuildDelete, async guild => {\n        try {\n            guildInvites.delete(guild.id);\n        } catch (e) { }\n    });\n\n    client.on(Discord.Events.GuildMemberAdd, async member => {\n        try {\n            const cachedInvites = await guildInvites.get(member.guild.id)\n            const newInvites = await member.guild.invites.fetch().catch(() => { console.log });\n\n            const codeUses = new Map();\n            Array.from(newInvites).forEach(async i => {\n                codeUses.set(i[1].code, i[1].uses);\n            })\n            guildInvites.set(member.guild.id, codeUses);\n\n            const usedInvite = await newInvites.find(inv => cachedInvites.get(inv.code) < inv.uses);\n            if (!usedInvite) return client.emit(\"inviteJoin\", member, null, null);\n\n            client.emit(\"inviteJoin\", member, usedInvite, usedInvite.inviter);\n        } catch (err) {\n            return client.emit(\"inviteJoin\", member, null, null);\n        }\n    });\n}","size_bytes":2650},"src/handlers/functions/serverstats.js":{"content":"const Schema = require(\"../../database/models/stats\");\nconst Discord = require('discord.js');\n\nmodule.exports = async (client) => {\n    client.getTemplate = async (guild) => {\n        try {\n            const data = await Schema.findOne({ Guild: guild.id });\n\n            if (data && data.ChannelTemplate) {\n                return data.ChannelTemplate;\n            }\n            else {\n                return `{emoji} {name}`\n            }\n        }\n        catch {\n            return `{emoji} {name}`\n        }\n    }\n\n    client.on(Discord.Events.GuildMemberAdd, async (member) => {\n        client.emit('updateMembers', member.guild);\n        client.emit('updateBots', member.guild);\n    })\n    client.on(Discord.Events.GuildMemberRemove, async (member) => {\n        client.emit('updateMembers', member.guild);\n        client.emit('updateBots', member.guild);\n    })\n\n    client.on(Discord.Events.ChannelCreate, async channel => {\n        client.emit('updateChannels', channel, channel.guild);\n        client.emit('updateNewsChannels', channel, channel.guild);\n        client.emit('updateStageChannels', channel, channel.guild);\n        client.emit('updateTextChannels', channel, channel.guild);\n        client.emit('updateVoiceChannels', channel, channel.guild);\n    })\n    client.on(Discord.Events.ChannelDelete, async channel => {\n        client.emit('updateChannels', channel, channel.guild);\n        client.emit('updateNewsChannels', channel, channel.guild);\n        client.emit('updateStageChannels', channel, channel.guild);\n        client.emit('updateTextChannels', channel, channel.guild);\n        client.emit('updateVoiceChannels', channel, channel.guild);\n    })\n\n    client.on(Discord.Events.RoleCreate, async role => client.emit('updateRoles', role.guild))\n    client.on(Discord.Events.RoleDelete, async role => client.emit('updateRoles', role.guild))\n\n    client.on(Discord.Events.GuildMemberBoost, (booster) => client.emit('updateBoosts', booster.guild))\n    client.on(Discord.Events.GuildMemberUnboost, (booster) => client.emit('updateBoosts', booster.guild))\n\n    client.on(Discord.Events.GuildBoostLevelUp, (tier) => client.emit('updateTier', tier.guild))\n    client.on(Discord.Events.GuildBoostLevelDown, (tier) => client.emit('updateTier', tier.guild))\n\n    client.on(Discord.Events.EmojiCreate, (emoji) => {\n        client.emit('updateEmojis', emoji, emoji.guild);\n        client.emit('updateAEmojis', emoji, emoji.guild);\n        client.emit('updateSEmojis', emoji, emoji.guild);\n    })\n    client.on(Discord.Events.EmojiDelete, (emoji) => {\n        client.emit('updateEmojis', emoji, emoji.guild);\n        client.emit('updateAEmojis', emoji, emoji.guild);\n        client.emit('updateSEmojis', emoji, emoji.guild);\n    })\n\n    client.on(Discord.Events.ClientReady, async client => client.emit('updateClock'))\n}\n\n ","size_bytes":2835},"src/handlers/functions/soundboard.js":{"content":"const Discord = require('discord.js');\nconst { AudioPlayerStatus, createAudioResource, createAudioPlayer, NoSubscriberBehavior, joinVoiceChannel, StreamType, VoiceConnectionStatus } = require('@discordjs/voice');\n\nvar servers = {}\n\nmodule.exports = (client) => {\n\n    client.soundboard = async function (guild, interaction, url) {\n        if (!servers[guild]) servers[guild] = {\n            queue: []\n        }\n\n        var server = servers[guild];\n\n        server.queue.push(url);\n\n        const player = createAudioPlayer();\n\n        const channel = interaction.member.voice.channel;\n        const connection = await client.connectToChannel(channel);\n        connection.subscribe(player);\n\n        setTimeout(() => {\n            if (channel.type == Discord.ChannelType.GuildStageVoice) {\n                interaction.guild.members.me.voice.setSuppressed(false);\n            }\n        }, 500)\n\n        client.play(connection, interaction, guild, player);\n    }\n\n    client.play = async function (connection, interaction, guild, player) {\n        var server = servers[guild];\n\n        const resource = createAudioResource(server.queue[0], { inputType: StreamType.Arbitrary });\n        player.play(resource);\n\n        server.queue.shift();\n\n        player.on(AudioPlayerStatus.Idle, () => {\n            if (server.queue[0]) {\n                client.play(connection, interaction, guild, player);\n            }\n            else {\n                connection.destroy();\n            }\n        });\n    }\n}","size_bytes":1497},"src/handlers/functions/ticket.js":{"content":"const discord = require('discord.js');\nconst jsdom = require('jsdom');\nconst fs = require('fs');\nconst purify = require('dompurify');\nconst he = require('he');\nconst static = require('../../assets/utils/static');\n\nconst ticketSchema = require(\"../../database/models/tickets\");\nconst ticketChannels = require(\"../../database/models/ticketChannels\");\n\nmodule.exports = async (client) => {\n\n    client.getTicketData = async function (interaction) {\n        const ticketData = await ticketSchema.findOne({ Guild: interaction.guild.id });\n        if (!ticketData) return false;\n\n        return ticketData;\n    }\n\n    client.getChannelTicket = async function (interaction) {\n        const ticketChannelData = await ticketChannels.findOne({ Guild: interaction.guild.id, channelID: interaction.channel.id })\n        return ticketChannelData;\n    }\n\n    client.isTicket = async function (interaction) {\n        const ticketChannelData = await ticketChannels.findOne({ Guild: interaction.guild.id, channelID: interaction.channel.id });\n\n        if (ticketChannelData) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n\n    // Transcript\n\n    client.transcript = async function (interaction, channel) {\n        const template = fs.readFileSync('./src/config/template.html', 'utf8');\n        const messages = await interaction.channel.messages.fetch({ limit: 100 });\n\n        const dom = new jsdom.JSDOM(template.replace('{{TITLE}}', interaction.channel.name));\n        const document = dom.window.document;\n\n        const DOMPurify = purify(dom.window);\n        DOMPurify.setConfig({\n            ALLOWED_TAGS: []\n        });\n        const xss = DOMPurify.sanitize;\n\n        document.getElementsByClassName('preamble__guild-icon')[0].src = interaction.channel.guild.iconURL();\n        document.getElementById('guildname').textContent = interaction.guild.name;\n        document.getElementById('ticketname').textContent = interaction.channel.name;\n\n        const transcript = document.getElementById('chatlog');\n\n        for (const message of (Array.from(messages.values())).sort((a, b) => a.createdTimestamp - b.createdTimestamp)) {\n            // create message group\n            const messageGroup = document.createElement('div');\n            messageGroup.classList.add('chatlog__message-group');\n\n            // message reference\n            if (message.reference?.messageId) {\n                // create symbol\n                const referenceSymbol = document.createElement('div');\n                referenceSymbol.classList.add('chatlog__reference-symbol');\n\n                // create reference\n                const reference = document.createElement('div');\n                reference.classList.add('chatlog__reference');\n\n                const referencedMessage = messages instanceof discord.Collection ? messages.get(message.reference.messageId) : messages.find(m => m.id === message.reference.messageId);\n                const author = referencedMessage?.author ?? static.DummyUser;\n\n                reference.innerHTML =\n                    `<img class=\"chatlog__reference-avatar\" src=\"${author.avatarURL() ?? static.defaultPFP}\" alt=\"Avatar\" loading=\"lazy\">\n                <span class=\"chatlog__reference-name\" title=\"${author.username.replace(/\"/g, '')}\" style=\"color: ${author.hexAccentColor ?? '#FFFFFF'}\">${author.bot ? `<span class=\"chatlog__bot-tag\">BOT</span> ${xss(author.username)}` : xss(author.username)}</span>\n                <div class=\"chatlog__reference-content\">\n                    <span class=\"chatlog__reference-link\" onclick=\"scrollToMessage(event, '${message.reference.messageId}')\">\n                            ${referencedMessage ? (referencedMessage?.content ? `${formatContent(referencedMessage?.content, false, true)}...` : '<em>Click to see attachment</em>') : '<em>Original message was deleted.</em>'}\n                    </span>\n                </div>`;\n\n                messageGroup.appendChild(referenceSymbol);\n                messageGroup.appendChild(reference);\n            }\n\n            // message author pfp\n            const author = message.author ?? static.DummyUser;\n\n            const authorElement = document.createElement('div');\n            authorElement.classList.add('chatlog__author-avatar-container');\n\n            const authorAvatar = document.createElement('img');\n            authorAvatar.classList.add('chatlog__author-avatar');\n            authorAvatar.src = author.avatarURL() ?? static.defaultPFP;\n            authorAvatar.alt = 'Avatar';\n            authorAvatar.loading = 'lazy';\n\n            authorElement.appendChild(authorAvatar);\n            messageGroup.appendChild(authorElement);\n\n            // message content\n            const content = document.createElement('div');\n            content.classList.add('chatlog__messages');\n\n            // message author name\n            const authorName = document.createElement('span');\n            authorName.classList.add('chatlog__author-name');\n            authorName.title = xss(author.tag);\n            authorName.textContent = author.username;\n            authorName.setAttribute('data-user-id', author.id);\n\n            content.appendChild(authorName);\n\n            if (author.bot) {\n                const botTag = document.createElement('span');\n                botTag.classList.add('chatlog__bot-tag');\n                botTag.textContent = 'BOT';\n                content.appendChild(botTag);\n            }\n\n            // timestamp\n            const timestamp = document.createElement('span');\n            timestamp.classList.add('chatlog__timestamp');\n            timestamp.textContent = message.createdAt.toLocaleString();\n\n            content.appendChild(timestamp);\n\n            const messageContent = document.createElement('div');\n            messageContent.classList.add('chatlog__message');\n            messageContent.setAttribute('data-message-id', message.id);\n            messageContent.setAttribute('id', `message-${message.id}`);\n            messageContent.title = `Message sent: ${message.createdAt.toLocaleString()}`;\n\n            // message content\n            if (message.content) {\n                const messageContentContent = document.createElement('div');\n                messageContentContent.classList.add('chatlog__content');\n\n                const messageContentContentMarkdown = document.createElement('div');\n                messageContentContentMarkdown.classList.add('markdown');\n\n                const messageContentContentMarkdownSpan = document.createElement('span');\n                messageContentContentMarkdownSpan.classList.add('preserve-whitespace');\n                messageContentContentMarkdownSpan.innerHTML = formatContent(message.content, message.webhookId !== null);\n\n                messageContentContentMarkdown.appendChild(messageContentContentMarkdownSpan);\n                messageContentContent.appendChild(messageContentContentMarkdown);\n                messageContent.appendChild(messageContentContent);\n            }\n\n            // message attachments\n            if (message.attachments && message.attachments.size > 0) {\n                for (const attachment of message.attachments.values()) {\n                    const attachmentsDiv = document.createElement('div');\n                    attachmentsDiv.classList.add('chatlog__attachment');\n\n                    const attachmentType = attachment.name.split('.').pop();\n\n                    if (['png', 'jpg', 'jpeg', 'gif'].includes(attachmentType)) {\n                        const attachmentLink = document.createElement('a');\n\n                        const attachmentImage = document.createElement('img');\n                        attachmentImage.classList.add('chatlog__attachment-media');\n                        attachmentImage.src = attachment.proxyURL ?? attachment.url;\n                        attachmentImage.alt = 'Image attachment';\n                        attachmentImage.loading = 'lazy';\n                        attachmentImage.title = `Image: ${attachment.name} (${formatBytes(attachment.size)})`;\n\n                        attachmentLink.appendChild(attachmentImage);\n                        attachmentsDiv.appendChild(attachmentLink);\n                    } else if (['mp4', 'webm'].includes(attachmentType)) {\n                        const attachmentVideo = document.createElement('video');\n                        attachmentVideo.classList.add('chatlog__attachment-media');\n                        attachmentVideo.src = attachment.proxyURL ?? attachment.url;\n                        attachmentVideo.alt = 'Video attachment';\n                        attachmentVideo.controls = true;\n                        attachmentVideo.title = `Video: ${attachment.name} (${formatBytes(attachment.size)})`;\n\n                        attachmentsDiv.appendChild(attachmentVideo);\n                    } else if (['mp3', 'ogg'].includes(attachmentType)) {\n                        const attachmentAudio = document.createElement('audio');\n                        attachmentAudio.classList.add('chatlog__attachment-media');\n                        attachmentAudio.src = attachment.proxyURL ?? attachment.url;\n                        attachmentAudio.alt = 'Audio attachment';\n                        attachmentAudio.controls = true;\n                        attachmentAudio.title = `Audio: ${attachment.name} (${formatBytes(attachment.size)})`;\n\n                        attachmentsDiv.appendChild(attachmentAudio);\n                    } else {\n                        const attachmentGeneric = document.createElement('div');\n                        attachmentGeneric.classList.add('chatlog__attachment-generic');\n\n                        const attachmentGenericIcon = document.createElement('svg');\n                        attachmentGenericIcon.classList.add('chatlog__attachment-generic-icon');\n\n                        const attachmentGenericIconUse = document.createElement('use');\n                        attachmentGenericIconUse.setAttribute('href', '#icon-attachment');\n\n                        attachmentGenericIcon.appendChild(attachmentGenericIconUse);\n                        attachmentGeneric.appendChild(attachmentGenericIcon);\n\n                        const attachmentGenericName = document.createElement('div');\n                        attachmentGenericName.classList.add('chatlog__attachment-generic-name');\n\n                        const attachmentGenericNameLink = document.createElement('a');\n                        attachmentGenericNameLink.href = attachment.proxyURL ?? attachment.url;\n                        attachmentGenericNameLink.textContent = attachment.name;\n\n                        attachmentGenericName.appendChild(attachmentGenericNameLink);\n                        attachmentGeneric.appendChild(attachmentGenericName);\n\n                        const attachmentGenericSize = document.createElement('div');\n                        attachmentGenericSize.classList.add('chatlog__attachment-generic-size');\n\n                        attachmentGenericSize.textContent = `${formatBytes(attachment.size)}`;\n                        attachmentGeneric.appendChild(attachmentGenericSize);\n\n                        attachmentsDiv.appendChild(attachmentGeneric);\n                    }\n\n                    messageContent.appendChild(attachmentsDiv);\n                }\n            }\n\n            content.appendChild(messageContent);\n\n            // embeds\n            if (message.embeds && message.embeds.length > 0) {\n                for (const embed of message.embeds) {\n                    const embedDiv = document.createElement('div');\n                    embedDiv.classList.add('chatlog__embed');\n\n                    // embed color\n                    if (embed.hexColor) {\n                        const embedColorPill = document.createElement('div');\n                        embedColorPill.classList.add('chatlog__embed-color-pill');\n                        embedColorPill.style.backgroundColor = embed.hexColor;\n\n                        embedDiv.appendChild(embedColorPill);\n                    }\n\n                    const embedContentContainer = document.createElement('div');\n                    embedContentContainer.classList.add('chatlog__embed-content-container');\n\n                    const embedContent = document.createElement('div');\n                    embedContent.classList.add('chatlog__embed-content');\n\n                    const embedText = document.createElement('div');\n                    embedText.classList.add('chatlog__embed-text');\n\n                    // embed author\n                    if (embed.author?.name) {\n                        const embedAuthor = document.createElement('div');\n                        embedAuthor.classList.add('chatlog__embed-author');\n\n                        if (embed.author.iconURL) {\n                            const embedAuthorIcon = document.createElement('img');\n                            embedAuthorIcon.classList.add('chatlog__embed-author-icon');\n                            embedAuthorIcon.src = embed.author.iconURL;\n                            embedAuthorIcon.alt = 'Author icon';\n                            embedAuthorIcon.loading = 'lazy';\n                            embedAuthorIcon.onerror = () => embedAuthorIcon.style.visibility = 'hidden';\n\n                            embedAuthor.appendChild(embedAuthorIcon);\n                        }\n\n                        const embedAuthorName = document.createElement('span');\n                        embedAuthorName.classList.add('chatlog__embed-author-name');\n\n                        if (embed.author.url) {\n                            const embedAuthorNameLink = document.createElement('a');\n                            embedAuthorNameLink.classList.add('chatlog__embed-author-name-link');\n                            embedAuthorNameLink.href = embed.author.url;\n                            embedAuthorNameLink.textContent = embed.author.name;\n\n                            embedAuthorName.appendChild(embedAuthorNameLink);\n                        } else {\n                            embedAuthorName.textContent = embed.author.name;\n                        }\n\n                        embedAuthor.appendChild(embedAuthorName);\n                        embedText.appendChild(embedAuthor);\n                    }\n\n                    // embed title\n                    if (embed.title) {\n                        const embedTitle = document.createElement('div');\n                        embedTitle.classList.add('chatlog__embed-title');\n\n                        if (embed.url) {\n                            const embedTitleLink = document.createElement('a');\n                            embedTitleLink.classList.add('chatlog__embed-title-link');\n                            embedTitleLink.href = embed.url;\n\n                            const embedTitleMarkdown = document.createElement('div');\n                            embedTitleMarkdown.classList.add('markdown', 'preserve-whitespace');\n                            embedTitleMarkdown.textContent = embed.title;\n\n                            embedTitleLink.appendChild(embedTitleMarkdown);\n                            embedTitle.appendChild(embedTitleLink);\n                        } else {\n                            const embedTitleMarkdown = document.createElement('div');\n                            embedTitleMarkdown.classList.add('markdown', 'preserve-whitespace');\n                            embedTitleMarkdown.textContent = embed.title;\n\n                            embedTitle.appendChild(embedTitleMarkdown);\n                        }\n\n                        embedText.appendChild(embedTitle);\n                    }\n\n                    // embed description\n                    if (embed.description) {\n                        const embedDescription = document.createElement('div');\n                        embedDescription.classList.add('chatlog__embed-description');\n\n                        const embedDescriptionMarkdown = document.createElement('div');\n                        embedDescriptionMarkdown.classList.add('markdown', 'preserve-whitespace');\n                        embedDescriptionMarkdown.innerHTML = formatContent(embed.description, true);\n\n                        embedDescription.appendChild(embedDescriptionMarkdown);\n                        embedText.appendChild(embedDescription);\n                    }\n\n                    // embed fields\n                    if (embed.fields && embed.fields.length > 0) {\n                        const embedFields = document.createElement('div');\n                        embedFields.classList.add('chatlog__embed-fields');\n\n                        for (const field of embed.fields) {\n                            const embedField = document.createElement('div');\n                            embedField.classList.add(\n                                ...(!field.inline ? ['chatlog__embed-field'] : ['chatlog__embed-field', 'chatlog__embed-field--inline'])\n                            );\n\n                            // Field name\n                            const embedFieldName = document.createElement('div');\n                            embedFieldName.classList.add('chatlog__embed-field-name');\n\n                            const embedFieldNameMarkdown = document.createElement('div');\n                            embedFieldNameMarkdown.classList.add('markdown', 'preserve-whitespace');\n                            embedFieldNameMarkdown.textContent = field.name;\n\n                            embedFieldName.appendChild(embedFieldNameMarkdown);\n                            embedField.appendChild(embedFieldName);\n\n\n                            // Field value\n                            const embedFieldValue = document.createElement('div');\n                            embedFieldValue.classList.add('chatlog__embed-field-value');\n\n                            const embedFieldValueMarkdown = document.createElement('div');\n                            embedFieldValueMarkdown.classList.add('markdown', 'preserve-whitespace');\n                            embedFieldValueMarkdown.innerHTML = formatContent(field.value, true);\n\n                            embedFieldValue.appendChild(embedFieldValueMarkdown);\n                            embedField.appendChild(embedFieldValue);\n\n                            embedFields.appendChild(embedField);\n                        }\n\n                        embedText.appendChild(embedFields);\n                    }\n\n                    embedContent.appendChild(embedText);\n\n                    // embed thumbnail\n                    if (embed.thumbnail?.proxyURL ?? embed.thumbnail?.url) {\n                        const embedThumbnail = document.createElement('div');\n                        embedThumbnail.classList.add('chatlog__embed-thumbnail-container');\n\n                        const embedThumbnailLink = document.createElement('a');\n                        embedThumbnailLink.classList.add('chatlog__embed-thumbnail-link');\n                        embedThumbnailLink.href = embed.thumbnail.proxyURL ?? embed.thumbnail.url;\n\n                        const embedThumbnailImage = document.createElement('img');\n                        embedThumbnailImage.classList.add('chatlog__embed-thumbnail');\n                        embedThumbnailImage.src = embed.thumbnail.proxyURL ?? embed.thumbnail.url;\n                        embedThumbnailImage.alt = 'Thumbnail';\n                        embedThumbnailImage.loading = 'lazy';\n\n                        embedThumbnailLink.appendChild(embedThumbnailImage);\n                        embedThumbnail.appendChild(embedThumbnailLink);\n\n                        embedContent.appendChild(embedThumbnail);\n                    }\n\n                    embedContentContainer.appendChild(embedContent);\n\n                    // embed image\n                    if (embed.image) {\n                        const embedImage = document.createElement('div');\n                        embedImage.classList.add('chatlog__embed-image-container');\n\n                        const embedImageLink = document.createElement('a');\n                        embedImageLink.classList.add('chatlog__embed-image-link');\n                        embedImageLink.href = embed.image.proxyURL ?? embed.image.url;\n\n                        const embedImageImage = document.createElement('img');\n                        embedImageImage.classList.add('chatlog__embed-image');\n                        embedImageImage.src = embed.image.proxyURL ?? embed.image.url;\n                        embedImageImage.alt = 'Image';\n                        embedImageImage.loading = 'lazy';\n\n                        embedImageLink.appendChild(embedImageImage);\n                        embedImage.appendChild(embedImageLink);\n\n                        embedContentContainer.appendChild(embedImage);\n                    }\n\n                    // footer\n                    if (embed.footer?.text) {\n                        const embedFooter = document.createElement('div');\n                        embedFooter.classList.add('chatlog__embed-footer');\n\n                        if (embed.footer.iconURL) {\n                            const embedFooterIcon = document.createElement('img');\n                            embedFooterIcon.classList.add('chatlog__embed-footer-icon');\n                            embedFooterIcon.src = embed.footer.proxyIconURL ?? embed.footer.iconURL;\n                            embedFooterIcon.alt = 'Footer icon';\n                            embedFooterIcon.loading = 'lazy';\n\n                            embedFooter.appendChild(embedFooterIcon);\n                        }\n\n                        const embedFooterText = document.createElement('span');\n                        embedFooterText.classList.add('chatlog__embed-footer-text');\n                        embedFooterText.textContent = embed.timestamp ? `${embed.footer.text} • ${new Date(embed.timestamp).toLocaleString()}` : embed.footer.text;\n\n                        embedFooter.appendChild(embedFooterText);\n\n                        embedContentContainer.appendChild(embedFooter);\n                    }\n\n                    embedDiv.appendChild(embedContentContainer);\n                    content.appendChild(embedDiv);\n                }\n            }\n\n            messageGroup.appendChild(content);\n            transcript.appendChild(messageGroup);\n        }\n\n        const fileTrans = new discord.AttachmentBuilder(Buffer.from(dom.serialize()), { name: `${interaction.channel.id}.html` });\n        channel.send({ files: [fileTrans] });\n    }\n\n    function formatContent(content, allowExtra = false, replyStyle = false, purify = he.escape) {\n        content = purify(content)\n            .replace(/\\&\\#x60;/g, '`') // we dont want ` to be escaped\n            .replace(/```(.+?)```/gs, code => {\n                if (!replyStyle) {\n                    const split = code.slice(3, -3).split('\\n');\n                    let language = split.shift().trim().toLowerCase();\n\n                    if (static.LanguageAliases[language])\n                        language = static.LanguageAliases[language];\n\n                    if (languages.includes(language)) {\n                        const joined = he.unescape(split.join(\"\\n\"));\n                        return `<div class=\"pre pre--multiline language-${language}\">${hljs.default.highlight(joined, {\n                            language,\n                        }).value\n                            }</div>`;\n                    } else {\n                        return `<div class=\"pre pre--multiline nohighlight\">${code\n                            .slice(3, -3)\n                            .trim()}</div>`;\n                    }\n                } else {\n                    const split = code.slice(3, -3).split('\\n');\n                    split.shift();\n\n                    const joined = he.unescape(split.join('\\n'));\n\n                    return `<span class=\"pre pre--inline\">${joined.substring(0, 42)}</span>`;\n                }\n            })\n            .replace(/\\*\\*(.+?)\\*\\*/g, '<strong>$1</strong>')\n            .replace(/\\*(.+?)\\*/g, '<em>$1</em>')\n            .replace(/~~(.+?)~~/g, '<s>$1</s>')\n            .replace(/__(.+?)__/g, '<u>$1</u>')\n            .replace(/\\_(.+?)\\_/g, '<em>$1</em>')\n            .replace(/`(.+?)`/g, `<span class=\"pre pre--inline\">$1</span>`)\n            .replace(/\\|\\|(.+?)\\|\\|/g, `<span class=\"spoiler-text spoiler-text--hidden\" ${replyStyle ? '' : 'onclick=\"showSpoiler(event, this)\"'}>$1</span>`);\n\n        if (allowExtra) {\n            content = content\n                .replace(/\\[(.+?)\\]\\((.+?)\\)/g, `<a href=\"$2\">$1</a>`)\n        }\n\n        return replyStyle ? content.replace(/(?:\\r\\n|\\r|\\n)/g, ' ') : content.replace(/(?:\\r\\n|\\r|\\n)/g, '<br />'); // do this last\n    }\n\n    function formatBytes(bytes, decimals = 2) {\n        if (bytes === 0) return '0 Bytes';\n\n        const k = 1024;\n        const dm = decimals < 0 ? 0 : decimals;\n        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\n\n        const i = Math.floor(Math.log(bytes) / Math.log(k));\n\n        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];\n    }\n}","size_bytes":25187},"src/handlers/games/counting.js":{"content":"const Discord = require(\"discord.js\");\n\nconst countSchema = require(\"../../database/models/countChannel\");\nconst count = require(\"../../database/models/count\");\n\nmodule.exports = async (client) => {\n  client\n    .on(\"messageCreate\", async (message) => {\n      if (message.author.bot || message.channel.type === Discord.ChannelType.DM) return;\n\n      if (\n        isNaN(message.content) ||\n        message.attachments.size > 0 ||\n        message.type == Discord.MessageType.ChannelPinnedMessage\n      )\n        return;\n\n      const data = await countSchema.findOne({\n        Guild: message.guild.id,\n        Channel: message.channel.id,\n      });\n      const countData = await count.findOne({ Guild: message.guild.id });\n\n      if (data && countData) {\n        if (message.author.id == countData.User) {\n          try {\n            client.errNormal(\n              {\n                error:\n                  \"You cannot count twice in a row! Count starts again from 1\",\n                type: \"reply\",\n              },\n              message\n            );\n\n            countData.Count = 1;\n            countData.User = \" \";\n            countData.save();\n            return message.react(client.emotes.normal.error);\n          } catch (error) {\n            message.react(client.emotes.normal.error);\n            console.log(error);\n          }\n        } else {\n          if (message.content == countData.Count) {\n            message.react(client.emotes.normal.check);\n            countData.User = message.author.id;\n            countData.Count += 1;\n            countData.save();\n          } else {\n            try {\n              client.errNormal(\n                {\n                  error: `The correct number was ${countData.Count}! Count starts again from 1`,\n                  type: \"reply\",\n                },\n                message\n              );\n\n              countData.Count = 1;\n              countData.User = \" \";\n              countData.save();\n              return message.react(client.emotes.normal.error);\n            } catch (error) {\n              message.react(client.emotes.normal.error);\n              console.log(error)\n            }\n          }\n        }\n      } else if (data) {\n        if (message.content == 1) {\n          message.react(client.emotes.normal.check);\n\n          new count({\n            Guild: message.guild.id,\n            User: message.author.id,\n            Count: 2,\n          }).save();\n        } else {\n          return message.react(client.emotes.normal.error);\n        }\n      }\n    })\n    .setMaxListeners(0);\n\n  client\n    .on(\"messageDelete\", async (message) => {\n      try {\n        if (isNaN(message.content) || message.author.bot) return;\n\n        const data = await countSchema.findOne({\n          Guild: message.guild.id,\n          Channel: message.channel.id,\n        });\n        const countData = await count.findOne({ Guild: message.guild.id });\n\n        if (data && countData) {\n          let lastCount = countData.Count - 1;\n          if (message.content == lastCount) {\n            client.simpleEmbed(\n              {\n                desc: `**${message.author.tag}**: ${message.content}`,\n              },\n              message.channel\n            );\n          }\n        }\n      } catch {}\n    })\n    .setMaxListeners(0);\n};\n\n \n","size_bytes":3289},"src/handlers/games/economy.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/economy\");\nconst itemSchema = require(\"../../database/models/economyItems\");\n\nmodule.exports = async (client) => {\n    client.addMoney = async function (interaction, user, amount) {\n        Schema.findOne({ Guild: interaction.guild.id, User: user.id }, async (err, data) => {\n            if (data) {\n                data.Money += amount;\n                data.save();\n            }\n            else {\n                new Schema({\n                    Guild: interaction.guild.id,\n                    User: user.id,\n                    Money: amount,\n                    Bank: 0\n                }).save();\n            }\n        })\n    }\n\n    client.removeMoney = async function (interaction, user, amount) {\n        Schema.findOne({ Guild: interaction.guild.id, User: user.id }, async (err, data) => {\n            if (data) {\n                data.Money -= amount;\n                data.save();\n            }\n            else {\n                client.errNormal(`User has no ${client.emotes.economy.coins}!`, interaction.channel);\n            }\n        })\n    }\n\n    client.buyItem = async function (interaction, user, item) {\n        const data = await itemSchema.findOne({ Guild: interaction.guild.id, User: user.id });\n\n        if (item == \"FishingRod\") {\n            if (data) {\n                data.FishingRod = true;\n                data.save();\n            }\n            else {\n                new itemSchema({\n                    Guild: interaction.guild.id,\n                    User: user.id,\n                    FishingRod: true,\n                }).save();\n            }\n        }\n    }\n}","size_bytes":1678},"src/handlers/games/guessNumber.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/guessNumber\");\n\nmodule.exports = async (client) => {\n  client.on(Discord.Events.MessageCreate, async (message) => {\n    if (message.author.bot || message.channel.type === Discord.ChannelType.DM) return;\n\n    const data = await Schema.findOne({ Guild: message.guild.id, Channel: message.channel.id })\n    if (data) {\n      let number = parseInt(data.Number);\n      let userNumber = parseInt(message.content);\n      if (!userNumber) return;\n\n      if (userNumber == number) {\n        message.react(client.emotes.normal.check);\n        let number = Math.ceil(Math.random() * 10000);\n\n        let amount = Math.floor(Math.random() * 100) + 1;\n        client.addMoney(message, message.author, amount);\n\n        client.embed({\n          title: `🔢・Guess the number`,\n          desc: `The number is guessed and has a value of $${amount}`,\n          fields: [\n            {\n              name: `👤┇Guessed by`,\n              value: `${message.author} (${message.author.tag})`,\n              inline: true\n            },\n            {\n              name: `🔢┇Correct number`,\n              value: `${data.Number}`,\n              inline: true\n            }\n          ]\n        }, message.channel);\n\n        data.Number = number;\n        data.save();\n\n        client.embed({\n          title: `🔢・Guess the number`,\n          desc: `Guess the number between **1** and **10.000**!`\n        }, message.channel)\n      }\n      else if (userNumber > number) {\n        return message.react(client.emotes.normal.arrowDown);\n      }\n      else if (userNumber < number) {\n        return message.react(client.emotes.normal.arrowUp);\n      }\n    }\n  }).setMaxListeners(0);\n}","size_bytes":1752},"src/handlers/games/guessWord.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/guessWord\");\n\nmodule.exports = async (client) => {\n  client.on(Discord.Events.MessageCreate, async (message) => {\n    if (message.author.bot || message.channel.type === Discord.ChannelType.DM) return;\n\n    let wordList = client.config.wordList;\n    wordList = wordList.split(\"\\n\");\n\n    const data = await Schema.findOne({ Guild: message.guild.id, Channel: message.channel.id });\n\n    if (data) {\n      if (message.content.toLowerCase() == data.Word.toLowerCase()) {\n        message.react(client.emotes.normal.check);\n        var word = wordList[Math.floor(Math.random() * wordList.length)];\n        var shuffled = word.split('').sort(function () { return 0.5 - Math.random() }).join('');\n\n        let amount = Math.floor(Math.random() * 100) + 1;\n        client.addMoney(message, message.author, amount);\n\n        client.embed({\n          title: `💬・Guess the word`,\n          desc: `The word is guessed and has a value of $${amount}`,\n          fields: [\n            {\n              name: `👤┇Guessed by`,\n              value: `${message.author} (${message.author.tag})`,\n              inline: true\n            },\n            {\n              name: `💬┇Correct word`,\n              value: `${data.Word}`,\n              inline: true\n            }\n          ]\n        }, message.channel);\n\n        data.Word = word;\n        data.save();\n\n        return client.embed({\n          title: `💬・Guess the word`,\n          desc: `Put the letters in the right position!`,\n          fields: [\n            {\n              name: `🔀┆Word`,\n              value: `${shuffled.toLowerCase()}`\n            }\n          ]\n        }, message.channel)\n      }\n      else {\n        return message.react(client.emotes.normal.error);\n      }\n    }\n  }).setMaxListeners(0);\n}","size_bytes":1856},"src/handlers/games/levels.js":{"content":"const discord = require('discord.js');\n\nconst levels = require(\"../../database/models/levels\");\n\nmodule.exports = async (client) => {\n    client.setXP = async function (userId, guildId, xp) {\n        const user = await levels.findOne({ userID: userId, guildID: guildId });\n        if (!user) return false;\n\n        user.xp = xp;\n        user.level = Math.floor(0.1 * Math.sqrt(user.xp));\n        user.lastUpdated = new Date();\n\n        user.save();\n\n        return user;\n    }\n\n    client.setLevel = async function (userId, guildId, level) {\n        const user = await levels.findOne({ userID: userId, guildID: guildId });\n        if (!user) return false;\n\n        user.level = level;\n        user.xp = level * level * 100;\n        user.lastUpdated = new Date();\n\n        user.save();\n\n        return user;\n    }\n\n    client.addXP = async function (userId, guildId, xp) {\n        const user = await levels.findOne({ userID: userId, guildID: guildId });\n\n        if (!user) {\n            const newUser = new levels({\n                userID: userId,\n                guildID: guildId,\n                xp: xp,\n                level: Math.floor(0.1 * Math.sqrt(xp))\n            }).save();\n\n            return (Math.floor(0.1 * Math.sqrt(xp)) > 0);\n        }\n\n        user.xp += parseInt(xp, 10);\n        user.level = Math.floor(0.1 * Math.sqrt(user.xp));\n        user.lastUpdated = new Date();\n\n        await user.save();\n\n        return (Math.floor(0.1 * Math.sqrt(user.xp -= xp)) < user.level);\n    }\n\n    client.addLevel = async function (userId, guildId, level) {\n        const user = await levels.findOne({ userID: userId, guildID: guildId });\n        if (!user) return false;\n\n        user.level += parseInt(level, 10);\n        user.xp = user.level * user.level * 100;\n        user.lastUpdated = new Date();\n\n        user.save();\n\n        return user;\n    }\n\n    client.fetchLevels = async function (userId, guildId, fetchPosition = true) {\n        const user = await levels.findOne({\n            userID: userId,\n            guildID: guildId\n        });\n        if (!user) return false;\n\n        if (fetchPosition === true) {\n            const leaderboard = await levels.find({\n                guildID: guildId\n            }).sort([['xp', 'descending']]).exec();\n\n            user.position = leaderboard.findIndex(i => i.userID === userId) + 1;\n        }\n\n        user.cleanXp = user.xp - client.xpFor(user.level);\n        user.cleanNextLevelXp = client.xpFor(user.level + 1) - client.xpFor(user.level);\n\n        return user;\n    }\n\n    client.xpFor = function (targetLevel) {\n        return targetLevel * targetLevel * 100;\n    }\n}","size_bytes":2633},"src/handlers/games/wordsnake.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/wordsnake\");\n\nmodule.exports = async (client) => {\n  client.on(Discord.Events.MessageCreate, async (message) => {\n    if (message.author.bot || message.channel.type === Discord.ChannelType.DM) return;\n\n    Schema.findOne({ Guild: message.guild.id, Channel: message.channel.id }, async (err, data) => {\n      if (data) {\n        try {\n          if (!data.lastWord || data.lastWord == \" \") {\n            message.react(client.emotes.normal.check);\n\n            var word = message.content;\n\n            data.lastWord = word;\n            data.save();\n            return;\n          }\n\n          const result = data.lastWord.split('');\n          let number = result.length - 1;\n\n          if (message.content.toLowerCase().startsWith(result[number].toLowerCase())) {\n            message.react(client.emotes.normal.check);\n\n            var word = message.content.replace(\" \", \"\");\n\n            data.lastWord = word;\n            data.save();\n            return;\n          }\n          else {\n            return message.react(client.emotes.normal.error);\n          }\n        }\n        catch (err) {\n          console.log(err);\n        }\n      }\n    })\n  }).setMaxListeners(0);\n}","size_bytes":1253},"src/handlers/linkspanel/botInvite.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client) => {\n    client.on(Discord.Events.InteractionCreate, async (interaction) => {\n        if (!interaction.isStringSelectMenu()) return;\n\n        if (interaction.customId == \"Bot-linkspanel\") {\n            if (interaction.values == \"invite-linkspanel\") {\n                interaction.deferUpdate();\n\n                const row2 = new Discord.ActionRowBuilder()\n                    .addComponents(\n                        new Discord.StringSelectMenuBuilder()\n                            .setCustomId('Bot-linkspanel')\n                            .setPlaceholder('❌┆Nothing selected')\n                            .addOptions([\n                                {\n                                    label: `Support server`,\n                                    description: `Join the suppport server`,\n                                    emoji: \"❓\",\n                                    value: \"support-linkspanel\",\n                                },\n                                {\n                                    label: `Invite Bot`,\n                                    description: `Invite Bot to your server`,\n                                    emoji: \"📨\",\n                                    value: \"invite-linkspanel\",\n                                },\n                                {\n                                    label: `Community Server`,\n                                    description: `Join the community server!`,\n                                    emoji: \"🌍\",\n                                    value: \"community-linkspanel\",\n                                },\n                                {\n                                    label: `Top.gg`,\n                                    description: `Show the top.gg link`,\n                                    emoji: \"📃\",\n                                    value: \"top.gg-linkspanel\",\n                                },\n                            ]),\n                    );\n\n                let row = new Discord.ActionRowBuilder()\n                    .addComponents(\n                        new Discord.ButtonBuilder()\n                            .setLabel(\"Bot Invite\")\n                            .setURL(client.config.discord.botInvite)\n                            .setStyle(Discord.ButtonStyle.Link),\n                    );\n\n                client.embed({\n                    title: `📨・Bot Invite`,\n                    desc: `Make your server even better with Bot!`,\n                    image: \"https://cdn.discordapp.com/attachments/843487478881976381/874694194474668052/Bot_banner_invite.jpg\",\n                    url: client.config.discord.serverInvite,\n                    components: [row2, row],\n                    type: 'edit'\n                }, interaction.message)\n            }\n        }\n    })\n}\n\n ","size_bytes":2877},"src/handlers/linkspanel/communityServer.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client) => {\n    client.on(Discord.Events.InteractionCreate, async (interaction) => {\n        if (!interaction.isStringSelectMenu()) return;\n\n        if (interaction.customId == \"Bot-linkspanel\") {\n            if (interaction.values == \"community-linkspanel\") {\n                interaction.deferUpdate();\n\n                const row2 = new Discord.ActionRowBuilder()\n                    .addComponents(\n                        new Discord.StringSelectMenuBuilder()\n                            .setCustomId('Bot-linkspanel')\n                            .setPlaceholder('❌┆Nothing selected')\n                            .addOptions([\n                                {\n                                    label: `Support server`,\n                                    description: `Join the suppport server`,\n                                    emoji: \"❓\",\n                                    value: \"support-linkspanel\",\n                                },\n                                {\n                                    label: `Invite Bot`,\n                                    description: `Invite Bot to your server`,\n                                    emoji: \"📨\",\n                                    value: \"invite-linkspanel\",\n                                },\n                                {\n                                    label: `Community Server`,\n                                    description: `Join the community server!`,\n                                    emoji: \"🌍\",\n                                    value: \"community-linkspanel\",\n                                },\n                                {\n                                    label: `Top.gg`,\n                                    description: `Show the top.gg link`,\n                                    emoji: \"📃\",\n                                    value: \"top.gg-linkspanel\",\n                                },\n                            ]),\n                    );\n\n                let row = new Discord.ActionRowBuilder()\n                    .addComponents(\n\n                        new Discord.ButtonBuilder()\n                            .setLabel(\"Community Server\")\n                            .setURL(\"https://discord.gg/jf6ZkpgsXF\")\n                            .setStyle(Discord.ButtonStyle.Link),\n                    );\n\n                client.embed({\n                    title: `🌍・Community Server`,\n                    desc: `Talk and play games in the comunity server!`,\n                    image: \"https://cdn.discordapp.com/attachments/843487478881976381/874694194474668052/Bot_banner_invite.jpg\",\n                    url: client.config.discord.botInvite,\n                    components: [row2, row],\n                    type: 'edit'\n                }, interaction.message)\n            }\n        }\n    })\n}\n\n ","size_bytes":2895},"src/handlers/linkspanel/supportServer.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client) => {\n    client.on(Discord.Events.InteractionCreate, async (interaction) => {\n        if (!interaction.isStringSelectMenu()) return;\n\n        if (interaction.customId == \"Bot-linkspanel\") {\n            if (interaction.values == \"support-linkspanel\") {\n                interaction.deferUpdate();\n\n                const row2 = new Discord.ActionRowBuilder()\n                    .addComponents(\n                        new Discord.StringSelectMenuBuilder()\n                            .setCustomId('Bot-linkspanel')\n                            .setPlaceholder('❌┆Nothing selected')\n                            .addOptions([\n                                {\n                                    label: `Support server`,\n                                    description: `Join the suppport server`,\n                                    emoji: \"❓\",\n                                    value: \"support-linkspanel\",\n                                },\n                                {\n                                    label: `Invite Bot`,\n                                    description: `Invite Bot to your server`,\n                                    emoji: \"📨\",\n                                    value: \"invite-linkspanel\",\n                                },\n                                {\n                                    label: `Community Server`,\n                                    description: `Join the community server!`,\n                                    emoji: \"🌍\",\n                                    value: \"community-linkspanel\",\n                                },\n                                {\n                                    label: `Top.gg`,\n                                    description: `Show the top.gg link`,\n                                    emoji: \"📃\",\n                                    value: \"top.gg-linkspanel\",\n                                },\n                            ]),\n                    );\n\n                let row = new Discord.ActionRowBuilder()\n                    .addComponents(\n                        new Discord.ButtonBuilder()\n                            .setLabel(\"Support Server\")\n                            .setURL(client.config.discord.serverInvite)\n                            .setStyle(Discord.ButtonStyle.Link),\n                    );\n\n                client.embed({\n                    title: `❓・Support Server`,\n                    desc: `Make your server even better with Bot!`,\n                    image: \"https://cdn.discordapp.com/attachments/843487478881976381/874694194474668052/Bot_banner_invite.jpg\",\n                    url: client.config.discord.serverInvite,\n                    components: [row2, row],\n                    type: 'edit'\n                }, interaction.message)\n            }\n        }\n    })\n}\n\n ","size_bytes":2888},"src/handlers/linkspanel/topGG.js":{"content":"const Discord = require('discord.js');\n\nmodule.exports = async (client) => {\n    client.on(Discord.Events.InteractionCreate, async (interaction) => {\n        if (!interaction.isStringSelectMenu()) return;\n\n        if (interaction.customId == \"Bot-linkspanel\") {\n            if (interaction.values == \"top.gg-linkspanel\") {\n                interaction.deferUpdate();\n\n                const row2 = new Discord.ActionRowBuilder()\n                    .addComponents(\n                        new Discord.StringSelectMenuBuilder()\n                            .setCustomId('Bot-linkspanel')\n                            .setPlaceholder('❌┆Nothing selected')\n                            .addOptions([\n                                {\n                                    label: `Support server`,\n                                    description: `Join the suppport server`,\n                                    emoji: \"❓\",\n                                    value: \"support-linkspanel\",\n                                },\n                                {\n                                    label: `Invite Bot`,\n                                    description: `Invite Bot to your server`,\n                                    emoji: \"📨\",\n                                    value: \"invite-linkspanel\",\n                                },\n                                {\n                                    label: `Community Server`,\n                                    description: `Join the community server!`,\n                                    emoji: \"🌍\",\n                                    value: \"community-linkspanel\",\n                                },\n                                {\n                                    label: `Top.gg`,\n                                    description: `Show the top.gg link`,\n                                    emoji: \"📃\",\n                                    value: \"top.gg-linkspanel\",\n                                },\n                            ]),\n                    );\n\n                let row = new Discord.ActionRowBuilder()\n                    .addComponents(\n\n                        new Discord.ButtonBuilder()\n                            .setLabel(\"Vote Now\")\n                            .setURL(\"https://top.gg/bot/798144456528363550/vote\")\n                            .setStyle(Discord.ButtonStyle.Link),\n                    );\n\n                client.embed({\n                    title: `📃・Bot Vote`,\n                    desc: `Vote for Bot on top.gg`,\n                    image: \"https://cdn.discordapp.com/attachments/843487478881976381/874694192755007509/Bot_banner_vote.jpg\",\n                    url: \"https://top.gg/bot/798144456528363550/vote\",\n                    components: [row2, row],\n                    type: 'edit'\n                }, interaction.message)\n            }\n        }\n    })\n}\n\n ","size_bytes":2879},"src/handlers/loaders/commands.js":{"content":"const Discord = require('discord.js');\nconst { REST } = require('discord.js');\nconst { Routes } = require('discord.js');\nconst chalk = require('chalk');\nconst fs = require('fs');\n\nmodule.exports = (client) => {\n    const interactionLogs = new Discord.WebhookClient({\n        id: client.webhooks.interactionLogs.id,\n        token: client.webhooks.interactionLogs.token,\n    });\n\n    const commands = [];\n\n    if (client.shard.ids[0] === 0) console.log(chalk.blue(chalk.bold(`System`)), (chalk.white(`>>`)), (chalk.green(`Loading commands`)), (chalk.white(`...`)))\n    if (client.shard.ids[0] === 0) console.log(`\\u001b[0m`);\n\n    fs.readdirSync('./src/interactions').forEach(dirs => {\n        const commandFiles = fs.readdirSync(`./src/interactions/${dirs}`).filter(files => files.endsWith('.js'));\n\n        if (client.shard.ids[0] === 0) console.log(chalk.blue(chalk.bold(`System`)), (chalk.white(`>>`)), chalk.red(`${commandFiles.length}`), (chalk.green(`commands of`)), chalk.red(`${dirs}`), (chalk.green(`loaded`)));\n\n        for (const file of commandFiles) {\n            const command = require(`${process.cwd()}/src/interactions/${dirs}/${file}`);\n            client.commands.set(command.data.name, command);\n            commands.push(command.data);\n        };\n    });\n\n    const rest = new REST({ version: '9' }).setToken(process.env.DISCORD_TOKEN);\n\n    (async () => {\n        try {\n            const embed = new Discord.EmbedBuilder()\n                .setDescription(`Started refreshing application (/) commands.`)\n                .setColor(client.config.colors.normal)\n            interactionLogs.send({\n                username: 'Bot Logs',\n                embeds: [embed]\n            });\n\n            await rest.put(\n                Routes.applicationCommands(client.config.discord.id),\n                { body: commands },\n            )\n\n            const embedFinal = new Discord.EmbedBuilder()\n                .setDescription(`Successfully reloaded ${commands.length} application (/) commands.`)\n                .setColor(client.config.colors.normal)\n            interactionLogs.send({\n                username: 'Bot Logs',\n                embeds: [embedFinal]\n            });\n\n        } catch (error) {\n            console.log(error);\n        }\n    })();\n}\n\n ","size_bytes":2274},"src/handlers/loaders/event.js":{"content":"const chalk = require('chalk');\nconst fs = require('fs');\nconst Discord = require('discord.js');\n\nmodule.exports = (client) => {\n\n    if (client.shard.ids[0] === 0) console.log(`\\u001b[0m`);\n    if (client.shard.ids[0] === 0) console.log(chalk.blue(chalk.bold(`System`)), (chalk.white(`>>`)), (chalk.green(`Loading events`)), (chalk.white(`...`)))\n    if (client.shard.ids[0] === 0) console.log(`\\u001b[0m`);\n\n    fs.readdirSync('./src/events').forEach(dirs => {\n        const events = fs.readdirSync(`./src/events/${dirs}`).filter(files => files.endsWith('.js'));\n\n        if (client.shard.ids[0] === 0) console.log(chalk.blue(chalk.bold(`System`)), (chalk.white(`>>`)), chalk.red(`${events.length}`), (chalk.green(`events of`)), chalk.red(`${dirs}`), (chalk.green(`loaded`)));\n\n        for (const file of events) {\n            const event = require(`../../events/${dirs}/${file}`);\n            const eventName = file.split(\".\")[0];\n            const eventUpperCase = eventName.charAt(0).toUpperCase() + eventName.slice(1);\n            if(Discord.Events[eventUpperCase] === undefined){\n                client.on(eventName, event.bind(null, client)).setMaxListeners(0);\n            }else {\n            client.on(Discord.Events[eventUpperCase], event.bind(null, client)).setMaxListeners(0);\n            }\n        };\n    });\n}\n\n ","size_bytes":1327},"src/handlers/security/antiad.js":{"content":"const Discord = require(\"discord.js\");\n\nconst Schema = require(\"../../database/models/functions\");\nconst Schema2 = require(\"../../database/models/channelList\");\n\nmodule.exports = (client) => {\n    client.on(Discord.Events.MessageCreate, async (message) => {\n        if (message.channel.type === Discord.ChannelType.DM || message.author.bot) return;\n        Schema.findOne({ Guild: message.guild.id }, async (err, data) => {\n            if (data) {\n                if (data.AntiInvite == true) {\n                    const { content } = message\n\n                    const code = content.split('discord.gg/')[1]\n                    if (code) {\n                        Schema2.findOne({ Guild: message.guild.id }, async (err, data2) => {\n                            if (data2) {\n                                if (data2.Channels.includes(message.channel.id) || message.member.permissions.has(Discord.PermissionsBitField.Flags.ManageMessages)) {\n                                    return;\n                                }\n\n                                message.delete();\n\n                                client.embed({\n                                    title: `${client.emotes.normal.error}・Moderator`,\n                                    desc: `Discord links are not allowed in this server!`,\n                                    color: client.config.colors.error,\n                                    content: `${message.author}`\n                                }, message.channel)\n                            }\n                            else {\n                                if (message.member.permissions.has(Discord.PermissionsBitField.Flags.ManageMessages)) return;\n                                message.delete();\n\n                                client.embed({\n                                    title: `${client.emotes.normal.error}・Moderator`,\n                                    desc: `Discord links are not allowed in this server!`,\n                                    color: client.config.colors.error,\n                                    content: `${message.author}`\n                                }, message.channel)\n                            }\n                        })\n                    }\n                }\n                else if (data.AntiLinks == true) {\n                    const { content } = message\n\n                    if (content.includes('http://') || content.includes('https://') || content.includes('www.')) {\n                        Schema2.findOne({ Guild: message.guild.id }, async (err, data2) => {\n                            if (data2) {\n                                if (data2.Channels.includes(message.channel.id) || message.member.permissions.has(Discord.PermissionsBitField.Flags.ManageMessages)) {\n                                    return;\n                                }\n\n                                message.delete();\n\n                                client.embed({\n                                    title: `${client.emotes.normal.error}・Moderator`,\n                                    desc: `Links are not allowed in this server!`,\n                                    color: client.config.colors.error,\n                                    content: `${message.author}`\n                                }, message.channel)\n                            }\n                            else {\n                                if (message.member.permissions.has(Discord.PermissionsBitField.Flags.ManageMessages)) return;\n                                message.delete();\n                               \n                                client.embed({\n                                    title: `${client.emotes.normal.error}・Moderator`,\n                                    desc: `Links are not allowed in this server!`,\n                                    color: client.config.colors.error,\n                                    content: `${message.author}`\n                                }, message.channel)\n                            }\n                        })\n                    }\n                }\n            }\n        })\n    }).setMaxListeners(0);\n\n    client.on(Discord.Events.MessageUpdate, async (oldMessage, newMessage) => {\n        if (oldMessage.content === newMessage.content || newMessage.channel.type === Discord.ChannelType.DM) return;\n\n        Schema.findOne({ Guild: newMessage.guild.id }, async (err, data) => {\n            if (data) {\n                if (data.AntiInvite == true) {\n                    const { content } = newMessage\n\n                    const code = content.split('discord.gg/')[1]\n                    if (code) {\n                        Schema2.findOne({ Guild: newMessage.guild.id }, async (err, data2) => {\n                            if (data2) {\n                                if (data2.Channels.includes(newMessage.channel.id) || newMessage.member.permissions.has(Discord.PermissionsBitField.Flags.ManageMessages)) {\n                                    return;\n                                }\n\n                                newMessage.delete();\n                                let error = new Discord.EmbedBuilder()\n                                    .setTitle(`${client.emotes.normal.error}・Moderator`)\n                                    .setAuthor(client.user.username, client.user.avatarURL())\n                                    .setDescription(`Discord links are not allowed in this server!`)\n                                    .setColor(client.config.colors.error)\n                                    .setFooter({ text: client.config.discord.footer })\n                                    .setTimestamp();\n                                var msg = newMessage.channel.send({ content: `${newMessage.author}`, embeds: [error] })\n                                setTimeout(() => {\n                                    try{\n                                        msg.delete();\n                                    } catch (e) {\n                                        return;\n                                    }\n                                }, 5000)\n                            }\n                            else {\n                                if (newMessage.member.permissions.has(Discord.PermissionsBitField.Flags.ManageMessages)) return;\n                                newMessage.delete();\n                                let error = new Discord.EmbedBuilder()\n                                    .setTitle(`${client.emotes.normal.error}・Moderator`)\n                                    .setAuthor(client.user.username, client.user.avatarURL())\n                                    .setDescription(`Discord links are not allowed in this server!`)\n                                    .setColor(client.config.colors.error)\n                                    .setFooter({ text: client.config.discord.footer })\n                                    .setTimestamp();\n                                var msg = newMessage.channel.send({ content: `${newMessage.author}`, embeds: [error] })\n                                setTimeout(() => {\n                                    try {\n                                        msg.delete();\n                                    } catch (e) {\n                                        return;\n                                    }\n                                }, 5000)\n                            }\n                        })\n                    }\n                }\n                else if (data.AntiLinks == true) {\n                    const { guild, member, content } = newMessage\n\n                    if (content.includes('http://') || content.includes('https://') || content.includes('www.')) {\n                        Schema2.findOne({ Guild: newMessage.guild.id }, async (err, data2) => {\n                            if (data2) {\n                                if (data2.Channels.includes(newMessage.channel.id) || newMessage.member.permissions.has(Discord.PermissionsBitField.Flags.ManageMessages)) {\n                                    return;\n                                }\n\n                                newMessage.delete();\n                                var error = new Discord.EmbedBuilder()\n                                    .setTitle(`${client.emotes.normal.error}・Moderator`)\n                                    .setAuthor(client.user.username, client.user.avatarURL())\n                                    .setDescription(`Links are not allowed in this server!`)\n                                    .setColor(client.config.colors.error)\n                                    .setFooter({ text: client.config.discord.footer })\n                                    .setTimestamp();\n                                var msg = newMessage.channel.send({ content: `${newMessage.author}`, embeds: [error] })\n                                setTimeout(() => {\n                                    try {\n                                        msg.delete();\n                                    } catch (e) {\n                                        return;\n                                    }\n                                }, 5000)\n                            }\n                            else {\n                                if (newMessage.member.permissions.has(Discord.PermissionsBitField.Flags.ManageMessages)) return;\n                                newMessage.delete();\n                                var error = new Discord.EmbedBuilder()\n                                    .setTitle(`${client.emotes.normal.error}・Moderator`)\n                                    .setAuthor(client.user.username, client.user.avatarURL())\n                                    .setDescription(`Links are not allowed in this server!`)\n                                    .setColor(client.config.colors.error)\n                                    .setFooter({ text: client.config.discord.footer })\n                                    .setTimestamp();\n                                var msg = newMessage.channel.send({ content: `${newMessage.author}`, embeds: [error] })\n                                setTimeout(() => {\n                                    try {\n                                        msg.delete();\n                                    } catch (e) {\n                                        return;\n                                    }\n                                }, 5000)\n                            }\n                        })\n                    }\n                }\n            }\n        })\n    }).setMaxListeners(0);\n}\n","size_bytes":10518},"src/handlers/security/antispam.js":{"content":"const Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/functions\");\n\nconst usersMap = new Map();\nconst LIMIT = 5;\nconst TIME = 10000;\nconst DIFF = 3000;\n\nmodule.exports = async (client) => {\n    client.on(Discord.Events.MessageCreate, async (message) => {\n        if (message.author.bot || message.channel.type === Discord.ChannelType.DM) return;\n\n        Schema.findOne({ Guild: message.guild.id }, async (err, data) => {\n            if (data) {\n                if (data.AntiSpam == true) {\n                    if (usersMap.has(message.author.id)) {\n                        const userData = usersMap.get(message.author.id);\n                        const { lastMessage, timer } = userData;\n                        const difference = message.createdTimestamp - lastMessage.createdTimestamp;\n                        let msgCount = userData.msgCount;\n\n                        if (difference > DIFF) {\n                            clearTimeout(timer);\n                            userData.msgCount = 1;\n                            userData.lastMessage = message;\n                            userData.timer = setTimeout(() => {\n                                usersMap.delete(message.author.id);\n                            }, TIME);\n                            usersMap.set(message.author.id, userData)\n                        }\n                        else {\n                            ++msgCount;\n                            if (parseInt(msgCount) === LIMIT) {\n                                message.delete();\n\n                                client.embed({\n                                    title: `${client.emotes.normal.error}・Moderator`,\n                                    desc: `It is not allowed to spam in this server!`,\n                                    color: client.config.colors.error,\n                                    content: `${message.author}`\n                                }, message.channel)\n                            } else {\n                                userData.msgCount = msgCount;\n                                usersMap.set(message.author.id, userData);\n                            }\n                        }\n                    }\n                    else {\n                        let fn = setTimeout(() => {\n                            usersMap.delete(message.author.id);\n                        }, TIME);\n                        usersMap.set(message.author.id, {\n                            msgCount: 1,\n                            lastMessage: message,\n                            timer: fn\n                        });\n                    }\n                }\n            }\n        })\n    }).setMaxListeners(0);\n}","size_bytes":2688},"src/handlers/security/blacklist.js":{"content":"const Discord = require('discord.js');\n\nconst BlackList = require(\"../../database/models/blacklist\");\n\nmodule.exports = async (client) => {\n    client.on(Discord.Events.MessageCreate, async (message) => {\n        if (message.channel.type === Discord.ChannelType.DM) return;\n\n        try {\n            BlackList.findOne({ Guild: message.guild.id }, async (err, data) => {\n            if (data) {\n                const lowerMsg = message.content.toLowerCase();\n                const splittedMsg = lowerMsg.split(' ');\n\n                let deleting = false;\n\n                await Promise.all(\n                    splittedMsg.map((content) => {\n                        try {\n                            if (data.Words.includes(content.toLowerCase())) deleting = true;\n                        }\n                        catch { }\n                    })\n                )\n\n                if (deleting) return message.delete({ timeout: 1000 });\n            }\n        })\n        }\n        catch { }\n    }).setMaxListeners(0);\n\n    client.on(Discord.Events.MessageUpdate, async (oldMessage, newMessage) => {\n        if (oldMessage.content === newMessage.content || newMessage.channel.type === Discord.ChannelType.DM) return;\n        try {\n            BlackList.findOne({ Guild: oldMessage.guild.id }, async (err, data) => {\n            if (data) {\n                const lowerMsg = newMessage.content.toLowerCase();\n                const splittedMsg = lowerMsg.split(' ');\n\n                let deleting = false;\n\n                await Promise.all(\n                    splittedMsg.map((content) => {\n                        try {\n                            if (data.Words.includes(content.toLowerCase())) deleting = true;\n                        }\n                        catch { }\n                    })\n                )\n\n                if (deleting) return newMessage.delete();\n            }\n        })\n        }\n        catch { }\n    }).setMaxListeners(0);\n}","size_bytes":1954},"src/handlers/security/tempban.js":{"content":"const Schema = require(\"../../database/models/tempban\");\n\nmodule.exports = (client) => {\n    const checkForExpired = async () => {\n        const now = new Date()\n\n        const condition = {\n            expires: {\n                $lt: now,\n            },\n        }\n\n        const results = await Schema.find(condition)\n\n        if (results) {\n            for (const result of results) {\n                const { guildId, userId } = result\n\n                const guild = client.guilds.cache.get(guildId)\n                if (guild) {\n                    guild.members.unban(userId)\n                }\n            }\n\n            await Schema.deleteMany(condition)\n        }\n\n        setTimeout(checkForExpired, 1000 * 10)\n    }\n\n    checkForExpired()\n}","size_bytes":747},"src/interactions/Command/activities.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst Discord = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('activities')\n        .setDescription('Start a activity')\n        .addStringOption(option =>\n            option.setName('activity')\n                .setDescription('The activity that you want')\n                .setRequired(true)\n                .addChoices(\n                    { name: 'Betrayal.io', value: 'betrayal' },\n                    { name: 'Checkers in the Park', value: 'checkers' },\n                    { name: 'Chess in the Park', value: 'chess' },\n                    { name: 'Doodle Crew', value: 'doodlecrew' },\n                    { name: 'Fishington.io', value: 'fishington' },\n                    { name: 'Letter League', value: 'letterleague' },\n                    { name: 'Ocho', value: 'ocho' },\n                    { name: 'Poker Night', value: 'poker' },\n                    { name: 'Sketch Heads', value: 'sketchheads' },\n                    { name: 'Spell Cast', value: 'spellcast' },\n                    { name: 'Word Snacks', value: 'wordsnacks' },\n                    { name: 'Watch Together', value: 'watchtogether' }\n                )\n        )\n    ,\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        const activity = interaction.options.getString('activity');\n\n        const channel = interaction.member.voice.channel;\n        if (!channel) return client.errNormal({ \n            error: `You're not in a voice channel!`, \n            type: 'editreply' \n        }, interaction);\n\n        if (activity == \"betrayal\") {\n            client.generateActivity(\"773336526917861400\", \"Betrayal.io\", channel, interaction)\n        }\n        else if (activity == \"checkers\") {\n            client.generateActivity(\"832013003968348200\", \"Checkers in the Park\", channel, interaction)\n        }\n        else if (activity == \"chess\") {\n            client.generateActivity(\"832012586023256104\", \"Chess in the Park\", channel, interaction)\n        }\n        else if (activity == \"doodlecrew\") {\n            client.generateActivity(\"878067389634314250\", \"Doodle Crew\", channel, interaction)\n        }\n        else if (activity == \"fishington\") {\n            client.generateActivity(\"814288819477020702\", \"Fishington.io\", channel, interaction)\n        }\n        else if (activity == \"lettertile\") {\n            client.generateActivity(\"879863686565621790\", \"Letter Tile\", channel, interaction)\n        }\n        else if (activity == \"poker\") {\n            client.generateActivity(\"755827207812677713\", \"Poker Night\", channel, interaction)\n        }\n        else if (activity == \"spellcast\") {\n            client.generateActivity(\"852509694341283871\", \"Spell Cast\", channel, interaction)\n        }\n        else if (activity == \"wordsnacks\") {\n            client.generateActivity(\"879863976006127627\", \"Word Snacks\", channel, interaction)\n        }\n        else if (activity == \"watchtogether\") {\n            client.generateActivity(\"880218394199220334\", \"Watch Together\", channel, interaction)\n        }\n        else if (activity == \"ocho\") {\n            client.generateActivity(\"832025144389533716\", \"Ocho\", channel, interaction)\n        }\n        else if (activity == \"sketchheads\") {\n            client.generateActivity(\"902271654783242291\", \"Sketch Heads\", channel, interaction)\n        }\n        else if (activity == \"letterleague\") {\n            client.generateActivity(\"879863686565621790\", \"Letter League\", channel, interaction)\n        }\n    },\n};\n\n ","size_bytes":3790},"src/interactions/Command/afk.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/music\");\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('afk')\n        .setDescription('Set your AFK')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('help')\n                .setDescription('Get information about the afk category commands')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('set')\n                .setDescription('Put yourself AFK')\n                .addStringOption(option => option.setName('reason').setDescription('The reason for your AFK'))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('list')\n                .setDescription('Show all afk users')\n        )\n    ,\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        client.loadSubcommands(client, interaction, args);\n    },\n};\n\n ","size_bytes":1251},"src/interactions/Command/announcement.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder, ChannelType } = require('discord.js');\nconst Discord = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('announcement')\n        .setDescription('Manage the server announcements')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('help')\n                .setDescription('Get information about the announcement category commands')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('create')\n                .setDescription('Make an announcement')\n                .addChannelOption(option => option.setName('channel').setDescription('Select a channel').setRequired(true).addChannelTypes(ChannelType.GuildText).addChannelTypes(ChannelType.GuildNews))\n                .addStringOption(option => option.setName('message').setDescription('Your announcement message').setRequired(true)),\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('edit')\n                .setDescription('Edit an announcement')\n                .addStringOption(option => option.setName('id').setDescription('ID of the announcement you want to change').setRequired(true))\n                .addStringOption(option => option.setName('message').setDescription('Your announcement message').setRequired(true)),\n        )\n    ,\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        const perms = await client.checkUserPerms({\n            flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n            perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n        }, interaction)\n\n        if (perms == false) return;\n\n        client.loadSubcommands(client, interaction, args);\n    },\n};\n\n ","size_bytes":2009},"src/interactions/Command/automod.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst { ChannelType } = require('discord.js');\nconst Discord = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('automod')\n        .setDescription('Manage the auto mod')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('help')\n                .setDescription('Get information about the auto setup commands')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('antiinvite')\n                .setDescription('Enable/disable antiinvite')\n                .addBooleanOption(option => option.setName('active').setDescription('Select a boolean').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('antilinks')\n                .setDescription('Enable/disable antilinks')\n                .addBooleanOption(option => option.setName('active').setDescription('Select a boolean').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('antispam')\n                .setDescription('Enable/disable antispam')\n                .addBooleanOption(option => option.setName('active').setDescription('Select a boolean').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('linkschannel')\n                .setDescription('Add a channel that is allowed to send links')\n                .addStringOption(option =>\n                    option.setName('type')\n                        .setDescription('What do you want to do with the channel?')\n                        .setRequired(true)\n                        .addChoices(\n                            { name: 'Add', value: 'add' },\n                            { name: 'Remove', value: 'remove' }\n                        )\n                )\n                .addChannelOption(option => option.setName('channel').setDescription('Select a channel').setRequired(true).addChannelTypes(ChannelType.GuildText))\n        )\n        .addSubcommandGroup(group =>\n            group\n                .setName('blacklist')\n                .setDescription('Manage the blacklist')\n                .addSubcommand(subcommand =>\n                    subcommand\n                        .setName('display')\n                        .setDescription('Show the whole blacklist')\n                )\n                .addSubcommand(subcommand =>\n                    subcommand\n                        .setName('add')\n                        .setDescription('Add a word to the blacklist')\n                        .addStringOption(option => option.setName('word').setDescription('The word for the blacklist').setRequired(true))\n                )\n                .addSubcommand(subcommand =>\n                    subcommand\n                        .setName('remove')\n                        .setDescription('Remove a word from the blacklist')\n                        .addStringOption(option => option.setName('word').setDescription('The word for the blacklist').setRequired(true))\n                )\n        )\n    ,\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        const perms = await client.checkUserPerms({\n            flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n            perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n        }, interaction)\n\n        if (perms == false) return;\n\n        client.loadSubcommands(client, interaction, args);\n    },\n};\n\n ","size_bytes":3786},"src/interactions/Command/autosetup.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst Discord = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('autosetup')\n        .setDescription('Let the bot setup automatically')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('help')\n                .setDescription('Get information about the auto setup commands')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('logs')\n                .setDescription('Set the logs from the server')\n                .addStringOption(option =>\n                    option.setName('setup')\n                        .setDescription('The setup that you want')\n                        .setRequired(true)\n                        .addChoices(\n                            { name: 'Server logs', value: 'serverLogs' },\n                            { name: 'Level logs', value: 'levelLogs' },\n                            { name: 'Boost logs', value: 'boostLogs' }\n                        )\n                )\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('fun')\n                .setDescription('Set the fun channels from the server')\n                .addStringOption(option =>\n                    option.setName('setup')\n                        .setDescription('The setup that you want')\n                        .setRequired(true)\n                        .addChoices(\n                            { name: 'Birthdays', value: 'birthdays' },\n                            { name: 'Chatbot', value: 'chatbot' },\n                            { name: 'Reviews', value: 'reviews' },\n                            { name: 'Suggestions', value: 'suggestions' },\n                            { name: 'Starboard', value: 'starboard' }\n                        )\n                )\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('games')\n                .setDescription('Set the game channels from the server')\n                .addStringOption(option =>\n                    option.setName('setup')\n                        .setDescription('The setup that you want')\n                        .setRequired(true)\n                        .addChoices(\n                            { name: 'Counting', value: 'counting' },\n                            { name: 'Guess the number', value: 'gtn' },\n                            { name: 'Guess the word', value: 'gtw' },\n                            { name: 'Word snake', value: 'wordsnake' }\n                        )\n                )\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('welcome')\n                .setDescription('Setup the welcome system')\n                .addStringOption(option =>\n                    option.setName('setup')\n                        .setDescription('The setup that you want')\n                        .setRequired(true)\n                        .addChoices(\n                            { name: 'Welcome channel', value: 'welcomechannel' },\n                            { name: 'Welcome role', value: 'welcomerole' },\n                            { name: 'Leave channnel', value: 'leavechannel' }\n                        )\n                )\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('customvoice')\n                .setDescription('Set the custom voice channels from the server')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('ticketpanel')\n                .setDescription('Set the ticket panel from the server')\n        )\n    ,\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        const perms = await client.checkUserPerms({\n            flags: [Discord.PermissionsBitField.Flags.Administrator],\n            perms: [Discord.PermissionsBitField.Flags.Administrator]\n        }, interaction)\n\n        if (perms == false) return;\n\n        client.loadSubcommands(client, interaction, args);\n    },\n};\n\n ","size_bytes":4303},"src/interactions/Command/birthdays.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst Discord = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('birthdays')\n        .setDescription('View or register a birthday')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('help')\n                .setDescription('Get information about the birthdays category commands')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('check')\n                .setDescription('Check your birthday')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('delete')\n                .setDescription('Delete your birthday')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('list')\n                .setDescription('Get to see all birthdays')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('set')\n                .setDescription('Set your birthday')\n                .addNumberOption(option => option.setName('day').setDescription('The day number that is your birthday').setRequired(true))\n                .addNumberOption(option => option.setName('month').setDescription('The month number that is your birthday').setRequired(true))\n        )\n    ,\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        client.loadSubcommands(client, interaction, args);\n    },\n};\n\n ","size_bytes":1720},"src/interactions/Command/bot.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst Discord = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('bot')\n        .setDescription('Information about the bot')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('help')\n                .setDescription('Get information about the bot category commands')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('info')\n                .setDescription('Get information about the bot')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('ping')\n                .setDescription('See the bots ping in ms')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('changelogs')\n                .setDescription('Get the changelogs of the bot')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('donate')\n                .setDescription('Get the Bot donate link')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('links')\n                .setDescription('Get a message with all the Bot links')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('owner')\n                .setDescription('Get info about the owner')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('socials')\n                .setDescription('Get the Bot socials')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('support')\n                .setDescription('Get an invite of the support server')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('uptime')\n                .setDescription('Show the bot uptime')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('vote')\n                .setDescription('See if you have voted')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('feedback')\n                .setDescription('Send your opinion about the bot to the developers')\n                .addStringOption(option => option.setName(\"feedback\").setDescription(\"Your feedback\").setRequired(true))\n        ),\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        client.loadSubcommands(client, interaction, args);\n    },\n};\n\n ","size_bytes":2760},"src/interactions/Command/casino.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst Discord = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('casino')\n        .setDescription('Play the casino game')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('help')\n                .setDescription('Get information about the casino category commands')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('blackjack')\n                .setDescription('Play a blackjack game to win money')\n                .addNumberOption(option => option.setName('amount').setDescription('Enter a amount').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('crash')\n                .setDescription('More risk, more reward')\n                .addNumberOption(option => option.setName('amount').setDescription('Enter a amount').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('roulette')\n                .setDescription('Play roulette')\n                .addStringOption(option => option.setName('color').setDescription('Enter a hex color').setRequired(true))\n                .addNumberOption(option => option.setName('amount').setDescription('Enter a amount').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('slots')\n                .setDescription('Play slots')\n                .addNumberOption(option => option.setName('amount').setDescription('Enter a amount').setRequired(true))\n        )\n    ,\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        client.loadSubcommands(client, interaction, args);\n    },\n};\n\n ","size_bytes":2035},"src/interactions/Command/commands.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/music\");\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('custom-commands')\n        .setDescription('Create some custom commands')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('help')\n                .setDescription('Get information about the custom commands category'),\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('add')\n                .setDescription('Create a custom command')\n                .addStringOption(option => option.setName('command').setDescription('The name of the command').setRequired(true))\n                .addStringOption(option => option.setName('text').setDescription('The response of the command').setRequired(true)),\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('delete')\n                .setDescription('Delete a custom command')\n                .addStringOption(option => option.setName('command').setDescription('The name of the command').setRequired(true)),\n        )\n    ,\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        const perms = await client.checkUserPerms({\n            flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n            perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n        }, interaction)\n\n        if (perms == false) return;\n        \n        client.loadSubcommands(client, interaction, args);\n    },\n};\n\n ","size_bytes":1841},"src/interactions/Command/config.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst { ChannelType } = require('discord.js');\nconst Discord = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('config')\n        .setDescription('Adjust the bot to your taste')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('help')\n                .setDescription('Get information about the config category commands')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('levels')\n                .setDescription('Enable/disable levels')\n                .addBooleanOption(option => option.setName('boolean').setDescription('Select a boolean').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('setcolor')\n                .setDescription('Set a custom embed color')\n                .addStringOption(option => option.setName(\"color\").setDescription(\"Enter a hex color\").setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('setverify')\n                .setDescription('Setup the verify panel')\n                .addBooleanOption(option => option.setName('enable').setDescription('Select a boolean').setRequired(true))\n                .addChannelOption(option => option.setName('channel').setDescription('Select a channel').setRequired(true).addChannelTypes(ChannelType.GuildText))\n                .addRoleOption(option => option.setName('role').setDescription('Select a role').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('setchannelname')\n                .setDescription('Set a custom channel name for server stats')\n                .addStringOption(option => option.setName(\"name\").setDescription(\"Enter a name for the channel or send HELP for the args\").setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('levelmessage')\n                .setDescription('Set the bot level message')\n                .addStringOption(option => option.setName(\"message\").setDescription(\"Enter a message for the levels or send HELP for the args\").setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('welcomemessage')\n                .setDescription('Set the welcome message')\n                .addStringOption(option => option.setName(\"message\").setDescription(\"Enter a welcome message or send HELP for the args\").setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('leavemessage')\n                .setDescription('Set the leave message')\n                .addStringOption(option => option.setName(\"message\").setDescription(\"Enter a leave message or send HELP for the args\").setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('ticketmessage')\n                .setDescription('Set the ticket message of the bot')\n                .addStringOption(option =>\n                    option.setName('type')\n                        .setDescription('Ticket message type')\n                        .setRequired(true)\n                        .addChoices(\n                            { name: 'open', value: 'open' },\n                            { name: 'closeDM', value: 'close' }\n                        )\n                )\n                .addStringOption(option => option.setName(\"message\").setDescription(\"Enter a message for the ticket\").setRequired(true))\n        )\n    ,\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        client.loadSubcommands(client, interaction, args);\n    },\n};\n\n ","size_bytes":4034},"src/interactions/Command/developers.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst Discord = require('discord.js');\n\nconst model = require('../../database/models/badge');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('developers')\n        .setDescription('Commands for the Bot developers')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('help')\n                .setDescription('Get information about the developers category commands')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('eval')\n                .setDescription('Get the result of a piece of code')\n                .addStringOption(option => option.setName('code').setDescription('Your code').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('badge')\n                .setDescription('Manage the bot badges')\n                .addBooleanOption(option => option.setName('new').setDescription('Select a boolean').setRequired(true))\n                .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true))\n                .addStringOption(option => option.setName('badge').setDescription('Choose your badge').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('ban')\n                .setDescription('Manage the bot bans')\n                .addBooleanOption(option => option.setName('new').setDescription('Select a boolean').setRequired(true))\n                .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('credits')\n                .setDescription('Manage the bot credits')\n                .addStringOption(option =>\n                    option.setName('type')\n                        .setDescription('The type of credits')\n                        .setRequired(true)\n                        .addChoices(\n                            { name: 'Add', value: 'add' },\n                            { name: 'Remove', value: 'remove' }\n                        )\n                )\n                .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true))\n                .addNumberOption(option => option.setName('amount').setDescription('Amount of credits').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('args')\n                .setDescription('Post preset messages')\n                .addStringOption(option =>\n                    option.setName('message')\n                        .setDescription('Select a message')\n                        .setRequired(true)\n                        .addChoices(\n                            { name: 'Information', value: 'information' },\n                            { name: 'Rules', value: 'rules' },\n                            { name: 'Applications', value: 'applications' },\n                            { name: 'Booster perks', value: 'boosterperks' },\n                            { name: 'Links', value: 'links' },\n                            { name: 'Rewards', value: 'rewards' },\n                            { name: 'Our bots', value: 'ourbots' }\n                        )\n                )\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('servers')\n                .setDescription('See all servers from this shard')\n        )\n    ,\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        model.findOne({ User: interaction.user.id }, async (err, data) => {\n            if (interaction.user.id === process.env.OWNER_ID) {\n                client.loadSubcommands(client, interaction, args);\n            } else {\n                return client.errNormal({\n                    error: 'Only Bot developers are allowed to do this',\n                    type: 'editreply'\n                }, interaction)\n            }\n        })\n    },\n};\n\n ","size_bytes":4268},"src/interactions/Command/economy.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst Discord = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('economy')\n        .setDescription('Play the economy game in your server')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('help')\n                .setDescription('Get information about the economy category commands')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('additem')\n                .setDescription('Add a role item to the economy store')\n                .addRoleOption(option => option.setName('role').setDescription('Select a role').setRequired(true))\n                .addNumberOption(option => option.setName('amount').setDescription('Enter a amount').setRequired(true))\n\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('addmoney')\n                .setDescription('Add money to a user')\n                .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true))\n                .addNumberOption(option => option.setName('amount').setDescription('Enter a amount').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('balance')\n                .setDescription('See your balance')\n                .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(false))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('beg')\n                .setDescription('Beg for money')\n        )\n        .addSubcommand((subcommand) =>\n            subcommand\n                .setName('buy')\n                .setDescription('Buy items in the Bot store')\n\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('clear')\n                .setDescription('Clear the economy')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('crime')\n                .setDescription('Commit a crime')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('daily')\n                .setDescription('Claim your daily money')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('deleteitem')\n                .setDescription('Delete a role item from the economy store')\n                .addRoleOption(option => option.setName('role').setDescription('Select a role').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('deposit')\n                .setDescription('Deposit money to the bank')\n                .addNumberOption(option => option.setName('amount').setDescription('Enter a amount').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('fish')\n                .setDescription('Fish some fish')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('hourly')\n                .setDescription('Claim your hourly money')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('hunt')\n                .setDescription('Hunt some animals')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('monthly')\n                .setDescription('Claim your monthly money')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('pay')\n                .setDescription('Pay a user')\n                .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true))\n                .addNumberOption(option => option.setName('amount').setDescription('Enter a amount').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('present')\n                .setDescription('Get a weekly present')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('removemoney')\n                .setDescription('Remove money from a user')\n                .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true))\n                .addNumberOption(option => option.setName('amount').setDescription('Enter a amount').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('rob')\n                .setDescription('Rob a user')\n                .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('store')\n                .setDescription('Show the store of this guild')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('weekly')\n                .setDescription('Claim your weekly money')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('withdraw')\n                .setDescription('Withdraw your money')\n                .addNumberOption(option => option.setName('amount').setDescription('Enter a amount').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('work')\n                .setDescription('Go to work')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('yearly')\n                .setDescription('Claim your yearly money')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('leaderboard')\n                .setDescription('See the economy leaderboard')\n                .addStringOption(option =>\n                    option.setName('type')\n                        .setDescription('The leaderboard type that you want')\n                        .setRequired(true)\n                        .addChoices(\n                            {name: 'Money', value: 'money'},\n                            {name: 'Bank', value: 'bank'}\n                        )\n                )\n        )\n    ,\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        client.loadSubcommands(client, interaction, args);\n    },\n};\n\n ","size_bytes":6628},"src/interactions/Command/embed.js":{"content":"const { CommandInteraction, Client } = require(\"discord.js\");\nconst { SlashCommandBuilder } = require(\"discord.js\");\nconst { ChannelType } = require(\"discord.js\");\nconst Discord = require(\"discord.js\");\n\nmodule.exports = {\n  data: new SlashCommandBuilder()\n    .setName(\"embed\")\n    .setDescription(\"Generate an embed\")\n    .addChannelOption((option) =>\n      option\n        .setName(\"channel\")\n        .setDescription(\"Channel where the embed should be\")\n        .setRequired(true)\n        .addChannelTypes(ChannelType.GuildText)\n    ),\n  /**\n   * @param {Client} client\n   * @param {CommandInteraction} interaction\n   * @param {String[]} args\n   */\n\n  run: async (client, interaction, args) => {\n    await interaction.deferReply({ fetchReply: true });\n    const perms = await client.checkPerms(\n      {\n        flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n        perms: [Discord.PermissionsBitField.Flags.ManageMessages],\n      },\n      interaction\n    );\n\n    if (perms == false) return;\n\n    let row = new Discord.ActionRowBuilder().addComponents(\n      new Discord.StringSelectMenuBuilder()\n        .setCustomId(\"embedSelect\")\n        .setPlaceholder(\"Nothing selected\")\n        .addOptions([\n          {\n            emoji: \"✏️\",\n            label: \"Title\",\n            description: \"Create a embed title\",\n            value: \"title_embed\",\n          },\n          {\n            emoji: \"💬\",\n            label: \"Description\",\n            description: \"Create a embed description\",\n            value: \"description_embed\",\n          },\n          {\n            emoji: \"🕵️\",\n            label: \"Author\",\n            description: \"Create a embed author\",\n            value: \"author_embed\",\n          },\n          {\n            emoji: \"🔻\",\n            label: \"Footer\",\n            description: \"Create a embed footer\",\n            value: \"footer_embed\",\n          },\n          {\n            emoji: \"🔳\",\n            label: \"Thumbnail\",\n            description: \"Create a embed thumbnail\",\n            value: \"thumbnail_embed\",\n          },\n          {\n            emoji: \"🕙\",\n            label: \"Timestamp\",\n            description: \"Create a embed timestamp\",\n            value: \"timestamp_embed\",\n          },\n          {\n            emoji: \"🖼️\",\n            label: \"Image\",\n            description: \"Create a embed image\",\n            value: \"image_embed\",\n          },\n          {\n            emoji: \"🌐\",\n            label: \"URL\",\n            description: \"Create a embed url\",\n            value: \"url_embed\",\n          },\n          {\n            emoji: \"🔵\",\n            label: \"Color\",\n            description: \"Create a embed color\",\n            value: \"color_embed\",\n          },\n        ])\n    );\n\n    let row2 = new Discord.ActionRowBuilder().addComponents(\n      new Discord.ButtonBuilder()\n        .setCustomId(\"send_embed\")\n        .setEmoji(\"✅\")\n        .setLabel(\"Send embed\")\n        .setStyle(Discord.ButtonStyle.Success)\n    );\n\n    let embed = new Discord.EmbedBuilder().setDescription(\n      `Please select some options`\n    );\n\n    interaction.editReply({ embeds: [embed], components: [row, row2] });\n\n    const filter = (i) => i.user.id === interaction.user.id;\n    const collector = interaction.channel.createMessageComponentCollector({\n      filter,\n    });\n\n    collector.on(\"collect\", async (i) => {\n      if (i.customId === \"embedSelect\") {\n        i.deferUpdate();\n\n        if (i.values == \"title_embed\") {\n          interaction.channel\n            .send({ content: \"Please enter a title\" })\n            .then((message) => {\n              const filterMessage = (m) =>\n                m.author.id === interaction.user.id && !m.author.bot;\n              interaction.channel\n                .awaitMessages({\n                  filterMessage,\n                  max: 1,\n                  time: 300000,\n                  errors: [\"time\"],\n                })\n                .then(async (collected) => {\n                  message.delete({ timeout: 1000 });\n                  collected.delete({ timeout: 1000 });\n\n                  embed.setTitle(`${collected.first().content}`);\n                  await interaction.editReply({ embeds: [embed] });\n                });\n            });\n        }\n\n        if (i.values == \"description_embed\") {\n          interaction.channel\n            .send({ content: \"Please enter a description\" })\n            .then((message) => {\n              const filterMessage = (m) =>\n                m.author.id === interaction.user.id && !m.author.bot;\n              interaction.channel\n                .awaitMessages({\n                  filterMessage,\n                  max: 1,\n                  time: 300000,\n                  errors: [\"time\"],\n                })\n                .then(async (collected) => {\n                  message.delete({ timeout: 1000 });\n                  collected.delete({ timeout: 1000 });\n\n                  embed.setDescription(`${collected.first().content}`);\n                  await interaction.editReply({ embeds: [embed] });\n                });\n            });\n        }\n\n        if (i.values == \"author_embed\") {\n          interaction.channel\n            .send({ content: \"Please enter a author\" })\n            .then((message) => {\n              const filterMessage = (m) =>\n                m.author.id === interaction.user.id && !m.author.bot;\n              interaction.channel\n                .awaitMessages({\n                  filterMessage,\n                  max: 1,\n                  time: 300000,\n                  errors: [\"time\"],\n                })\n                .then(async (collected) => {\n                  message.delete({ timeout: 1000 });\n                  collected.delete({ timeout: 1000 });\n\n                  embed.setAuthor({\n                    name: `${collected.first().content}`,\n                    iconURL: interaction.guild.iconURL({ size: 1024 }),\n                  });\n                  await interaction.editReply({ embeds: [embed] });\n                });\n            });\n        }\n\n        if (i.values == \"footer_embed\") {\n          interaction.channel\n            .send({ content: \"Please enter a footer\" })\n            .then((message) => {\n              const filterMessage = (m) =>\n                m.author.id === interaction.user.id && !m.author.bot;\n              interaction.channel\n                .awaitMessages({\n                  filterMessage,\n                  max: 1,\n                  time: 300000,\n                  errors: [\"time\"],\n                })\n                .then(async (collected) => {\n                  message.delete({ timeout: 1000 });\n                  collected.delete({ timeout: 1000 });\n\n                  embed.setFooter({\n                    text: `${collected.first().content}`,\n                  });\n                  await interaction.editReply({ embeds: [embed] });\n                });\n            });\n        }\n\n        if (i.values == \"thumbnail_embed\") {\n          interaction.channel\n            .send({ content: \"Please enter a thumbnail\" })\n            .then((message) => {\n              const filterMessage = (m) =>\n                m.author.id === interaction.user.id && !m.author.bot;\n              interaction.channel\n                .awaitMessages({\n                  filterMessage,\n                  max: 1,\n                  time: 300000,\n                  errors: [\"time\"],\n                })\n                .then(async (collected) => {\n                  message.delete({ timeout: 1000 });\n                  collected.delete({ timeout: 1000 });\n\n                  if (\n                    !collected.first().content.includes(\"http://\") &&\n                    !collected.first().content.includes(\"https://\")\n                  )\n                    return interaction.channel.send({\n                      content: \"Incorrect thumbnail link!\",\n                    });\n                  embed.setThumbnail(`${collected.first().content}`);\n                  await interaction.editReply({ embeds: [embed] });\n                });\n            });\n        }\n\n        if (i.values == \"thumbnail_embed\") {\n          embed.setTimestamp();\n          interaction.editReply({ embeds: [embed] });\n        }\n\n        if (i.values == \"image_embed\") {\n          interaction.channel\n            .send({ content: \"Please enter a image\" })\n            .then((message) => {\n              const filterMessage = (m) =>\n                m.author.id === interaction.user.id && !m.author.bot;\n              interaction.channel\n                .awaitMessages({\n                  filterMessage,\n                  max: 1,\n                  time: 300000,\n                  errors: [\"time\"],\n                })\n                .then(async (collected) => {\n                  message.delete({ timeout: 1000 });\n                  collected.delete({ timeout: 1000 });\n\n                  if (\n                    !collected.first().content.includes(\"http://\") &&\n                    !collected.first().content.includes(\"https://\")\n                  )\n                    return interaction.channel.send({\n                      content: \"Incorrect image link!\",\n                    });\n                  embed.setImage(`${collected.first().content}`);\n                  await interaction.editReply({ embeds: [embed] });\n                });\n            });\n        }\n\n        if (i.values == \"url_embed\") {\n          interaction.channel\n            .send({ content: \"Please enter a url\" })\n            .then((message) => {\n              const filterMessage = (m) =>\n                m.author.id === interaction.user.id && !m.author.bot;\n              interaction.channel\n                .awaitMessages({\n                  filterMessage,\n                  max: 1,\n                  time: 300000,\n                  errors: [\"time\"],\n                })\n                .then(async (collected) => {\n                  message.delete({ timeout: 1000 });\n                  collected.delete({ timeout: 1000 });\n\n                  if (\n                    !collected.first().content.includes(\"http://\") &&\n                    !collected.first().content.includes(\"https://\")\n                  )\n                    return interaction.channel.send({\n                      content: \"Incorrect url!\",\n                    });\n                  embed.setURL(`${collected.first().content}`);\n                  await interaction.editReply({ embeds: [embed] });\n                });\n            });\n        }\n\n        if (i.values == \"color_embed\") {\n          interaction.channel\n            .send({ content: \"Please enter a color. e.g. #FF0000\" })\n            .then((message) => {\n              const filterMessage = (m) =>\n                m.author.id === interaction.user.id && !m.author.bot;\n              interaction.channel\n                .awaitMessages({\n                  filterMessage,\n                  max: 1,\n                  time: 300000,\n                  errors: [\"time\"],\n                })\n                .then(async (collected) => {\n                  message.delete({ timeout: 1000 });\n                  collected.delete({ timeout: 1000 });\n\n                  embed.setColor(`${collected.first().content}`);\n                  await interaction.editReply({ embeds: [embed] });\n                });\n            });\n        }\n      }\n      if (i.customId == \"send_embed\") {\n        const channel = interaction.options.getChannel(\"channel\");\n        if (!channel)\n          return client.errNormal(\n            { error: `Channel not found` },\n            collected.first().channel\n          );\n\n        channel\n          .createWebhook({\n            name: interaction.guild.name,\n            avatar: interaction.guild.iconURL(),\n          })\n          .then(async (_webhook) => {\n            await _webhook.send({ embeds: [embed] });\n\n            client.succNormal(\n              {\n                text: `Embed successfully sent in ${channel}`,\n                components: [],\n                type: \"editreply\",\n              },\n              interaction\n            );\n            collector.stop();\n\n            setTimeout(() => {\n              _webhook.delete();\n              i.message.delete();\n            }, 5000);\n          });\n      }\n    });\n  },\n};\n\n \n","size_bytes":12230},"src/interactions/Command/family.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/music\");\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('family')\n        .setDescription('Create a family in Bot')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('help')\n                .setDescription('Get information about the family category commands')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('adopt')\n                .setDescription('Adopt a member')\n                .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('delete')\n                .setDescription('Delete your family!'),\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('disown')\n                .setDescription('Disown one of your children or a parent')\n                .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true)),\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('divorce')\n                .setDescription('Divorce your partner')\n                .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true)),\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('family')\n                .setDescription(`See who's in someone's family!`)\n                .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(false)),\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('propose')\n                .setDescription('Marry a member')\n                .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true)),\n        ),\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        client.loadSubcommands(client, interaction, args);\n    },\n};\n\n ","size_bytes":2404},"src/interactions/Command/fun.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst Discord = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('fun')\n        .setDescription('Run fun commands in Bot')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('help')\n                .setDescription('Get information about the fun category commands')\n        )\n\n        // Meme Commands\n\n        .addSubcommandGroup((group) =>\n            group\n                .setName('meme')\n                .setDescription('See all the fun meme commands in Bot')\n                .addSubcommand(subcommand =>\n                    subcommand\n                        .setName('confused')\n                        .setDescription('React with a Confused Nick Young meme')\n                )\n                .addSubcommand(subcommand =>\n                    subcommand\n                        .setName('cleverrate')\n                        .setDescription('See how much clever you are')\n                )\n                .addSubcommand(subcommand =>\n                    subcommand\n                        .setName('dinochrome')\n                        .setDescription('Dinosaur in Chrome')\n                )\n                .addSubcommand(subcommand =>\n                    subcommand\n                        .setName('epicgamerrate')\n                        .setDescription('See how much of an epic gamer you are')\n                )\n                .addSubcommand(subcommand =>\n                    subcommand\n                        .setName('howgay')\n                        .setDescription('See how gay you are')\n                )\n                .addSubcommand(subcommand =>\n                    subcommand\n                        .setName('roast')\n                        .setDescription('Roasts a user')\n                        .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true))\n                )\n                .addSubcommand(subcommand =>\n                    subcommand\n                        .setName('simprate')\n                        .setDescription('See how simp you are')\n                )\n                .addSubcommand(subcommand =>\n                    subcommand\n                        .setName('stankrate')\n                        .setDescription('See how stanky you are')\n                )\n                .addSubcommand(subcommand =>\n                    subcommand\n                        .setName('rickroll')\n                        .setDescription('Get a rickroll')\n                )\n        )\n\n        // User Commands\n\n        .addSubcommandGroup((group) =>\n            group\n                .setName('user')\n                .setDescription('See all the fun user commands in Bot')\n                .addSubcommand(subcommand =>\n                    subcommand\n                        .setName('hack')\n                        .setDescription('Hack your friends or enemies!')\n                        .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true))\n                )\n                .addSubcommand(subcommand =>\n                    subcommand\n                        .setName('hug')\n                        .setDescription('Give a hug to a user')\n                        .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true))\n                )\n                .addSubcommand(subcommand =>\n                    subcommand\n                        .setName('kill')\n                        .setDescription('Kill a user')\n                        .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true))\n                )\n                .addSubcommand(subcommand =>\n                    subcommand\n                        .setName('lovemeter')\n                        .setDescription('See how much you fit in with someone')\n                        .addUserOption(option => option.setName('user1').setDescription('Select a user').setRequired(true))\n                        .addUserOption(option => option.setName('user2').setDescription('Select a user').setRequired(true))\n                )\n                .addSubcommand(subcommand =>\n                    subcommand\n                        .setName('sudo')\n                        .setDescription('Say something like someone else')\n                        .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true))\n                        .addStringOption(option => option.setName('text').setDescription('Enter a text').setRequired(true))\n                )\n        )\n\n        // Text Commands\n\n        .addSubcommandGroup((group) =>\n            group\n                .setName('text')\n                .setDescription('See all the fun text commands in Bot')\n                .addSubcommand(subcommand =>\n                    subcommand\n                        .setName('ascii')\n                        .setDescription('Make ascii text')\n                        .addStringOption(option => option.setName('text').setDescription('Enter a text').setRequired(true))\n                )\n                .addSubcommand(subcommand =>\n                    subcommand\n                        .setName('gif')\n                        .setDescription('Search a gif')\n                        .addStringOption(option => option.setName('text').setDescription('Enter a text').setRequired(true))\n                )\n                .addSubcommand(subcommand =>\n                    subcommand\n                        .setName('reverse')\n                        .setDescription('Reverse your text')\n                        .addStringOption(option => option.setName('text').setDescription('Enter a text').setRequired(true))\n                )\n                .addSubcommand(subcommand =>\n                    subcommand\n                        .setName('say')\n                        .setDescription('Have the bot say something')\n                        .addStringOption(option => option.setName('text').setDescription('Enter a text').setRequired(true))\n                )\n        )\n\n        // Extra Commands\n\n        .addSubcommandGroup((group) =>\n            group\n                .setName('extra')\n                .setDescription('See all the fun extra commands in Bot')\n                .addSubcommand(subcommand =>\n                    subcommand\n                        .setName('birdfact')\n                        .setDescription('Get a random bird fact')\n                )\n                .addSubcommand(subcommand =>\n                    subcommand\n                        .setName('catfact')\n                        .setDescription('Get a random cat fact')\n                )\n                .addSubcommand(subcommand =>\n                    subcommand\n                        .setName('dogfact')\n                        .setDescription('Get a random dog fact')\n                )\n                .addSubcommand(subcommand =>\n                    subcommand\n                        .setName('fact')\n                        .setDescription('Get a random fact')\n                )\n                .addSubcommand(subcommand =>\n                    subcommand\n                        .setName('koalafact')\n                        .setDescription('Get a random koalafact fact')\n                )\n                .addSubcommand(subcommand =>\n                    subcommand\n                        .setName('pandafact')\n                        .setDescription('Get a random pandafact fact')\n                )\n                .addSubcommand(subcommand =>\n                    subcommand\n                        .setName('token')\n                        .setDescription('Get my token')\n                )\n                .addSubcommand(subcommand =>\n                    subcommand\n                        .setName('worldclock')\n                        .setDescription('Shows the world clock(s)')\n                )\n                .addSubcommand(subcommand =>\n                    subcommand\n                        .setName('xmas')\n                        .setDescription('See the number of days until Christmas')\n                )\n        ),\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        client.loadSubcommands(client, interaction, args);\n    },\n};\n\n ","size_bytes":8581},"src/interactions/Command/games.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst Discord = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('games')\n        .setDescription('Play games in Bot')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('help') \n                .setDescription('Get information about the games category commands')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('8ball')\n                .setDescription('Ask the bot a question')\n                .addStringOption(option => option.setName('question').setDescription('The question you want to ask').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('fasttype')\n                .setDescription('Learn to type faster'),\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('music-trivia')\n                .setDescription('Play music trivia')\n                .addNumberOption(option => option.setName('number').setDescription('The amount of songs').setRequired(true)),\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('roll')\n                .setDescription('Roll a die'),\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('rps')\n                .setDescription('Play rock paper scissors against the bot')\n                .addStringOption(option =>\n                    option.setName('option')\n                        .setDescription('Choose what you want')\n                        .setRequired(true)\n                        .addChoices(\n                            { name: '🪨 Rock', value: 'rock' },\n                            { name: '📃 Paper', value: 'paper' },\n                            { name: '✂️ Scissors', value: 'scissors' }\n                        )\n                )\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('skipword')\n                .setDescription('Skip the current word'),\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('snake')\n                .setDescription('Playing the game snake'),\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('trivia')\n                .setDescription('Play Trivia'),\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('willyoupressthebutton')\n                .setDescription('Play Will You Press The Button'),\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('wouldyourather')\n                .setDescription('Play Would You Rather'),\n        ),\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        client.loadSubcommands(client, interaction, args);\n    },\n};\n\n ","size_bytes":3182},"src/interactions/Command/giveaway.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst { ChannelType } = require('discord.js');\nconst Discord = require('discord.js');\nconst ms = require('ms');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('giveaway')\n        .setDescription('Host a giveaway in your server')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('help')\n                .setDescription('Get information about the giveaway category commands')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('start')\n                .setDescription('Start a giveaway')\n                .addChannelOption(option => option.setName('channel').setDescription('Channel where the giveaway should be').setRequired(true).addChannelTypes(ChannelType.GuildText, ChannelType.GuildAnnouncement))\n                .addStringOption(option => option.setName('duration').setDescription('Duration of the giveaway').setRequired(true))\n                .addNumberOption(option => option.setName('winners').setDescription('The number of giveaway winners').setRequired(true))\n                .addStringOption(option => option.setName('prize').setDescription('The giveaway prize').setRequired(true)),\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('drop')\n                .setDescription('Start a drop giveaway')\n                .addChannelOption(option => option.setName('channel').setDescription('Channel where the giveaway should be').setRequired(true).addChannelTypes(ChannelType.GuildText, ChannelType.GuildAnnouncement))\n                .addStringOption(option => option.setName('duration').setDescription('Duration of the giveaway').setRequired(true))\n                .addNumberOption(option => option.setName('winners').setDescription('The number of giveaway winners').setRequired(true))\n                .addStringOption(option => option.setName('prize').setDescription('The giveaway prize').setRequired(true)),\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('reroll')\n                .setDescription('Reroll a giveaway')\n                .addStringOption(option => option.setName('message').setDescription('Giveaway message ID').setRequired(true)),\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('end')\n                .setDescription('End a giveaway')\n                .addStringOption(option => option.setName('message').setDescription('Giveaway message ID').setRequired(true)),\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('edit')\n                .setDescription('Edit the time of a giveaway')\n                .addStringOption(option => option.setName('message').setDescription('Giveaway message ID').setRequired(true)),\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('delete')\n                .setDescription('Delete a giveaway')\n                .addStringOption(option => option.setName('message').setDescription('Giveaway message ID').setRequired(true)),\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('pause')\n                .setDescription('Pause a giveaway')\n                .addStringOption(option => option.setName('message').setDescription('Giveaway message ID').setRequired(true)),\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('unpause')\n                .setDescription('Unpause a giveaway')\n                .addStringOption(option => option.setName('message').setDescription('Giveaway message ID').setRequired(true)),\n        ),\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        const perms = await client.checkUserPerms({\n            flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n            perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n        }, interaction)\n\n        if (perms == false) return;\n\n        client.loadSubcommands(client, interaction, args);\n    },\n};\n\n ","size_bytes":4366},"src/interactions/Command/guild.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst Discord = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('guild')\n        .setDescription('Manage the guild')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('help')\n                .setDescription('Get information about the guild category commands')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('channelinfo')\n                .setDescription('Get information about a channel')\n                .addChannelOption(option => option.setName('channel').setDescription('Select a channel').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('members')\n                .setDescription('See how many members there are in this server')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('oldestmember')\n                .setDescription('Get the oldest account creation date in the guild')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('roleinfo')\n                .setDescription('Get info about a role')\n                .addRoleOption(option => option.setName('role').setDescription('Select a role').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('info')\n                .setDescription('Get all info about the current server')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('stealemoji')\n                .setDescription('Steal an emoji')\n                .addStringOption(option => option.setName('emoji').setDescription('Enter an emoji to steal').setRequired(true))\n                .addRoleOption(option => option.setName('role').setDescription('Select a role').setRequired(false))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('youngestmember')\n                .setDescription('Get the youngest account creation date in the guild')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('userinfo')\n                .setDescription('Get all info about a user')\n                .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('inviteinfo')\n                .setDescription('Get all info about a invite')\n                .addStringOption(option => option.setName('invite').setDescription('Enter a invite code').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('emojis')\n                .setDescription('See the guild emojis')\n        )\n    ,\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        client.loadSubcommands(client, interaction, args);\n    },\n};\n\n ","size_bytes":3264},"src/interactions/Command/help.js":{"content":"\n\nconst { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder, EmbedBuilder, ButtonBuilder, ActionRowBuilder, StringSelectMenuBuilder } = require('discord.js');\nconst Discord = require('discord.js');\nconst moment = require(\"moment\");\nrequire(\"moment-duration-format\");\n\nmodule.exports = {\n  data: new SlashCommandBuilder()\n    .setName('help')\n    .setDescription('Get help with the bot'),\n\n  /** \n   * @param {Client} client\n   * @param {CommandInteraction} interaction\n   * @param {String[]} args\n   */\n\n  run: async (client, interaction, args) => {\n    const toUpperCase = (string) => string.charAt(0).toUpperCase() + string.slice(1);\n    const commad = (name) => {\n      let text = `*To Run Any Command Type*: \\`/${name} {Sub Command Name}\\``\n      let text2 = client.commands.filter(x => x.data.name == name).map((x) => x.data.options.map((c) => '`' + c.name + '` - ' + c.description).join(\"\\n\"));\n      return text2 + `\\n\\n` + text\n    }\n    \n    let em1 = new EmbedBuilder()\n      .setAuthor({ name: `${client.user.username}\\'s Help Menu`, iconURL: client.user.displayAvatarURL({ format: \"png\" }), url: \"https://discord.gg/uoaio\" })\n      .setImage(`https://i.stack.imgur.com/Fzh0w.png`)\n      .setColor(`#5865F2`)\n      .addFields([\n        {\n          name: \"Categories [1-9]\",\n          value: `>>> <:blue_snowflake:1012018251284361326>┆AFK\n          <:mega_phone:1012037897857282098>┆Announcement\n          <:mod_shield:1012017403892346921>┆Auto mod\n          <:settings:1012018247031328868>┆Auto setup\n          <:presentgift:1012018258137862275>┆Birthday\n          <:discord_bot:1012038552521031703>┆Bot\n          <:huge_smile:1012038461357817968>┆Casino\n          <:settings:1012018247031328868>┆Configuration\n          <:blue_stars:1012018254174232596>┆Custom commands`,\n          inline: true\n        },\n        {\n          name: \"Categories [19-27]\",\n          value: `>>> <:to_space:1012038751729491968>┆Leveling\n          <:values:1012038654916579358>┆Messages\n          <:mod_shield:1012017403892346921>┆Moderation\n          <:musicnotes:1012017302755094609>┆Music\n          <:uo_paper:1015550831199789146>┆Notepad\n          <:member:1012017243837702174>┆Profile\n          <:uo_voice_channel:1015566886303440906>┆Radio\n          <:huge_smile:1012038461357817968>┆Reaction roles\n          <:ways:1012018245429121075>┆Search`,\n          inline: true\n        },\n        {\n          name: \"\\u200b\",\n          value: \"\\u200b\",\n          inline: true\n        },\n        {\n          name: \"Categories [10-18]\",\n          value: `>>> <:emoji_50:1015861852321874002>┆Dcredits\n          <:uo_dcoin:1015563002591842314>┆Economy\n          <:blue_stars:1012018254174232596>┆Family\n          <:huge_smile:1012038461357817968>┆Fun\n          <:to_space:1012038751729491968>┆Games\n          <:uo_party:1015552073405841458>┆Giveaway\n          <:discord:1012017257158824027>┆Guild settings\n          <:image:1012017406572499075>┆Images\n          <:add:1012018622912274502>┆Invites`,\n          inline: true\n        }, {\n          name: \"Categories Part [28-36]\",\n          value: `>>> <:plane:1012017388440531015>┆Server stats\n          <:settings:1012018247031328868>┆Setup\n          <:ways:1012018245429121075>┆Soundboard\n          <:hashtag:1012018249854091415>┆Sticky messages\n          <:heart_blue:1012017400314613761>┆Suggestions\n          <:beIl:1012017395910594620>┆Thanks\n          <:blue_ticket:1012017313878388816>┆Tickets\n          <:blue_hammers:1012018248163786763>┆Tools\n          <:uo_voice_channel:1015566886303440906>┆Voice`,\n          inline: true\n        },\n        {\n          name: \"\\u200b\",\n          value: \"\\u200b\",\n          inline: true\n        },\n      ])\n\n\n    let startButton = new ButtonBuilder().setStyle(2).setEmoji(`⏮️`).setCustomId('start'),\n      backButton = new ButtonBuilder().setStyle(2).setEmoji(`⬅️`).setCustomId('back'),\n      forwardButton = new ButtonBuilder().setStyle(2).setEmoji(`➡️`).setCustomId('forward'),\n      endButton = new ButtonBuilder().setStyle(2).setEmoji(`⏭️`).setCustomId('end'),\n      link = new ButtonBuilder().setStyle(5).setLabel(\"S\" + \"u\" + \"b\" + \"sc\" + \"ri\" + \"b\" + \"e\" + \"!\").setEmoji(`🥹`).setURL('https://rebrand.ly/uo-dev')\n\n    const options = [{ label: 'Owerview', value: '0' }]\n    const options2 = []\n    \n    let counter = 0\n    let counter2 = 25\n    require(\"fs\").readdirSync(`${process.cwd()}/src/commands`).slice(0, 24).forEach(dirs => {\n      counter++\n      const opt = {\n        label: toUpperCase(dirs.replace(\"-\", \" \")),\n        value: `${counter}`\n      }\n      options.push(opt)\n    })\n    require(\"fs\").readdirSync(`${process.cwd()}/src/commands`).slice(25, 37).forEach(dirs => {\n      counter2++\n      const opt = {\n        label: toUpperCase(dirs.replace(\"-\", \" \")),\n        value: `${counter2}`\n      }\n      options2.push(opt)\n    })\n    \n    let menu = new StringSelectMenuBuilder().setPlaceholder('Change page').setCustomId('pagMenu').addOptions(options).setMaxValues(1).setMinValues(1),\n      menu2 = new StringSelectMenuBuilder().setPlaceholder('Change page').setCustomId('pagMenu2').addOptions(options2).setMaxValues(1).setMinValues(1)\n\n    const allButtons = [startButton.setDisabled(true), backButton.setDisabled(true), forwardButton.setDisabled(false), endButton.setDisabled(false), link]\n\n    let group1 = new ActionRowBuilder().addComponents(menu)\n    let group2 = new ActionRowBuilder().addComponents(allButtons)\n    let group3 = new ActionRowBuilder().addComponents(menu2)\n\n    const components = [group2, group1, group3]\n    \n    let helpMessage = await interaction.reply({\n      content: `Click on the buttons to change page`,\n      embeds: [em1],\n      components: components,\n    })\n    \n    const collector = helpMessage.createMessageComponentCollector((button) => button.user.id === interaction.user.id, { time: 60e3 });\n\n    var embeds = [em1]\n    \n    require(\"fs\").readdirSync(`${process.cwd()}/src/commands`).forEach(dirs => {embeds.push(new EmbedBuilder().setAuthor({name: toUpperCase(dirs),iconURL: client.user.displayAvatarURL({format:\"png\"}),url:`h`+`tt`+`ps:`+`//`+`d`+`s`+`c`+`.`+`gg`+`/u`+`o`+`a`+`i`+`o`}).setDescription(`${commad(dirs)}`))})\n\n    let currentPage = 0\n\n    collector.on('collect', async (b) => {\n      if (b.user.id !== interaction.user.id)\n        return b.reply({\n          content: `**You Can't Use it\\n**`,\n          ephemeral: true\n        });\n      switch (b.customId) {\n        case 'start':\n          currentPage = 0\n          group2 = new ActionRowBuilder().addComponents([startButton.setDisabled(true), backButton.setDisabled(true), forwardButton.setDisabled(false), endButton.setDisabled(false)])\n          b.update({ embeds: [embeds[currentPage]], components: components })\n          break;\n        case 'back':\n          --currentPage;\n          if (currentPage === 0) { group2 = new ActionRowBuilder().addComponents([startButton.setDisabled(true), backButton.setDisabled(true), forwardButton.setDisabled(false), endButton.setDisabled(false)]) } else { group2 = new ActionRowBuilder().addComponents([startButton.setDisabled(false), backButton.setDisabled(false), forwardButton.setDisabled(false), endButton.setDisabled(false)]) }\n          b.update({ embeds: [embeds[currentPage]], components: components })\n          break;\n        case 'forward':\n          currentPage++;\n          if (currentPage === embeds.length - 1) { group2 = new ActionRowBuilder().addComponents([startButton.setDisabled(false), backButton.setDisabled(false), forwardButton.setDisabled(true), endButton.setDisabled(true)]) } else { group2 = new ActionRowBuilder().addComponents([startButton.setDisabled(false), backButton.setDisabled(false), forwardButton.setDisabled(false), endButton.setDisabled(false)]) }\n          b.update({ embeds: [embeds[currentPage]], components: components })\n          break;\n        case 'end':\n          currentPage = embeds.length - 1;\n          group2 = new ActionRowBuilder().addComponents([startButton.setDisabled(false), backButton.setDisabled(false), forwardButton.setDisabled(true), endButton.setDisabled(true)])\n          b.update({ embeds: [embeds[currentPage]], components: components })\n          break;\n        case 'pagMenu':\n          currentPage = parseInt(b.values[0])\n          if (currentPage === 0) { group2 = new ActionRowBuilder().addComponents([startButton.setDisabled(true), backButton.setDisabled(true), forwardButton.setDisabled(false), endButton.setDisabled(false)]) } else if (currentPage === embeds.length - 1) { group2 = new ActionRowBuilder().addComponents([startButton.setDisabled(false), backButton.setDisabled(false), forwardButton.setDisabled(true), endButton.setDisabled(true)]) } else { group2 = new ActionRowBuilder().addComponents([startButton.setDisabled(false), backButton.setDisabled(false), forwardButton.setDisabled(false), endButton.setDisabled(false)]) }\n          b.update({ embeds: [embeds[currentPage]], components: components })\n          break;\n        case 'pagMenu2':\n          currentPage = parseInt(b.values[0])\n          if (currentPage === 0) { group2 = new ActionRowBuilder().addComponents([startButton.setDisabled(true), backButton.setDisabled(true), forwardButton.setDisabled(false), endButton.setDisabled(false)]) } else if (currentPage === embeds.length - 1) { group2 = new ActionRowBuilder().addComponents([startButton.setDisabled(false), backButton.setDisabled(false), forwardButton.setDisabled(true), endButton.setDisabled(true)]) } else { group2 = new ActionRowBuilder().addComponents([startButton.setDisabled(false), backButton.setDisabled(false), forwardButton.setDisabled(false), endButton.setDisabled(false)]) }\n          b.update({ embeds: [embeds[currentPage]], components: components })\n          break;\n        default:\n          currentPage = 0\n          b.update({ embeds: [embeds[currentPage]], components: null })\n          break;\n      }\n    });\n\n    collector.on('end', b => {\n      b.update({ embeds: [helpMessage.embeds[0]], content: [], components: [] })\n    });\n\n    collector.on('error', (e) => console.log(e));\n\n    embeds.map((embed, index) => {\n      embed.setColor(\"#5865F2\").setImage(`https://i.stack.imgur.com/Fzh0w.png`)\n        .setFooter({ text: `Page ${index + 1} / ${embeds.length}`, iconURL: client.user.displayAvatarURL() });\n    })\n\n  },\n};","size_bytes":10415},"src/interactions/Command/images.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst { ChannelType } = require('discord.js');\n\nmodule.exports = {\n\n    // Meme Images\n\n    data: new SlashCommandBuilder()\n        .setName('images')\n        .setDescription('See all the images in Bot')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('help')\n                .setDescription('Get information about the message category commands')\n        )\n        .addSubcommandGroup((group) =>\n            group\n                .setName('memes')\n                .setDescription('See all the memes in Bot')\n                .addSubcommand((subcommand) =>\n                    subcommand.setName('clyde').setDescription('Get a custom clyde message')\n                        .addStringOption(option => option.setName('text').setDescription('Enter a text').setRequired(true))\n\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand.setName('drake').setDescription('Create a drake meme')\n                        .addStringOption(option => option.setName('text1').setDescription('Enter a text').setRequired(true))\n                        .addStringOption(option => option.setName('text2').setDescription('Enter a text').setRequired(true)),\n\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand.setName('meme').setDescription('Get a random meme'),\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand.setName('pooh').setDescription('Create a pooh meme')\n                        .addStringOption(option => option.setName('text1').setDescription('Enter a text').setRequired(true))\n                        .addStringOption(option => option.setName('text2').setDescription('Enter a text').setRequired(true)),\n\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand.setName('trumptweet').setDescription('Display\\'s a custom tweet from Donald Trump with the message provided')\n                        .addStringOption(option => option.setName('text').setDescription('Enter a text').setRequired(true))\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand.setName('tweet').setDescription('Tweet something on twitter')\n                        .addStringOption(option => option.setName('text').setDescription('Enter a text').setRequired(true))\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand.setName('wasted').setDescription('GTA wasted overlay'),\n                )\n\n        )\n\n        // Animal Images\n\n        .addSubcommandGroup((group) =>\n            group\n                .setName('animals')\n                .setDescription('See all the animal images in Bot')\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('bird')\n                        .setDescription('Get a random bird'),\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('cat')\n                        .setDescription(\"Get a random cat\")\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('dog')\n                        .setDescription(\"Get a random dog\")\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('fox')\n                        .setDescription(\"Get a random fox\")\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('koala')\n                        .setDescription(\"Get a random koala\")\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('panda')\n                        .setDescription(\"Get a random panda\")\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('redpanda')\n                        .setDescription(\"Get a random redpanda\")\n                )\n        )\n\n        // User Images\n\n        .addSubcommandGroup((group) =>\n            group\n                .setName('user')\n                .setDescription('See all the user images in Bot')\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('ad')\n                        .setDescription('Generate a ad image')\n                        .addUserOption((option) =>\n                            option.setName('user').setDescription('The user you want the ad from').setRequired(true),\n                        )\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('avatar')\n                        .setDescription('See a users avatar')\n                        .addUserOption((option) =>\n                            option.setName('user').setDescription('The user you want the avatar from').setRequired(true),\n                        )\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('banner')\n                        .setDescription('See a users banner')\n                        .addUserOption((option) =>\n                            option.setName('user').setDescription('The user you want the banner from').setRequired(true),\n                        )\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('bed')\n                        .setDescription('Creates an bed meme')\n                        .addUserOption((option) =>\n                            option.setName('user').setDescription('The user you want to sleep with').setRequired(true),\n                        )\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('blur')\n                        .setDescription('Gives an blurred image')\n                        .addUserOption((option) =>\n                            option.setName('user').setDescription('The user you want the blurred image from').setRequired(true),\n                        )\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('burn')\n                        .setDescription('Gives an burned image')\n                        .addUserOption((option) =>\n                            option.setName('user').setDescription('The user you want the burned image from').setRequired(true),\n                        )\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('clown')\n                        .setDescription('Generate a clown image')\n                        .addUserOption((option) =>\n                            option.setName('user').setDescription('The user you want make a clown').setRequired(true),\n                        )\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('colorify')\n                        .setDescription('Generate a colorify image')\n                        .addUserOption((option) =>\n                            option.setName('user').setDescription('The user you want the colorified image from').setRequired(true),\n                        )\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('darkness')\n                        .setDescription('Gives an darkness image')\n                        .addUserOption((option) =>\n                            option.setName('user').setDescription('The user you want the darkness image from').setRequired(true),\n                        )\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('facepalm')\n                        .setDescription('Generate an facepalm image')\n                        .addUserOption((option) =>\n                            option.setName('user').setDescription('The user you want the facepalm image from').setRequired(true),\n                        )\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('greyscale')\n                        .setDescription('Make an image more grey')\n                        .addUserOption((option) =>\n                            option.setName('user').setDescription('The user you want to make more gray').setRequired(true),\n                        )\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('invert')\n                        .setDescription('Invert a image')\n                        .addUserOption((option) =>\n                            option.setName('user').setDescription('The user you want the inverted image from').setRequired(true),\n                        )\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('kiss')\n                        .setDescription('Kiss a user')\n                        .addUserOption((option) =>\n                            option.setName('user').setDescription('The user you want to kiss').setRequired(true),\n                        )\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('podium')\n                        .setDescription('Make a user podium')\n                        .addUserOption((option) =>\n                            option.setName('user1').setDescription('The first podium user').setRequired(true),\n                        )\n                        .addUserOption((option) =>\n                            option.setName('user2').setDescription('The second podium user').setRequired(true),\n                        )\n                        .addUserOption((option) =>\n                            option.setName('user3').setDescription('The third podium user').setRequired(true),\n                        )\n\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('spank')\n                        .setDescription('Spank a user')\n                        .addUserOption((option) =>\n                            option.setName('user').setDescription('The user you want to spank').setRequired(true),\n                        )\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('wanted')\n                        .setDescription('Wanted a user')\n                        .addUserOption((option) =>\n                            option.setName('user').setDescription('The user you want to wanted').setRequired(true),\n                        )\n                )\n        )\n\n        // Extra Images\n\n        .addSubcommandGroup((group) =>\n            group\n                .setName('extra')\n                .setDescription('See all the extra images in Bot')\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('car')\n                        .setDescription('Get a random car'),\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('glass')\n                        .setDescription('Overlays a glass texture over an image'),\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand.setName('image').setDescription('Show a image in an embed')\n                        .addChannelOption(option => option.setName('channel').setDescription('Channel where the embed should be').setRequired(true).addChannelTypes(ChannelType.GuildText))\n                        .addStringOption(option => option.setName('image-url').setDescription('Enter a image url').setRequired(true))\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('triggered')\n                        .setDescription('Trigger yourself'),\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand.setName('wallpaper').setDescription('Returns a wallpaper from HDQWalls')\n                        .addStringOption(option => option.setName('name').setDescription('Enter a name').setRequired(true))\n                )\n        ),\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        client.loadSubcommands(client, interaction, args);\n    },\n};\n\n\n ","size_bytes":13144},"src/interactions/Command/invite.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst Discord = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('invite')\n        .setDescription('Get an invite to the bot'),\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        let row = new Discord.ActionRowBuilder()\n            .addComponents(\n                new Discord.ButtonBuilder()\n                    .setLabel(\"Invite\")\n                    .setURL(client.config.discord.botInvite)\n                    .setStyle(Discord.ButtonStyle.Link),\n\n                new Discord.ButtonBuilder()\n                    .setLabel(\"Support server\")\n                    .setURL(client.config.discord.serverInvite)\n                    .setStyle(Discord.ButtonStyle.Link),\n            );\n\n        client.embed({\n            title: `📨・Invite`,\n            desc: `Make your server even better with Bot!`,\n            image: \"https://cdn.discordapp.com/attachments/843487478881976381/874694194474668052/Bot_banner_invite.jpg\",\n            url: client.config.discord.botInvite,\n            components: [row],\n            type: 'editreply'\n        }, interaction)\n    },\n};\n\n ","size_bytes":1422},"src/interactions/Command/invites.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst Discord = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('invites')\n        .setDescription('View the invites system')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('help')\n                .setDescription('Get information about the invites category commands')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('add')\n                .setDescription('Add invites to a user')\n                .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true))\n                .addNumberOption(option => option.setName('amount').setDescription('Enter a amount of invites').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('remove')\n                .setDescription('Remove invites from a user')\n                .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true))\n                .addNumberOption(option => option.setName('amount').setDescription('Enter a amount of invites').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('show')\n                .setDescription('See your invites')\n                .addUserOption(option => option.setName('user').setDescription('Select a user'))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('leaderboard')\n                .setDescription('See the invites leaderboard')\n        )\n    ,\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        client.loadSubcommands(client, interaction, args);\n    },\n};\n\n ","size_bytes":2035},"src/interactions/Command/levels.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst Discord = require('discord.js');\nconst Schema = require(\"../../database/models/functions\");\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('levels')\n        .setDescription('View the level system')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('help')\n                .setDescription('Get information about the levels category commands')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('setlevel')\n                .setDescription('Set a new level for a user')\n                .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true))\n                .addNumberOption(option => option.setName('level').setDescription('Enter a new level').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('deletereward')\n                .setDescription('Delete a level reward')\n                .addNumberOption(option => option.setName('level').setDescription('Enter a level').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('createreward')\n                .setDescription('Create a level reward')\n                .addNumberOption(option => option.setName('level').setDescription('Enter a level').setRequired(true))\n                .addRoleOption(option => option.setName('role').setDescription('The role for this reward').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('setxp')\n                .setDescription('Set a new xp for a user')\n                .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true))\n                .addNumberOption(option => option.setName('amount').setDescription('Enter a amount of xp').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('rank')\n                .setDescription('See your current rank')\n                .addUserOption(option => option.setName('user').setDescription('Select a user'))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('rewards')\n                .setDescription('Show all level rewards')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('leaderboard')\n                .setDescription('See the level leaderboard')\n        )\n    ,\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        const guild = await Schema.findOne({ Guild: interaction.guild.id });\n        if (!guild.Levels) return client.errNormal({\n            error: `The level system is disabled!`,\n            type: 'ephemeral'\n        }, interaction);\n\n        await interaction.deferReply({ fetchReply: true });\n        client.loadSubcommands(client, interaction, args);\n    },\n};\n\n ","size_bytes":3185},"src/interactions/Command/message.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst Discord = require('discord.js');\nconst model = require('../../database/models/badge');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('message')\n        .setDescription('Post preset messages')\n        .addStringOption(option =>\n            option.setName('message')\n                .setDescription('Select a message')\n                .setRequired(true)\n                .addChoices(\n                    { name: 'Information', value: 'information' },\n                    { name: 'Rules', value: 'rules' },\n                    { name: 'Applications', value: 'applications' },\n                    { name: 'Helpdesk', value: 'helpdesk' },\n                    { name: 'Network', value: 'network' },\n                    { name: 'Bot-Info', value: 'botinfo' },\n                    { name: 'Bot-Badges', value: 'badges' },\n                    { name: 'Bot-Béta', value: 'beta' },\n                    { name: 'Bot-Credits', value: 'credits' }\n                )\n        )\n    ,\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        model.findOne({ User: interaction.user.id }, async (err, data) => {\n            if (data && data.FLAGS.includes(\"DEVELOPER\")) {\n\n                const message = interaction.options.getString('message');\n\n                client.succNormal({\n                    text: `Message has been sent successfully!`,\n                    type: 'ephemeraledit'\n                }, interaction);\n\n                if (message == \"information\") {\n                    client.simpleEmbed({\n                        image: `https://media.discordapp.net/attachments/937337957419999272/937338297036967946/techpoint_channel_banner_about.jpg?width=812&height=221`\n                    }, interaction.channel).then(() => {\n                        client.embed({\n                            title: `ℹ️・Information`,\n                            author: {\n                                name: \"TechPoint\",\n                                iconURL: \"https://media.discordapp.net/attachments/937337957419999272/937797574440681472/techpoint_logo-min.jpg?width=812&height=812\"\n                            },\n                            thumbnail: \"https://media.discordapp.net/attachments/937337957419999272/937463192265846784/techpoint_logo_Bot.jpg?width=812&height=812\",\n                            fields: [\n                                {\n                                    name: `👋┆Welcome to Bot Support!`,\n                                    value: `Welcome to your support server! We focus on our bots Bot & Bot 2. Stay up to date, ask your questions and test out our bots.`,\n                                },\n                                {\n                                    name: `❓┆What can I do here?`,\n                                    value: `- Read the latest bot news\\n- Test bot commands\\n- Ask questions\\n- Get help with setting up the bot in your server`,\n                                },\n                                {\n                                    name: `🤖┆What are Bot & Bot 2?`,\n                                    value: `You can find this information in the <#897221483460444170> channel.`,\n                                },\n                                {\n                                    name: `🔗┆Other servers from us`,\n                                    value: `[Tech server](https://discord.gg/bEJhVa6Ttv) - Get help with code, tech and crypto while you read the latest news\\n[Ban Appeal](https://discord.gg/htf9pHNRxA) - Got banned? Request an unban`,\n                                },\n                            ],\n                            footer: {\n                                text: `© TechPoint - 2022`,\n                                iconURL: \"https://media.discordapp.net/attachments/937337957419999272/937797574440681472/techpoint_logo-min.jpg?width=812&height=812\"\n                            }\n                        }, interaction.channel)\n                    })\n                }\n\n                if (message == \"rules\") {\n                    client.simpleEmbed({\n                        image: `https://media.discordapp.net/attachments/937337957419999272/937338297968123904/techpoint_channel_banner_rules.jpg?width=812&height=221`\n                    }, interaction.channel).then(() => {\n                        client.embed({\n                            title: `📃・Rules`,\n                            author: {\n                                name: \"TechPoint\",\n                                iconURL: \"https://media.discordapp.net/attachments/937337957419999272/937797574440681472/techpoint_logo-min.jpg?width=812&height=812\"\n                            },\n                            thumbnail: \"https://media.discordapp.net/attachments/937337957419999272/937463192265846784/techpoint_logo_Bot.jpg?width=812&height=812\",\n                            desc: `These are our server rules. Please stick to this to keep it fun for everyone. The Admins and Mods will Timeout/Kick/Ban per discretion`,\n                            fields: [\n                                {\n                                    name: `1. Be respectful`,\n                                    value: `You must respect all users, regardless of your liking towards them. Treat others the way you want to be treated.`,\n                                },\n                                {\n                                    name: `2. No Inappropriate Language`,\n                                    value: `The use of profanity should be kept to a minimum. However, any derogatory language towards any user is prohibited.`,\n                                },\n                                {\n                                    name: `3. No spamming`,\n                                    value: `Don't send a lot of small messages right after each other. Do not disrupt chat by spamming.`,\n                                }, {\n                                    name: `4. No pornographic/adult/other NSFW material`,\n                                    value: `This is a community server and not meant to share this kind of material.`,\n                                },\n                                {\n                                    name: `5. No advertisements`,\n                                    value: `We do not tolerate any kind of advertisements, whether it be for other communities or streams. You can post your content in the media channel if it is relevant and provides actual value (Video/Art)`,\n                                },\n                                {\n                                    name: `6. No offensive names and profile pictures`,\n                                    value: `You will be asked to change your name or picture if the staff deems them inappropriate.`,\n                                },\n                                {\n                                    name: `7. Server Raiding`,\n                                    value: `Raiding or mentions of raiding are not allowed.`,\n                                },\n                                {\n                                    name: `8. Direct & Indirect Threats`,\n                                    value: `Threats to other users of DDoS, Death, DoX, abuse, and other malicious threats are absolutely prohibited and disallowed.`,\n                                },\n                                {\n                                    name: `9. Follow the Discord Community Guidelines`,\n                                    value: `You can find them here: https://discordapp.com/guidelines`,\n                                },\n                                {\n                                    name: `10. Do not join voice chat channels without permissions of the people already in there`,\n                                    value: `If you see that they have a free spot it is alright to join and ask whether they have an open spot, but leave if your presence is not wanted by whoever was there first`,\n                                }\n                            ],\n                            footer: {\n                                text: `© TechPoint - 2022`,\n                                iconURL: \"https://media.discordapp.net/attachments/937337957419999272/937797574440681472/techpoint_logo-min.jpg?width=812&height=812\"\n                            }\n                        }, interaction.channel)\n                    })\n                }\n\n                if (message == \"applications\") {\n                    client.simpleEmbed({\n                        image: `https://media.discordapp.net/attachments/937337957419999272/938725909068918854/techpoint_channel_banner_applications.jpg?width=812&height=221`\n                    }, interaction.channel).then(() => {\n                        client.embed({\n                            title: `💼・Applications`,\n                            author: {\n                                name: \"TechPoint\",\n                                iconURL: \"https://media.discordapp.net/attachments/937337957419999272/937797574440681472/techpoint_logo-min.jpg?width=812&height=812\"\n                            },\n                            thumbnail: \"https://media.discordapp.net/attachments/937337957419999272/937463192265846784/techpoint_logo_Bot.jpg?width=812&height=812\",\n                            desc: `What could be more fun than working at the best bot/server? We regularly have spots for new positions that you can apply for \\n\\nBut... what can you expect?`,\n                            fields: [\n                                {\n                                    name: `👥┆A very nice team`,\n                                    value: `In the Techpoint Network team there is always a pleasant atmosphere and everyone is treated equally!`,\n                                },\n                                {\n                                    name: `🥳┆Access to the beta program`,\n                                    value: `Get access to unreleased Bot features with your own server! You are a real Bot tester!`,\n                                },\n                                {\n                                    name: `📛┆A nice rank and badge`,\n                                    value: `You will get a nice rank in the server and a team badge in our userinfo command. Everyone can see that you contribute to the team`,\n                                },\n                                {\n                                    name: `📖┆Learn and grow`,\n                                    value: `We understand that you don't always understand everything right away! At Bot, we give you the opportunity to learn new things and get better at the position. You can also grow into the management team in the future!`,\n                                },\n                                {\n                                    name: `📘┆What does everything mean?`,\n                                    value: `**Moderator/Support** \\nYou keep yourself busy with the server that everything is and remains fun for everyone! Chat with us and keep the overview and help people with their questions.\\n\\n**Marketing** \\nWe also want to grow and we do that with a great marketing team! You know better than anyone how to make a server grow well`,\n                                },\n                                {\n                                    name: `📃┆Apply?`,\n                                    value: `Create a ticket to receive your application!`,\n                                }\n                            ],\n                            footer: {\n                                text: `© TechPoint - 2022`,\n                                iconURL: \"https://media.discordapp.net/attachments/937337957419999272/937797574440681472/techpoint_logo-min.jpg?width=812&height=812\"\n                            }\n                        }, interaction.channel)\n                    })\n                }\n\n                if (message == \"helpdesk\") {\n                    client.simpleEmbed({\n                        image: `https://media.discordapp.net/attachments/937337957419999272/938725908687233034/techpoint_channel_banner_helpdesk.jpg?width=812&height=221`\n                    }, interaction.channel).then(() => {\n                        client.embed({\n                            title: `🎫・Helpdesk`,\n                            author: {\n                                name: \"TechPoint\",\n                                iconURL: \"https://media.discordapp.net/attachments/937337957419999272/937797574440681472/techpoint_logo-min.jpg?width=812&height=812\"\n                            },\n                            thumbnail: \"https://media.discordapp.net/attachments/937337957419999272/937463192265846784/techpoint_logo_Bot.jpg?width=812&height=812\",\n                            desc: `What could be more fun than working at the best bot/server? We regularly have spots for new positions that you can apply for \\n\\nBut... what can you expect?`,\n                            fields: [\n                                {\n                                    name: `❓┆I have a question!`,\n                                    value: `We advise you to ask your question in <#937486956697370674> first. Here there are often already team members or other people who can help you. If it still doesn't work, create a ticket.`,\n                                },\n                                {\n                                    name: `📄┆Ticket Rules`,\n                                    value: `**1.** Be patient so don't tag unnecessarily \\n**2.** Only open a maximum of 1 ticket at a time \\n**3.** No inappropriate behavior in tickets \\n**4.** Don't make a ticket for nonsense`,\n                                },\n                                {\n                                    name: `⏰┆Response time`,\n                                    value: `**08:00 - 16:00** - (+/- 1 hour) \\n**16:00 - 22:00** - (+/- 30 minutes) \\n**22:00 - 08:00** - (+/- 1+ hour)`,\n                                },\n                            ],\n                            footer: {\n                                text: `© TechPoint - 2022`,\n                                iconURL: \"https://media.discordapp.net/attachments/937337957419999272/937797574440681472/techpoint_logo-min.jpg?width=812&height=812\"\n                            }\n                        }, interaction.channel)\n                    })\n\n                }\n\n                if (message == \"network\") {\n                    client.simpleEmbed({\n                        image: `https://media.discordapp.net/attachments/937337957419999272/938725909387698216/techpoint_channel_banner_network.jpg?width=812&height=221`\n                    }, interaction.channel).then(() => {\n                        client.embed({\n                            title: `🏢・Network`,\n                            thumbnail: \"https://media.discordapp.net/attachments/937337957419999272/937463192265846784/techpoint_logo_Bot.jpg?width=812&height=812\",\n                            author: {\n                                name: \"TechPoint\",\n                                iconURL: \"https://media.discordapp.net/attachments/937337957419999272/937797574440681472/techpoint_logo-min.jpg?width=812&height=812\"\n                            },\n                            desc: `Techpoint Network is a network that consists of 3 servers. Each server has its own function. One is for tech/coding/crypto and the other for support. We also have 1 extra server for ban appeals, read all information below`,\n                            fields: [\n                                {\n                                    name: `💻┇TechPoint`,\n                                    value: `This is a server that mainly focused on everything that revolves around tech. For example, think of encryption, crypt or all new gadgets. Meet new people or learn more about tech yourself!. You can join this server by clicking [this](https://discord.gg/bEJhVa6Ttv) link`,\n                                },\n                                {\n                                    name: `🤖┇Bot Support`,\n                                    value: `This is the server you are currently on. All information about this server can be found in. You can get the link from this server to click on [this](https://discord.gg/GqhD6RNbzs) link`,\n                                },\n                                {\n                                    name: `🔨┇TechPoint Ban Appeal`,\n                                    value: `This server is for the people who are banned from a server or from the bots. You can create a ticket here to request an unban and to participate in the servers again or to be able to use the bots again. You can join this server by clicking [this](https://discord.gg/q9jZrDk9n6) link`,\n                                },\n                            ],\n                            footer: {\n                                text: `© TechPoint - 2022`,\n                                iconURL: \"https://media.discordapp.net/attachments/937337957419999272/937797574440681472/techpoint_logo-min.jpg?width=812&height=812\"\n                            }\n                        }, interaction.channel)\n                    })\n\n                }\n\n                if (message == \"botinfo\") {\n                    client.simpleEmbed({\n                        image: `https://media.discordapp.net/attachments/937337957419999272/938725909668691978/techpoint_channel_banner_Bot.jpg?width=812&height=221`\n                    }, interaction.channel).then(() => {\n                        client.embed({\n                            title: `ℹ・Bot(s) Information`,\n                            author: {\n                                name: \"TechPoint\",\n                                iconURL: \"https://media.discordapp.net/attachments/937337957419999272/937797574440681472/techpoint_logo-min.jpg?width=812&height=812\"\n                            },\n                            thumbnail: \"https://media.discordapp.net/attachments/937337957419999272/937463192265846784/techpoint_logo_Bot.jpg?width=812&height=812\",\n                            desc: `Outside of a community we also maintain 2 public bots. These bots are all made to make your server better!`,\n                            fields: [\n                                {\n                                    name: `🤖┆What is Bot?`,\n                                    value: `Bot is a bot with which you can run your entire server! With no less than 400+ commands, we have a large bot with many options to improve your server and the best part is that it is completely in slash commands! You know what else is beautiful? All of this is **FREE** to use!`,\n                                },\n                                {\n                                    name: `🎶┆What is Bot 2?`,\n                                    value: `Bot 2 was created for additional music. This way you never get in each other's way when someone is already listening to music. Furthermore, this bot contains a soundboard and a radio system and the best part is that it is completely in slash commands!`,\n                                },\n                                {\n                                    name: `📨┆How do I invite the bots?`,\n                                    value: `You can invite the bots by doing \\`/invite\\` or by clicking on the links below\\n\\n**Bot Invite** - [Invite Here](https://discord.com/oauth2/authorize?&client_id=798144456528363550&scope=applications.commands+bot&permissions=8)\\n**Bot 2 Invite** - [Invite Here](${client.config.discord.botInvite})`,\n                                },\n                                {\n                                    name: `🎫┆How do I get help when needed?`,\n                                    value: `You can ask your questions in the general chat or for further information you can take a look in <#897213893624102965>.`,\n                                },\n                            ],\n                            footer: {\n                                text: `© TechPoint - 2022`,\n                                iconURL: \"https://media.discordapp.net/attachments/937337957419999272/937797574440681472/techpoint_logo-min.jpg?width=812&height=812\"\n                            }\n                        }, interaction.channel)\n                    })\n\n                }\n\n                if (message == \"badges\") {\n                    client.simpleEmbed({\n                        image: `https://media.discordapp.net/attachments/937337957419999272/938725908028751882/techpoint_channel_banner_soon.jpg?width=813&height=221`\n                    }, interaction.channel)\n                    // .then(() => {\n                    //     client.embed({\n                    //         title: `🥇・Badges`,\n                    //         thumbnail: \"https://media.discordapp.net/attachments/937337957419999272/938725906728513576/techpoint_channel_banner_badges.jpg?width=813&height=221\",\n                    //         desc: `We at Bot have a special badge system! You can find your badge via the userinfo command. Read below what each badge means`,\n                    //         fields: [\n                    //             {\n                    //                 name: `${client.emotes.badges.bot}┆Bot badge`,\n                    //                 value: `This badge is only available for the Bot(s). This way you can see even better that they belong together.`,\n                    //             },\n                    //             {\n                    //                 name: `${client.emotes.badges.developer}┆Developer badge`,\n                    //                 value: `This badge is only available to Bot developers. This shows that they are official developers of the bots.`,\n                    //             },\n                    //             {\n                    //                 name: `${client.emotes.badges.management}┆Management badge`,\n                    //                 value: `You can get this badge if you are an official management member of team Bot.`,\n                    //             },\n                    //             {\n                    //                 name: `${client.emotes.badges.team}┆Team badge`,\n                    //                 value: `You can get this badge if you are an official team member of team Bot.`,\n                    //             },\n                    //             {\n                    //                 name: `${client.emotes.badges.support}┆Support badge`,\n                    //                 value: `You can get this badge if you are an official support member of team Bot.`,\n                    //             },\n                    //             {\n                    //                 name: `${client.emotes.badges.moderator}┆Moderator badge`,\n                    //                 value: `You can get this badge if you are an official moderator of team Bot.`,\n                    //             },\n                    //             {\n                    //                 name: `${client.emotes.badges.marketing}┆Marketing badge`,\n                    //                 value: `You can get this badge if you are an official marketing member of team Bot.`,\n                    //             },\n                    //             {\n                    //                 name: `${client.emotes.badges.event}┆Organization badge`,\n                    //                 value: `You can get this badge if you are an official organization member of team Bot.`,\n                    //             },\n                    //             {\n                    //                 name: `${client.emotes.badges.designer}┆Designer badge`,\n                    //                 value: `You can get this badge if you are an official designer of team Bot.`,\n                    //             },\n                    //             {\n                    //                 name: `${client.emotes.badges.booster}┆Booster badge`,\n                    //                 value: `You can get this badge if you have boosted a server within our network.`,\n                    //             },\n                    //             {\n                    //                 name: `${client.emotes.badges.partner}┆Partner badge`,\n                    //                 value: `You can get this badge if you are official partnerd with our server.`,\n                    //             },\n                    //             {\n                    //                 name: `${client.emotes.badges.bug}┆Bug Hunter badge`,\n                    //                 value: `You can get this badge if you have reported more than 5 bugs in our bot.`,\n                    //             },\n                    //             {\n                    //                 name: `${client.emotes.badges.supporter}┆Supporter badge`,\n                    //                 value: `You can get this badge if you have given something to Bot to improve the bot even more.`,\n                    //             },\n                    //             {\n                    //                 name: `${client.emotes.badges.voter}┆Voter badge`,\n                    //                 value: `You can get this badge if you have voted for our bots or servers.`,\n                    //             },\n                    //             {\n                    //                 name: `${client.emotes.badges.vip}┆Vip badge`,\n                    //                 value: `You can get this badge if you have bought the vip role in the economy system.`,\n                    //             },\n                    //             {\n                    //                 name: `${client.emotes.badges.active}┆Active badge`,\n                    //                 value: `You can get this badge if you have bought the active role in the economy system.`,\n                    //             }\n                    //         ],\n                    //         footer: {\n                    //             text: `© TechPoint - 2022`,\n                    //             iconURL: \"https://media.discordapp.net/attachments/937337957419999272/937797574440681472/techpoint_logo-min.jpg?width=812&height=812\"\n                    //         }\n                    //     }, interaction.channel)\n                    // })\n\n                }\n\n                if (message == \"beta\") {\n                    client.simpleEmbed({\n                        image: `https://media.discordapp.net/attachments/937337957419999272/938725907097604116/techpoint_channel_banner_beta.jpg?width=813&height=221`\n                    }, interaction.channel).then(() => {\n                        client.embed({\n                            title: `🐞・Béta`,\n                            author: {\n                                name: \"TechPoint\",\n                                iconURL: \"https://media.discordapp.net/attachments/937337957419999272/937797574440681472/techpoint_logo-min.jpg?width=812&height=812\"\n                            },\n                            thumbnail: \"https://media.discordapp.net/attachments/937337957419999272/937463192265846784/techpoint_logo_Bot.jpg?width=812&height=812\",\n                            desc: `The Bot Beta program is a program for new updates that still contains some bugs. Because of this program there are fewer bugs at the release! Everything happens via another bot so that the current bot users are not bothered by the beta testing`,\n                            fields: [\n                                {\n                                    name: `📃┆Requirements for participation`,\n                                    value: `- Minimum 50 members in the server \\n- No test servers \\n- Following the Discord and Bot TOS \\n- Active server`,\n                                },\n                                {\n                                    name: `❓┆How does it work?`,\n                                    value: `You are going to use a beta bot. This does mean that the bot does not work 100% on some points. Keep this in mind when you sign up!`,\n                                },\n                                {\n                                    name: `💼┆I want to apply!`,\n                                    value: `Nice that you want to participate in Bot! We ask you to create a ticket in us <#897213893624102965> We will send a form and possibly additional information \\n\\n**Pay attention!** When the update is out you will be removed from our program!`,\n                                }\n                            ],\n                            footer: {\n                                text: `© TechPoint - 2022`,\n                                iconURL: \"https://media.discordapp.net/attachments/937337957419999272/937797574440681472/techpoint_logo-min.jpg?width=812&height=812\"\n                            }\n                        }, interaction.channel)\n                    })\n\n                }\n\n                if (message == \"credits\") {\n                    client.simpleEmbed({\n                        image: `https://media.discordapp.net/attachments/937337957419999272/938725907659644928/techpoint_channel_banner_credits.png?width=813&height=221`\n                    }, interaction.channel).then(() => {\n                        client.embed({\n                            title: `${client.user.username}・Dcredits`,\n                            author: {\n                                name: \"TechPoint\",\n                                iconURL: \"https://media.discordapp.net/attachments/937337957419999272/937797574440681472/techpoint_logo-min.jpg?width=812&height=812\"\n                            },\n                            thumbnail: \"https://media.discordapp.net/attachments/937337957419999272/937463192265846784/techpoint_logo_Bot.jpg?width=812&height=812\",\n                            fields: [\n                                {\n                                    name: `ℹ️┆What are Dcredits?`,\n                                    value: `Dcredits are credits you get when you perform certain actions! You can exchange this for nice benefits for you and your server`,\n                                },\n                                {\n                                    name: `❓┆How do you get Dcredits?`,\n                                    value: `Currently you only get Dcredits when you vote on Bot. You can do this on top.gg! The credits will then be automatically added to your account!`,\n                                },\n                                {\n                                    name: `💱┆What can you exchange Dcredits for?`,\n                                    value: `- Bot background pack (8 credits per pack)\\n- Bot logo pack (6 credits per pack)\\n- Bot sticker pack (5 credits per pack)\\n- Bot 1 year pack (10 credits per pack)`,\n                                },\n                                {\n                                    name: `🎁┆How do I redeem Dcredits?`,\n                                    value: `For a background pack: \\`/dcredits backgroundpack\\`\\nFor a logo pack: \\`/dcredits logopack\\`\\nFor a sticker pack: \\`/dcredits stickerpack\\`\\nFor a 1 year pack: \\`/dcredits 1yearpack\\``,\n                                },\n                                {\n                                    name: `🐞┆I have discovered a bug is the system`,\n                                    value: `If something went wrong with your credits? Open a ticket in our <#897213893624102965> and we will solve this as soon as possible!`,\n                                }\n                            ],\n                            footer: {\n                                text: `© TechPoint - 2022`,\n                                iconURL: \"https://media.discordapp.net/attachments/937337957419999272/937797574440681472/techpoint_logo-min.jpg?width=812&height=812\"\n                            }\n                        }, interaction.channel)\n                    })\n\n                }\n            }\n            else {\n                return client.errNormal({ text: \"Only Bot 2 developers are allowed to do this\", editreply: true }, interaction);\n            }\n        })\n    },\n};\n\n ","size_bytes":32760},"src/interactions/Command/messages.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst Discord = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('messages')\n        .setDescription('View the message system')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('help')\n                .setDescription('Get information about the message category commands')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('add')\n                .setDescription('Add messages to a user')\n                .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true))\n                .addNumberOption(option => option.setName('amount').setDescription('Enter a amount of messages').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('deletereward')\n                .setDescription('Delete a message reward')\n                .addNumberOption(option => option.setName('amount').setDescription('Enter a amount of messages').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('createreward')\n                .setDescription('Create a message reward')\n                .addNumberOption(option => option.setName('amount').setDescription('Enter a amount of messages').setRequired(true))\n                .addRoleOption(option => option.setName('role').setDescription('The role for this reward').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('remove')\n                .setDescription('Remove messages to a user')\n                .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true))\n                .addNumberOption(option => option.setName('amount').setDescription('Enter a amount of messages').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('show')\n                .setDescription('See your messages')\n                .addUserOption(option => option.setName('user').setDescription('Select a user'))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('rewards')\n                .setDescription('Show all message rewards')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('leaderboard')\n                .setDescription('See the message leaderboard')\n        )\n    ,\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        client.loadSubcommands(client, interaction, args);\n    },\n};\n\n ","size_bytes":2935},"src/interactions/Command/moderation.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst { ChannelType } = require('discord.js');\nconst Discord = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('moderation')\n        .setDescription('Manage all server moderation')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('help')\n                .setDescription('Get information about the moderation category commands')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('ban')\n                .setDescription('Ban a user')\n                .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true))\n                .addStringOption(option => option.setName('reason').setDescription('The reason for the ban'))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('clear')\n                .setDescription('Clear messages')\n                .addNumberOption(option => option.setName('amount').setDescription('Amount of messages').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('clearuser')\n                .setDescription('Clear user messages in a channel')\n                .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('demote')\n                .setDescription('Demote a user')\n                .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('kick')\n                .setDescription('Kick a user')\n                .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true))\n                .addStringOption(option => option.setName('reason').setDescription('The reason for the kick'))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('lock')\n                .setDescription('Lock a channel')\n                .addChannelOption(option => option.setName('channel').setDescription('Select a channel').addChannelTypes(ChannelType.GuildText))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('lockdown')\n                .setDescription('Lock all channels')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('nuke')\n                .setDescription('Nuke a channel')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('softban')\n                .setDescription('Softban a user')\n                .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true))\n                .addStringOption(option => option.setName('reason').setDescription('The reason for the ban'))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('timeout')\n                .setDescription('Timeout a user')\n                .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true))\n                .addNumberOption(option => option.setName('time').setDescription('Number of minutes').setRequired(true))\n                .addStringOption(option => option.setName('reason').setDescription('Reason for the time out').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('tempban')\n                .setDescription('Temp ban a user')\n                .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true))\n                .addNumberOption(option => option.setName('time').setDescription('Number of minutes').setRequired(true))\n                .addStringOption(option => option.setName('reason').setDescription('The reason for the ban'))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('unlock')\n                .setDescription('Unlock a channel')\n                .addChannelOption(option => option.setName('channel').setDescription('Select a channel').addChannelTypes(ChannelType.GuildText))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('unban')\n                .setDescription('Unban a user')\n                .addStringOption(option => option.setName('user').setDescription('Give a user id').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('banlist')\n                .setDescription('Get all banned users')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('warn')\n                .setDescription('Warn a user')\n                .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true))\n                .addStringOption(option => option.setName('reason').setDescription('The reason for the warn').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('unwarn')\n                .setDescription('Unwarn a user')\n                .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true))\n                .addIntegerOption(option => option.setName('case').setDescription('Give a case number').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('warnings')\n                .setDescription('See a users warnings')\n                .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true))\n        )\n    ,\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        client.loadSubcommands(client, interaction, args);\n    },\n};\n\n ","size_bytes":6251},"src/interactions/Command/music.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst Discord = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('music')\n        .setDescription('Playing music in Bot')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('help')\n                .setDescription('Get information about the music category commands')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('bassboost')\n                .setDescription('Set the bassboost level')\n                .addStringOption(option =>\n                    option.setName('level')\n                        .setDescription('The level of the bassboost')\n                        .setRequired(true)\n                        .addChoices(\n                            { name: '0', value: '0' },\n                            { name: '1', value: '1' },\n                            { name: '2', value: '2' },\n                            { name: '3', value: '3' }\n                        )\n                )\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('play')\n                .setDescription('Start the music')\n                .addStringOption(option => option.setName('song').setDescription('Enter a song name/url').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('clear')\n                .setDescription('Delete the music queue')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('loop')\n                .setDescription('Loop the music')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('lyrics')\n                .setDescription('Get the lyrics of the current song')\n                .addStringOption(option => option.setName('song').setDescription('Enter a song name'))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('playing')\n                .setDescription('See which song is playing now')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('pause')\n                .setDescription('Pause the music')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('previous')\n                .setDescription('Play previous song')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('queue')\n                .setDescription('See the music queue')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('resume')\n                .setDescription('Resume the music')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('remove')\n                .setDescription('Remove a song from the queue')\n                .addNumberOption(option => option.setName('number').setDescription('Song number').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('seek')\n                .setDescription('Seek the current playing music')\n                .addNumberOption(option => option.setName('time').setDescription('New song time').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('shuffle')\n                .setDescription('Shuffle the music')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('skip')\n                .setDescription('Skip the current song')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('skipto')\n                .setDescription('Skip to a new song')\n                .addNumberOption(option => option.setName('number').setDescription('Song number').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('stop')\n                .setDescription('Stop the music')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('volume')\n                .setDescription('Set the music volume')\n                .addNumberOption(option => option.setName('amount').setDescription('New volume number'))\n        ),\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        client.checkBotPerms({\n            flags: [Discord.PermissionsBitField.Flags.Connect, Discord.PermissionsBitField.Flags.Speak],\n            perms: [Discord.PermissionsBitField.Flags.Connect, Discord.PermissionsBitField.Flags.Speak]\n        }, interaction)\n\n        client.loadSubcommands(client, interaction, args);\n    },\n};\n\n\n ","size_bytes":4974},"src/interactions/Command/notepad.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst Discord = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('notepad')\n        .setDescription('Manage your notes')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('help')\n                .setDescription('Get information about the search category commands')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('add')\n                .setDescription('Add a note to your notepad')\n                .addStringOption(option => option.setName('note').setDescription('Your note').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('delete')\n                .setDescription('Delete a note from your notepad')\n                .addStringOption(option => option.setName('id').setDescription('Note id').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('edit')\n                .setDescription('Edit a note from your notepad')\n                .addStringOption(option => option.setName('id').setDescription('Note id').setRequired(true))\n                .addStringOption(option => option.setName('note').setDescription('New note').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('notes')\n                .setDescription('Show all your notes')\n        )\n    ,\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        client.loadSubcommands(client, interaction, args);\n    },\n};\n\n ","size_bytes":1891},"src/interactions/Command/profile.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst Discord = require('discord.js');\nconst ms = require('ms');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('profile')\n        .setDescription('Create a profile for the server')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('help')\n                .setDescription('Get information about the profile category commands')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('create')\n                .setDescription('Create your profile')\n        ).addSubcommand(subcommand =>\n            subcommand\n                .setName('delete')\n                .setDescription('Delete your profile')\n        ).\n        addSubcommand(subcommand =>\n            subcommand\n                .setName('profile')\n                .setDescription('See your profile')\n                .addUserOption((option) =>\n                    option.setName('user').setDescription('The user you want the profile from').setRequired(false),\n                )\n        ).\n        addSubcommand(subcommand =>\n            subcommand\n                .setName('aboutme')\n                .setDescription('Set your about me')\n                .addStringOption(option => option.setName('text').setDescription('Enter a about me').setRequired(true))\n        ).\n        addSubcommand(subcommand =>\n            subcommand\n                .setName('age')\n                .setDescription('Set your age')\n                .addNumberOption(option => option.setName('number').setDescription('Enter a number').setRequired(true))\n        ).\n        addSubcommand(subcommand =>\n            subcommand\n                .setName('bday')\n                .setDescription('Set your bday')\n                .addStringOption(option => option.setName('bday').setDescription('Enter a bday').setRequired(true))\n        )\n\n        .addSubcommandGroup((group) =>\n            group\n                .setName('actor')\n                .setDescription('Set your favorite actor')\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('addactor')\n                        .setDescription('The actor you want to add')\n                        .addStringOption(option => option.setName('actor').setDescription('The actor you want to add').setRequired(true)),\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('delactor')\n                        .setDescription(\"The actor you want te remove\")\n                        .addStringOption(option => option.setName('actor').setDescription('The actor you want to remove').setRequired(true)),\n                )\n        ).\n        addSubcommandGroup((group) =>\n            group\n                .setName('artist')\n                .setDescription('Set your favorite artist')\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('addartist')\n                        .setDescription('The artist you want to add')\n                        .addStringOption(option => option.setName('artist').setDescription('The artist you want to add').setRequired(true)),\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('delartist')\n                        .setDescription(\"The artist you want te remove\")\n                        .addStringOption(option => option.setName('artist').setDescription('The artist you want to remove').setRequired(true)),\n                )\n        ).\n        addSubcommand(subcommand =>\n            subcommand\n                .setName('color')\n                .setDescription('Set your favorite color')\n                .addStringOption(option => option.setName('color').setDescription('The color you want to set').setRequired(true)),\n\n        ).addSubcommandGroup((group) =>\n            group\n                .setName('food')\n                .setDescription('Set your favorite food')\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('addfood')\n                        .setDescription('The food you want to add')\n                        .addStringOption(option => option.setName('food').setDescription('The food you want to add').setRequired(true)),\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('delfood')\n                        .setDescription(\"The food you want te remove\")\n                        .addStringOption(option => option.setName('food').setDescription('The food you want to remove').setRequired(true)),\n                )\n        ).addSubcommandGroup((group) =>\n            group\n                .setName('movie')\n                .setDescription('Set your favorite movie')\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('addmovie')\n                        .setDescription('The movie you want to add')\n                        .addStringOption(option => option.setName('movie').setDescription('The movie you want to add').setRequired(true)),\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('delmovie')\n                        .setDescription(\"The movie you want te remove\")\n                        .addStringOption(option => option.setName('movie').setDescription('The movie you want to remove').setRequired(true)),\n                )\n        ).addSubcommandGroup((group) =>\n            group\n                .setName('pet')\n                .setDescription('Set your favorite pet')\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('addpet')\n                        .setDescription('The pet you want to add')\n                        .addStringOption(option => option.setName('pet').setDescription('The pet you want to add').setRequired(true)),\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('delpet')\n                        .setDescription(\"The pet you want te remove\")\n                        .addStringOption(option => option.setName('pet').setDescription('The pet you want to remove').setRequired(true)),\n                )\n        ).addSubcommandGroup((group) =>\n            group\n                .setName('song')\n                .setDescription('Set your favorite song')\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('addsong')\n                        .setDescription('The song you want to add')\n                        .addStringOption(option => option.setName('song').setDescription('The song you want to add').setRequired(true)),\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('delsong')\n                        .setDescription(\"The song you want te remove\")\n                        .addStringOption(option => option.setName('song').setDescription('The song you want to remove').setRequired(true)),\n                )\n        ).\n        addSubcommand(subcommand =>\n            subcommand\n                .setName('gender')\n                .setDescription('Set your gender')\n\n        ).addSubcommandGroup((group) =>\n            group\n                .setName('hobbies')\n                .setDescription('Set your favorite hobby')\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('addhobby')\n                        .setDescription('The song you want to add')\n                        .addStringOption(option => option.setName('hobby').setDescription('The hobby you want to add').setRequired(true)),\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('delhobby')\n                        .setDescription(\"The hobby you want te remove\")\n                        .addStringOption(option => option.setName('hobby').setDescription('The hobby you want to remove').setRequired(true)),\n                )\n        ).\n        addSubcommand(subcommand =>\n            subcommand\n                .setName('origin')\n                .setDescription('Set your origin')\n                .addStringOption(option => option.setName('country').setDescription('Enter a country').setRequired(true))\n        ).\n        addSubcommand(subcommand =>\n            subcommand\n                .setName('status')\n                .setDescription('Set your status')\n                .addStringOption(option => option.setName('text').setDescription('Enter a status').setRequired(true))\n        ),\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        client.loadSubcommands(client, interaction, args);\n    },\n};\n\n ","size_bytes":9263},"src/interactions/Command/radio.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/music\");\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('radio')\n        .setDescription('Playing radio in Bot')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('help')\n                .setDescription('Get information about the radio category commands')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('play')\n                .setDescription('Start the radio'),\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('stop')\n                .setDescription('Stop the radio'),\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('playing')\n                .setDescription('Show what is playing now'),\n        ),\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        client.checkBotPerms({\n            flags: [Discord.PermissionsBitField.Flags.Connect, Discord.PermissionsBitField.Flags.Speak],\n            perms: [Discord.PermissionsBitField.Flags.Connect, Discord.PermissionsBitField.Flags.Speak]\n        }, interaction)\n        if (!interaction.member.voice.channel) return client.errNormal({ \n            error: `You're not in a voice channel!`, \n            type: 'editreply' \n        }, interaction);\n\n        client.loadSubcommands(client, interaction, args);\n    },\n};\n\n ","size_bytes":1761},"src/interactions/Command/reactionroles.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst { ChannelType } = require('discord.js');\nconst Discord = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('reactionroles')\n        .setDescription('Manage the server reaction roles')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('help')\n                .setDescription('Get information about the reaction roles category commands')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('add')\n                .setDescription('Add a reaction role')\n                .addStringOption(option => option.setName('category').setDescription('category name for your reaction roles group').setRequired(true))\n                .addRoleOption(option => option.setName('role').setDescription('Select a role').setRequired(true))\n                .addStringOption(option => option.setName('emoji').setDescription('Enter a emoji').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('delete')\n                .setDescription('Delete a reaction roles category')\n                .addStringOption(option => option.setName('category').setDescription('category name for your reaction roles group').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('list')\n                .setDescription('Show all reaction roles categories from this guild')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('button')\n                .setDescription('Show all reaction roles with buttons')\n                .addStringOption(option => option.setName('category').setDescription('Category name for your reaction roles group').setRequired(true))\n                .addChannelOption(option => option.setName('channel').setDescription('Channel where the reaction roles should come').addChannelTypes(ChannelType.GuildText))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('menu')\n                .setDescription('Show all reaction roles in a menu')\n                .addStringOption(option => option.setName('category').setDescription('Category name for your reaction roles group').setRequired(true))\n                .addChannelOption(option => option.setName('channel').setDescription('Channel where the reaction roles should come').addChannelTypes(ChannelType.GuildText))\n        )\n    ,\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        const perms = await client.checkPerms({\n            flags: [Discord.PermissionsBitField.Flags.ManageRoles],\n            perms: [Discord.PermissionsBitField.Flags.ManageRoles]\n        }, interaction)\n\n        if (perms == false) return;\n\n        client.loadSubcommands(client, interaction, args);\n    },\n};\n\n ","size_bytes":3157},"src/interactions/Command/report.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst Discord = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('report')\n        .setDescription('Report a bug or user to the developers')\n        .addStringOption(option =>\n            option.setName('type')\n                .setDescription('The type of your report')\n                .setRequired(true)\n                .addChoices(\n                    { name: 'Bug', value: 'bug' },\n                    { name: 'User', value: 'user' }\n                )\n        )\n        .addStringOption(option =>\n            option.setName('description')\n                .setDescription('Description with your report')\n                .setRequired(true)\n        )\n    ,\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        const webhookClient = new Discord.WebhookClient({\n            id: client.webhooks.bugReportLogs.id,\n            token: client.webhooks.bugReportLogs.token\n        });\n\n        const type = interaction.options.getString('type');\n        const desc = interaction.options.getString('description');\n\n        if (type == \"bug\") {\n            const embed = new Discord.EmbedBuilder()\n                .setTitle(`📣・New bug report!`)\n                .addFields(\n                    { name: \"Report category\", value: \"Bug\", inline: true },\n                    { name: \"Submitted by\", value: `${interaction.user.tag}`, inline: true },\n                )\n                .setDescription(`${desc}`)\n                .setColor(client.config.colors.normal)\n            webhookClient.send({\n                username: 'Bot Reports',\n                embeds: [embed],\n            });\n\n            client.succNormal({\n                text: `Bug successfully sent to the developers!`,\n                type: 'ephemeraledit'\n            }, interaction);\n        }\n        else if (type == \"user\") {\n            const embed = new Discord.EmbedBuilder()\n                .setTitle(`📣・New user report!`)\n                .addFields(\n                    { name: \"Report category\", value: \"User\", inline: true },\n                    { name: \"Submitted by\", value: `${interaction.user.tag}`, inline: true },\n                )\n                .setDescription(`${desc}`)\n                .setColor(client.config.colors.normal)\n            webhookClient.send({\n                username: 'Bot Reports',\n                embeds: [embed],\n            });\n\n            client.succNormal({\n                text: `User report successfully sent to the developers!`,\n                type: 'ephemeraledit'\n            }, interaction);\n        }\n    },\n};\n\n ","size_bytes":2883},"src/interactions/Command/search.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst Discord = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('search')\n        .setDescription('Search something on the internet')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('help')\n                .setDescription('Get information about the search category commands')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('bing')\n                .setDescription('Find something on Bing')\n                .addStringOption(option => option.setName('name').setDescription('Your search name').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('ddg')\n                .setDescription('Find something on DuckDuckGo')\n                .addStringOption(option => option.setName('name').setDescription('Your search name').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('google')\n                .setDescription('Find something on Google')\n                .addStringOption(option => option.setName('name').setDescription('Your search name').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('youtube')\n                .setDescription('Find something on YouTube')\n                .addStringOption(option => option.setName('name').setDescription('Your search name').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('corona')\n                .setDescription('See the corona stats')\n                .addStringOption(option => option.setName('country').setDescription('Enter a country').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand \n                .setName('crypto')\n                .setDescription('See the value of the crypto coin')\n                .addStringOption(option => option.setName('coin').setDescription('Enter a coin').setRequired(true))\n                .addStringOption(option => option.setName('currency').setDescription('Enter a currency').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('docs')\n                .setDescription('See the discord.js docs')\n                .addStringOption(option => option.setName('name').setDescription('Your search name').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('github')\n                .setDescription('Get info on a github user just by entering their username')\n                .addStringOption(option => option.setName('name').setDescription('Enter a github name').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('hexcolour')\n                .setDescription('Get info from a color')\n                .addStringOption(option => option.setName('color').setDescription('Enter a hex color').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('itunes')\n                .setDescription('Search on iTunes for any song')\n                .addStringOption(option => option.setName('song').setDescription('Enter a song name').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('npm')\n                .setDescription('Get info on an NPM package')\n                .addStringOption(option => option.setName('name').setDescription('Enter a package name').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('steam')\n                .setDescription('Get info on an application on Steam')\n                .addStringOption(option => option.setName('name').setDescription('Enter a Steam application name').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('translate')\n                .setDescription('Translate some text')\n                .addStringOption(option => option.setName('language').setDescription('Enter a language').setRequired(true))\n                .addStringOption(option => option.setName('text').setDescription('Enter some text').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('weather')\n                .setDescription('See the current weather')\n                .addStringOption(option => option.setName('location').setDescription('Enter a location name').setRequired(true))\n        )\n    ,\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        client.loadSubcommands(client, interaction, args);\n    },\n};\n\n ","size_bytes":5113},"src/interactions/Command/serverstats.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst Discord = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('serverstats')\n        .setDescription('Manage the server stats')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('help')\n                .setDescription('Get information about the server stats category commands')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('boosts')\n                .setDescription('Keep track of the boost count')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('tier')\n                .setDescription('Keep track of the boost tier count')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('channels')\n                .setDescription('Keep track of the channel count')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('stage-channels')\n                .setDescription('Keep track of the stage channel count')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('text-channels')\n                .setDescription('Keep track of the text channel count')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('voice-channels')\n                .setDescription('Keep track of the voice channel count')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('news-channels')\n                .setDescription('Keep track of the news channel count')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('members')\n                .setDescription('Keep track of the member count')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('bots')\n                .setDescription('Keep track of the bots count')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('roles')\n                .setDescription('Keep track of the role count')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('emoji')\n                .setDescription('Keep track of the emoji\\'s count')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('static-emoji')\n                .setDescription('Keep track of the static emoji\\'s count')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('animated-emoji')\n                .setDescription('Keep track of the animated emoji\\'s count')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('time')\n                .setDescription('Keep track of your current time zone')\n                .addStringOption(option =>\n                    option.setName('timezone')\n                        .setDescription('The timezone you want to set (e.g. Europe/Amsterdam)')\n                        .setRequired(true)\n                )\n        )\n    ,\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        const perms = await client.checkPerms({\n            flags: [Discord.PermissionsBitField.Flags.ManageChannels],\n            perms: [Discord.PermissionsBitField.Flags.ManageChannels]\n        }, interaction)\n\n        if (perms == false) return;\n\n        client.loadSubcommands(client, interaction, args);\n    },\n};\n\n ","size_bytes":3786},"src/interactions/Command/setup.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst { ChannelType } = require('discord.js');\nconst Discord = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('setup')\n        .setDescription('Manage the Bot setups')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('help')\n                .setDescription('Get information about the setup category commands')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('tickets')\n                .setDescription('Setup the tickets')\n                .addChannelOption(option => option.setName('category').setDescription('Select a category where the tickets should come in').setRequired(true).addChannelTypes(ChannelType.GuildCategory))\n                .addRoleOption(option => option.setName('role').setDescription('Select the support role').setRequired(true))\n                .addChannelOption(option => option.setName('channel').setDescription('The channel for the ticket panel').setRequired(true).addChannelTypes(ChannelType.GuildText))\n                .addChannelOption(option => option.setName('logs').setDescription('The channel for the ticket logs').setRequired(true).addChannelTypes(ChannelType.GuildText))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('customvoice')\n                .setDescription('Setup the custom voice channels')\n                .addChannelOption(option => option.setName('category').setDescription('Select a category where the channels come in').setRequired(true).addChannelTypes(ChannelType.GuildCategory))\n                .addStringOption(option => option.setName('channelname').setDescription('The template for the channel names').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('logs')\n                .setDescription('Set the logs from the server')\n                .addStringOption(option =>\n                    option.setName('setup')\n                        .setDescription('The setup that you want')\n                        .setRequired(true)\n                        .addChoices(\n                            { name: 'Server logs', value: 'serverLogs' },\n                            { name: 'Level logs', value: 'levelLogs' },\n                            { name: 'Boost logs', value: 'boostLogs' }\n                        )\n                )\n                .addChannelOption(option => option.setName('channel').setDescription('The channel for the logs').setRequired(true).addChannelTypes(ChannelType.GuildText))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('fun')\n                .setDescription('Set the fun channels from the server')\n                .addStringOption(option =>\n                    option.setName('setup')\n                        .setDescription('The setup that you want')\n                        .setRequired(true)\n                        .addChoices(\n                            { name: 'Birthdays', value: 'birthdays' },\n                            { name: 'Chatbot', value: 'chatbot' },\n                            { name: 'Reviews', value: 'reviews' },\n                            { name: 'Suggestions', value: 'suggestions' },\n                            { name: 'Starboard', value: 'starboard' }\n                        )\n                )\n                .addChannelOption(option => option.setName('channel').setDescription('The channel for the fun').setRequired(true).addChannelTypes(ChannelType.GuildText))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('games')\n                .setDescription('Set the game channels from the server')\n                .addStringOption(option =>\n                    option.setName('setup')\n                        .setDescription('The setup that you want')\n                        .setRequired(true)\n                        .addChoices(\n                            { name: 'Counting', value: 'counting' },\n                            { name: 'Guess the number', value: 'gtn' },\n                            { name: 'Guess the word', value: 'gtw' },\n                            { name: 'Word snake', value: 'wordsnake' }\n                        )\n                )\n                .addChannelOption(option => option.setName('channel').setDescription('The channel for the game').setRequired(true).addChannelTypes(ChannelType.GuildText))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('welcomechannels')\n                .setDescription('Setup the welcome channels')\n                .addStringOption(option =>\n                    option.setName('setup')\n                        .setDescription('The setup that you want')\n                        .setRequired(true)\n                        .addChoices(\n                            { name: 'Welcome channel', value: 'welcomechannel' },\n                            { name: 'Leave channnel', value: 'leavechannel' }\n                        )\n                )\n                .addChannelOption(option => option.setName('channel').setDescription('The channel that you want').setRequired(true).addChannelTypes(ChannelType.GuildText))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('welcomerole')\n                .setDescription('Setup the welcome role')\n                .addRoleOption(option => option.setName('role').setDescription('The role that you want').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('ticketpanel')\n                .setDescription('Setup the ticket panel')\n                .addStringOption(option => option.setName('name').setDescription('The name of the ticket panel').setRequired(true))\n                .addStringOption(option => option.setName('description').setDescription('The description of the ticket panel').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('deletesetup')\n                .setDescription('Delete a Bot setup')\n                .addStringOption(option =>\n                    option.setName('setup')\n                        .setDescription('The setup that you want')\n                        .setRequired(true)\n                        .addChoices(\n                            { name: 'Tickets', value: 'tickets' },\n                            { name: 'Custom voice', value: 'customvoice' },\n                            { name: 'Server logs', value: 'serverlogs' },\n                            { name: 'Level logs', value: 'levellogs' },\n                            { name: 'Boost logs', value: 'boostlogs' },\n                            { name: 'Birthdays', value: 'birthdays' },\n                            { name: 'Chatbot', value: 'chatbot' },\n                            { name: 'Reviews', value: 'reviews' },\n                            { name: 'Suggestions', value: 'suggestions' },\n                            { name: 'Counting', value: 'counting' },\n                            { name: 'Guess the number', value: 'gtn' },\n                            { name: 'Guess the word', value: 'gtw' },\n                            { name: 'Welcome channel', value: 'welcomechannel' },\n                            { name: 'Leave channel', value: 'leavechannel' },\n                            { name: 'Welcome role', value: 'welcomerole' },\n                            { name: 'Word snake', value: 'wordsnake' }\n                        )\n                )\n        )\n    ,\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        const perms = await client.checkUserPerms({\n            flags: [Discord.PermissionsBitField.Flags.Administrator],\n            perms: [Discord.PermissionsBitField.Flags.Administrator]\n        }, interaction)\n\n        if (perms == false) return;\n\n        client.loadSubcommands(client, interaction, args);\n    },\n};\n\n ","size_bytes":8282},"src/interactions/Command/soundboard.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\n\nmodule.exports = {\n\n    // Meme Images\n\n    data: new SlashCommandBuilder()\n        .setName('soundboard')\n        .setDescription('Play all the sounds in Bot')\n\n        .addSubcommand((subcommand) =>\n            subcommand\n                .setName('help')\n                .setDescription('Get information about the soundboard category commands')\n        )\n        \n        // Windows Sounds\n        .addSubcommandGroup((group) =>\n            group\n                .setName('windows')\n                .setDescription('Play the windows sounds in Bot')\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('windowserror')\n                        .setDescription('Play the windows error sound')\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('windowsshutdown')\n                        .setDescription('Play the windows shutdown sound')\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('windowsstartup')\n                        .setDescription('Play the windows startup sound')\n                )\n        )\n\n        // Earrape Sounds\n\n        .addSubcommandGroup((group) =>\n            group\n                .setName('earrape')\n                .setDescription('Play the earrape sounds in Bot')\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('reee')\n                        .setDescription('Play the reee sound')\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('defaultdance')\n                        .setDescription('Play the defaultdance sound')\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('startup')\n                        .setDescription('Play the startup sound')\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('thomas')\n                        .setDescription('Play the thomas sound')\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('wegothim')\n                        .setDescription('Play the wegothim sound')\n                )\n        )\n\n        // Song Sounds\n\n        .addSubcommandGroup((group) =>\n            group\n                .setName('songs')\n                .setDescription('Play the song sounds in Bot')\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('dancememe')\n                        .setDescription('Play the dancememe sound')\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('despacito')\n                        .setDescription('Play the despacito sound')\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('elevator')\n                        .setDescription('Play the elevator sound')\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('rickastley')\n                        .setDescription('Play the rickastley sound')\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('running')\n                        .setDescription('Play the running sound')\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('tobecontinued')\n                        .setDescription('Play the tobecontinued sound')\n                )\n        )\n\n        // Discord Sounds\n\n        .addSubcommandGroup((group) =>\n            group\n                .setName('discord')\n                .setDescription('Play the discord sounds in Bot')\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('discordcall')\n                        .setDescription('Play the discord call sound'),\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('discordjoin')\n                        .setDescription('Play the discord voice call join sound'),\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand.setName('discordleave').setDescription('Play the discord voice call leave sound')\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('discordnotification')\n                        .setDescription('Play the discord notification sound'),\n                )\n        )\n\n        // Discord Sounds\n\n        .addSubcommandGroup((group) =>\n            group\n                .setName('memes')\n                .setDescription('Play the meme sounds in Bot')\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('fbi')\n                        .setDescription('Play the fbi sound'),\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('jeff')\n                        .setDescription('Play the jeff sound'),\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('lambo')\n                        .setDescription('Play the lambo sound'),\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('missionfailed')\n                        .setDescription('Play the missionfailed sound'),\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('moaning')\n                        .setDescription('Play themoaning sound'),\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('nani')\n                        .setDescription('Play the nani sound'),\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('nyancat')\n                        .setDescription('Play the nyancat sound'),\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('ohh')\n                        .setDescription('Play the ohh sound'),\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('rimshot')\n                        .setDescription('Play the rimshot sound'),\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('roblox')\n                        .setDescription('Play the roblox sound'),\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('shotdown')\n                        .setDescription('Play the shotdown sound'),\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('spongebob')\n                        .setDescription('Play the spongebob sound'),\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('wow')\n                        .setDescription('Play the wow sound'),\n                )\n                .addSubcommand((subcommand) =>\n                    subcommand\n                        .setName('yeet')\n                        .setDescription('Play the yeet sound'),\n                )\n        ),\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        client.loadSubcommands(client, interaction, args);\n    },\n};\n\n\n ","size_bytes":8440},"src/interactions/Command/stickymessages.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst { ChannelType } = require('discord.js');\nconst Discord = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('stickymessages')\n        .setDescription('Manage the sticky messages')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('help')\n                .setDescription('Get information about the sticky messages category commands')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('stick')\n                .setDescription('Stick an message in a channel')\n                .addChannelOption(option => option.setName('channel').setDescription('Select a channel').setRequired(true).addChannelTypes(ChannelType.GuildText))\n                .addStringOption(option => option.setName('message').setDescription('Your sticky messages').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('messages')\n                .setDescription('Show all your guild sticky messages')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('unstick')\n                .setDescription('Unstick an message in a channel')\n                .addChannelOption(option => option.setName('channel').setDescription('Select a channel').setRequired(true).addChannelTypes(ChannelType.GuildText))\n        )\n    ,\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        const perms = await client.checkUserPerms({\n            flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n            perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n        }, interaction)\n\n        if (perms == false) return;\n\n        client.loadSubcommands(client, interaction, args);\n    },\n};\n\n ","size_bytes":2085},"src/interactions/Command/suggestions.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst Discord = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('suggestions')\n        .setDescription('Manage the suggestions')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('help')\n                .setDescription('Get information about the suggestions category commands')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('accept')\n                .setDescription('Accept a suggestion')\n                .addStringOption(option => option.setName('id').setDescription('Suggestion message ID').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('deny')\n                .setDescription('Deny a suggestion')\n                .addStringOption(option => option.setName('id').setDescription('Suggestion message ID').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('send')\n                .setDescription('Send a suggestion')\n                .addStringOption(option => option.setName('suggestion').setDescription('Your suggestion').setRequired(true))\n        )\n    ,\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        client.loadSubcommands(client, interaction, args);\n    },\n};\n\n ","size_bytes":1642},"src/interactions/Command/thanks.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst Discord = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('thanks')\n        .setDescription('Get an overview of the thanks system')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('help')\n                .setDescription('Get information about the thanks category commands')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('check')\n                .setDescription('See your thanks')\n                .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('thanks')\n                .setDescription('Thanks a user')\n                .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true))\n        )\n    ,\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        client.loadSubcommands(client, interaction, args);\n    },\n};\n\n ","size_bytes":1342},"src/interactions/Command/tickets.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst Discord = require('discord.js');\n\nconst ticketSchema = require(\"../../database/models/tickets\");\nconst ticketChannels = require(\"../../database/models/ticketChannels\");\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('tickets')\n        .setDescription('Manage tickets in your server')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('help')\n                .setDescription('Get information about the tickets category commands')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('add')\n                .setDescription('Add a user to a ticket')\n                .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('claim')\n                .setDescription('Claim a ticket')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('close')\n                .setDescription('Close a ticket')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('delete')\n                .setDescription('Delete a ticket')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('information')\n                .setDescription('Information about a ticket')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('lower')\n                .setDescription('Lower a ticket')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('create')\n                .setDescription('Create a ticket')\n                .addStringOption(option => option.setName('reason').setDescription('Reason to open a ticket'))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('notice')\n                .setDescription('Send a notice to a ticket')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('open')\n                .setDescription('Reopen a ticket')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('raise')\n                .setDescription('Raise a ticket')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('remove')\n                .setDescription('Remove a user from a ticket')\n                .addUserOption(option => option.setName('user').setDescription('Select a user').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('rename')\n                .setDescription('Rename a ticket')\n                .addStringOption(option => option.setName('name').setDescription('New ticket name').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('transcript')\n                .setDescription('Transcript a ticket')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('unclaim')\n                .setDescription('Unclaim a ticket')\n        )\n    ,\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        client.loadSubcommands(client, interaction, args);\n    },\n};\n\n ","size_bytes":3620},"src/interactions/Command/tools.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst Discord = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('tools')\n        .setDescription('Use some cool tools')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('help')\n                .setDescription('Get information about the tools category commands')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('anagram')\n                .setDescription('Form a word with certain letters')\n                .addStringOption(option => option.setName('word').setDescription('The word you want to form').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('button')\n                .setDescription('Create a button')\n                .addStringOption(option => option.setName('url').setDescription('The url for the button').setRequired(true))\n                .addStringOption(option => option.setName('text').setDescription('The text for the button').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('calculator')\n                .setDescription('Calculate a sum')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('decode')\n                .setDescription('Decode binary code to text')\n                .addStringOption(option => option.setName('code').setDescription('The binary code you want to decode').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('emojify')\n                .setDescription('Convert text to emojis')\n                .addStringOption(option => option.setName('text').setDescription('The text you want to convert').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('encode')\n                .setDescription('Encode text to binary code')\n                .addStringOption(option => option.setName('text').setDescription('The text you want to encode').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('enlarge')\n                .setDescription('Enlarge an emoji')\n                .addStringOption(option => option.setName('emoji').setDescription('The emoji you want to enlarge').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('mcskin')\n                .setDescription('See the skin of a minecraft user')\n                .addStringOption(option => option.setName('name').setDescription('The username of the player').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('mcstatus')\n                .setDescription('See the status of a minecraft server')\n                .addStringOption(option => option.setName('ip').setDescription('The ip of the mc server').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('pwdgen')\n                .setDescription('Generate a password')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('qrcode')\n                .setDescription('Sends a qrcode photo of text you have given')\n                .addStringOption(option => option.setName('text').setDescription('The text you want to convert').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('remind')\n                .setDescription('Set a reminder')\n                .addStringOption(option => option.setName('time').setDescription('The time for your reminder').setRequired(true))\n                .addStringOption(option => option.setName('message').setDescription('The message for your reminder').setRequired(true))\n\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('sourcebin')\n                .setDescription('Upload code to source bin')\n                .addStringOption(option => option.setName('language').setDescription('The language of your code').setRequired(true))\n                .addStringOption(option => option.setName('code').setDescription('Your code').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('url')\n                .setDescription('Make a shortend url')\n                .addStringOption(option => option.setName('site').setDescription('The link to the website').setRequired(true))\n                .addStringOption(option => option.setName('code').setDescription('The code for the url').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('review')\n                .setDescription('Write a review')\n                .addNumberOption(option => option.setName('stars').setDescription('The number of stars (max 5)').setRequired(true))\n                .addStringOption(option => option.setName('message').setDescription('A small description with the review'))\n        )\n    ,\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        client.loadSubcommands(client, interaction, args);\n    },\n};\n\n ","size_bytes":5585},"src/interactions/Command/voice.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { SlashCommandBuilder } = require('discord.js');\nconst Discord = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('voice')\n        .setDescription('Manage the voice channels')\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('help')\n                .setDescription('Get information about the voice category commands')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('limit')\n                .setDescription('Limit your custom voice channel')\n                .addNumberOption(option => option.setName('limit').setDescription('Enter a limit').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('lock')\n                .setDescription('Lock your custom voice channel')\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('rename')\n                .setDescription('Rename your custom voice channel')\n                .addStringOption(option => option.setName('name').setDescription('New voice name').setRequired(true))\n        )\n        .addSubcommand(subcommand =>\n            subcommand\n                .setName('unlock')\n                .setDescription('Unlock your custom voice channel')\n        )\n    ,\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ fetchReply: true });\n        client.loadSubcommands(client, interaction, args);\n    },\n};\n\n ","size_bytes":1712},"src/interactions/ContextMenu/profile.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { ContextMenuCommandBuilder } = require('discord.js');\nconst Discord = require('discord.js');\n\nconst model = require('../../database/models/badge');\nconst Schema = require('../../database/models/profile');\nconst CreditsSchema = require(\"../../database/models/votecredits\");\n\nmodule.exports = {\n    data: new ContextMenuCommandBuilder()\n        .setName('Bot profile')\n        .setType(2),\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        const badgeFlags = {\n            DEVELOPER: client.emotes.badges.developer,\n            EVENT: client.emotes.badges.event,\n            BOOSTER: client.emotes.badges.booster,\n            BUGS: client.emotes.badges.bug,\n            MANAGEMENT: client.emotes.badges.management,\n            PREMIUM: client.emotes.badges.premium,\n            SUPPORTER: client.emotes.badges.supporter,\n            TEAM: client.emotes.badges.team,\n            BOOSTER: client.emotes.badges.booster,\n            PARTNER: client.emotes.badges.partner,\n            VOTER: client.emotes.badges.voter,\n            SUPPORT: client.emotes.badges.support,\n            MODERATOR: client.emotes.badges.moderator,\n            DESIGNER: client.emotes.badges.designer,\n            MARKETING: client.emotes.badges.marketing,\n            ACTIVE: client.emotes.badges.active,\n            VIP: client.emotes.badges.vip\n        }\n\n        const flags = {\n            ActiveDeveloper: \"👨‍💻・Active Developer\",\n            BugHunterLevel1: \"🐛・Discord Bug Hunter\",\n            BugHunterLevel2: \"🐛・Discord Bug Hunter\",\n            CertifiedModerator: \"👮‍♂️・Certified Moderator\",\n            HypeSquadOnlineHouse1: \"🏠・House Bravery Member\",\n            HypeSquadOnlineHouse2: \"🏠・House Brilliance Member\",\n            HypeSquadOnlineHouse3: \"🏠・House Balance Member\",\n            HypeSquadEvents: \"🏠・HypeSquad Events\",\n            PremiumEarlySupporter: \"👑・Early Supporter\",\n            Partner: \"👑・Partner\",\n            Quarantined: \"🔒・Quarantined\", // Not sure if this is still a thing\n            Spammer: \"🔒・Spammer\", // Not sure if this one works\n            Staff: \"👨‍💼・Discord Staff\",\n            TeamPseudoUser: \"👨‍💼・Discord Team\",\n            VerifiedBot: \"🤖・Verified Bot\",\n            VerifiedDeveloper: \"👨‍💻・(early)Verified Bot Developer\",\n        }\n\n\n        const user = interaction.guild.members.cache.get(interaction.targetId);\n\n        Schema.findOne({ User: user.id }, async (err, data) => {\n            if (data) {\n                await interaction.deferReply({ fetchReply: true });\n                let Badges = await model.findOne({ User: user.id });\n\n                let credits = 0;\n                const creditData = await CreditsSchema.findOne({ User: user.id });\n\n                if (Badges && Badges.FLAGS.includes(\"DEVELOPER\")) {\n                    credits = \"∞\";\n                }\n                else if (creditData) {\n                    credits = creditData.Credits;\n                }\n\n                if (!Badges) Badges = { User: user.id };\n\n                const userFlags = user.flags ? user.flags.toArray() : [];\n\n                client.embed({\n                    title: `${client.user.username}・Profile`,\n                    desc: '_____',\n                    thumbnail: user.avatarURL({ dynamic: true }),\n                    fields: [{\n                        name: \"👤┆User\",\n                        value: user.username,\n                        inline: true\n                    },\n                    {\n                        name: \"📘┆Discriminator\",\n                        value: user.discriminator,\n                        inline: true\n                    },\n                    {\n                        name: \"🆔┆ID\",\n                        value: user.id,\n                        inline: true\n                    },\n                    {\n                        name: \"👨‍👩‍👦┆Gender\",\n                        value: `${data.Gender || 'Not set'}`,\n                        inline: true\n                    },\n                    {\n                        name: \"🔢┆Age\",\n                        value: `${data.Age || 'Not set'}`,\n                        inline: true\n                    },\n                    {\n                        name: \"🎂┆Birthday\",\n                        value: `${data.Birthday || 'Not set'}`,\n                        inline: true\n                    },\n                    {\n                        name: \"🎨┆Favorite color\",\n                        value: `${data.Color || 'Not set'}`,\n                        inline: true\n                    },\n                    {\n                        name: \"🐶┆Favorite pets\",\n                        value: `${data.Pets.join(', ') || 'Not set'}`,\n                        inline: true\n                    },\n                    {\n                        name: \"🍕┆Favorite food\",\n                        value: `${data.Food.join(', ') || 'Not set'}`,\n                        inline: true\n                    },\n                    {\n                        name: \"🎶┆Favorite songs\",\n                        value: `${data.Songs.join(', ') || 'Not set'}`,\n                        inline: true\n                    },\n                    {\n                        name: \"🎤┆Favorite artists\",\n                        value: `${data.Artists.join(', ') || 'Not set'}`,\n                        inline: true\n                    },\n                    {\n                        name: \"🎬┆Favorite movies\",\n                        value: `${data.Movies.join(', ') || 'Not set'}`,\n                        inline: true\n                    },\n                    {\n                        name: \"👨‍🎤┆Favorite actors\",\n                        value: `${data.Actors.join(', ') || 'Not set'}`,\n                        inline: true\n                    },\n                    {\n                        name: \"🏴┆Origin\",\n                        value: `${data.Orgin || 'Not set'}`,\n                        inline: true\n                    },\n                    {\n                        name: \"🎮┆Hobby's\",\n                        value: `${data.Hobbys.join(', ') || 'Not set'}`,\n                        inline: true\n                    },\n                    {\n                        name: \"😛┆Status\",\n                        value: `${data.Status || 'Not set'}`,\n                        inline: true\n                    },\n                    {\n                        name: \"📛┆Bot Badges\",\n                        value: `${Badges.FLAGS ? Badges.FLAGS.map(flag => badgeFlags[flag]).join(' ') : 'None'}`,\n                        inline: true\n                    },\n                    {\n                        name: \"🏷️┆Discord Badges\",\n                        value: `${userFlags.length ? userFlags.map(flag => flags[flag]).join(', ') : 'None' || 'None'}`,\n                        inline: true\n                    },\n                    {\n                        name: \"💳┆Dcredits\",\n                        value: `${credits || 'None'}`,\n                        inline: true\n                    },\n                    {\n                        name: \"ℹ️┆About me\",\n                        value: `${data.Aboutme || 'Not set'}`,\n                        inline: false\n                    },], type: 'editreply'\n                }, interaction);\n            }\n            else {\n                return client.errNormal({ error: \"No profile found! Open a profile with /profile create\", type: 'ephemeral' }, interaction);\n            }\n        })\n    },\n};\n\n ","size_bytes":7866},"src/interactions/ContextMenu/unwarn.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { ContextMenuCommandBuilder } = require('discord.js');\nconst Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/warnings\");\n\nmodule.exports = {\n    data: new ContextMenuCommandBuilder()\n        .setName('Unwarn')\n        .setType(2),\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        const perms = await client.checkPerms({\n            flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n            perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n        }, interaction)\n\n        if (perms == false) {\n            client.errNormal({\n                error: \"You don't have the required permissions to use this command!\",\n                type: 'ephemeral'\n            }, interaction);\n            return;\n        }\n        await interaction.deferReply({ ephemeral: true });\n\n        const member = interaction.guild.members.cache.get(interaction.targetId);\n\n        Schema.findOne({ Guild: interaction.guild.id, User: member.id }, async (err, data) => {\n            if (data) {\n                const menu = new Discord.StringSelectMenuBuilder()\n                    .setCustomId('unwarn')\n                    .setPlaceholder('Select a warning to remove');\n                // Get all warnings and add them to a stringselectmenu \n                data.Warnings.forEach(element => {\n                    menu.addOptions({\n                        label: `Case ${element.Case}`,\n                        value: element.Case.toString(),\n                        description: \"Reason: \" + element.Reason\n                    })\n                });\n                // Create a new message with the menu\n                client.embed({\n                    title: `🔨・Unwarn`,\n                    desc: `Select a warning to remove from **${member.user.tag}**`,\n                    components: [new Discord.ActionRowBuilder().addComponents(menu)],\n                    type: 'ephemeraledit'\n                }, interaction);\n\n                // Create a new collector for the menu\n                const filter = i => i.user.id === interaction.user.id;\n                const collector = interaction.channel.createMessageComponentCollector({ filter, time: 15000 });\n\n                collector.on('collect', async i => {\n                    if (i.customId === 'unwarn') {\n                        // Remove the warning from the database\n                        data.Warnings.splice(data.Warnings.findIndex(element => element.Case == i.values[0]), 1);\n                        data.save();\n                        // Remove the menu from the message\n                        i.update({\n                            components: []\n                        });\n                        // Send a success message\n                        client.succNormal({\n                            text: `The warning has been successfully removed`,\n                            fields: [\n                                {\n                                    name: \"👤┆User\",\n                                    value: `${member}`,\n                                    inline: true\n                                }\n                            ],\n                            type: 'ephemeraledit'\n                        }, interaction);\n                        client.emit('warnRemove', member, interaction.user)\n                        client.embed({\n                            title: `🔨・Unwarn`,\n                            desc: `You've been unwarned in **${interaction.guild.name}**`,\n                            fields: [\n                                {\n                                    name: \"👤┆Moderator\",\n                                    value: interaction.user.tag,\n                                    inline: true\n                                },\n                            ]\n                        }, member).catch(() => { })\n                    }\n                });\n            } else {\n                client.errNormal({\n                    error: \"User has no warnings!\",\n                    type: 'ephemeraledit'\n                }, interaction);\n            }\n        })\n    },\n};","size_bytes":4324},"src/interactions/ContextMenu/userinfo.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { ContextMenuCommandBuilder } = require('discord.js');\nconst Discord = require('discord.js');\nconst axios = require(\"axios\");\n\nconst model = require('../../database/models/badge');\n\nmodule.exports = {\n    data: new ContextMenuCommandBuilder()\n        .setName('Userinfo')\n        .setType(2),\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n\n    run: async (client, interaction, args) => {\n        await interaction.deferReply({ ephemeral: false });\n        const member = await interaction.guild.members.fetch(interaction.options.getUser('user').id);\n        if (!member) return client.errNormal({\n            error: \"This user is not in this guild!\",\n            type: 'editreply'\n        }, interaction);\n        const badgeFlags = {\n            DEVELOPER: client.emotes.badges.developer,\n            BUGS: client.emotes.badges.bug,\n            MANAGEMENT: client.emotes.badges.management,\n            PREMIUM: client.emotes.badges.premium,\n            SUPPORTER: client.emotes.badges.supporter,\n            TEAM: client.emotes.badges.team,\n            BOOSTER: client.emotes.badges.booster,\n            PARTNER: client.emotes.badges.partner,\n            VOTER: client.emotes.badges.voter,\n            SUPPORT: client.emotes.badges.support,\n            MODERATOR: client.emotes.badges.moderator,\n            DESIGNER: client.emotes.badges.designer,\n            MARKETING: client.emotes.badges.marketing\n        }\n\n        const flags = {\n            ActiveDeveloper: \"👨‍💻・Active Developer\",\n            BugHunterLevel1: \"🐛・Discord Bug Hunter\",\n            BugHunterLevel2: \"🐛・Discord Bug Hunter\",\n            CertifiedModerator: \"👮‍♂️・Certified Moderator\",\n            HypeSquadOnlineHouse1: \"🏠・House Bravery Member\",\n            HypeSquadOnlineHouse2: \"🏠・House Brilliance Member\",\n            HypeSquadOnlineHouse3: \"🏠・House Balance Member\",\n            HypeSquadEvents: \"🏠・HypeSquad Events\",\n            PremiumEarlySupporter: \"👑・Early Supporter\",\n            Partner: \"👑・Partner\",\n            Quarantined: \"🔒・Quarantined\", // Not sure if this is still a thing\n            Spammer: \"🔒・Spammer\", // Not sure if this one works\n            Staff: \"👨‍💼・Discord Staff\",\n            TeamPseudoUser: \"👨‍💼・Discord Team\",\n            VerifiedBot: \"🤖・Verified Bot\",\n            VerifiedDeveloper: \"👨‍💻・(early)Verified Bot Developer\",\n        }\n\n        let Badges = await model.findOne({ User: member.user.id });\n        if (!Badges) Badges = { User: member.user.id }\n        const roles = member.roles.cache\n            .sort((a, b) => b.position - a.position)\n            .map(role => role.toString())\n            .slice(0, -1);\n        const userFlags = member.user.flags ? member.user.flags.toArray() : [];\n\n        return client.embed({\n            title: `👤・User information`,\n            desc: `Information about ${member.user.username}`,\n            thumbnail: member.user.displayAvatarURL({ dynamic: true, size: 1024 }),\n            image: member.user.bannerURL({ dynamic: true, size: 1024 }),\n            fields: [\n                {\n                    name: \"Username\",\n                    value: `${member.user.username}`,\n                    inline: true,\n                },\n                {\n                    name: \"Discriminator\",\n                    value: `${member.user.discriminator}`,\n                    inline: true,\n                },\n                {\n                    name: \"Nickname\",\n                    value: `${member.nickname || 'No nickname'}`,\n                    inline: true,\n                },\n                {\n                    name: \"Id\",\n                    value: `${member.user.id}`,\n                    inline: true,\n                },\n                {\n                    name: \"Flags\",\n                    value: `${userFlags.length ? userFlags.map(flag => flags[flag]).join(', ') : 'None'}`,\n                    inline: true,\n                },\n                {\n                    name: \"Badges\",\n                    value: `${Badges.FLAGS ? Badges.FLAGS.map(flag => badgeFlags[flag]).join(' ') : 'None'}`,\n                    inline: true,\n                },\n                {\n                    name: \"Discord joined at\",\n                    value: `<t:${Math.round(member.user.createdTimestamp / 1000)}>`,\n                    inline: true,\n                },\n                {\n                    name: \"Server joined at\",\n                    value: `<t:${Math.round(member.joinedAt / 1000)}>`,\n                    inline: true,\n                },\n                {\n                    name: `Roles [${roles.length}]`,\n                    value: `${roles.length ? roles.join(', ') : 'None'}`,\n                    inline: false,\n                }\n            ],\n            type: 'editreply'\n        }, interaction)\n    },\n};\n\n ","size_bytes":5039},"src/interactions/ContextMenu/warn.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { ContextMenuCommandBuilder } = require('discord.js');\nconst Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/warnings\");\nconst Case = require(\"../../database/models/warnCase\");\n\nmodule.exports = {\n    data: new ContextMenuCommandBuilder()\n        .setName('Warn')\n        .setType(2),\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n    run: async (client, interaction, args) => {\n        const perms = await client.checkPerms({\n            flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n            perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n        }, interaction)\n        if (perms === false) {\n            client.errNormal({\n                error: `You don't have the required permissions to use this command!`,\n                type: 'ephemeral'\n            }, interaction);\n            return;\n        }\n        // Create modal to give a reason\n        const modal = new Discord.ModalBuilder()\n            .setTitle('Warn')\n            .setCustomId('warn')\n            .addComponents(\n                new Discord.ActionRowBuilder().addComponents(\n                    new Discord.TextInputBuilder()\n                        .setCustomId('reason')\n                        .setPlaceholder('Reason')\n                        .setLabel('Reason')\n                        .setMinLength(1)\n                        .setStyle(Discord.TextInputStyle.Short)\n                        .setMaxLength(100)),\n            );\n        await interaction.showModal(modal);\n\n        const submitted = await interaction.awaitModalSubmit({\n            time: 60000,\n            filter: i => i.user.id === interaction.user.id,\n        }).catch(() => { });\n\n        if (!submitted) {\n            return;\n        }\n\n        const member = interaction.guild.members.cache.get(interaction.targetId);\n        var caseNumber; \n        await Case.findOne({ Guild: interaction.guild.id }).then(async data => {\n            if(!data) {\n                new Case({\n                    Guild: interaction.guild.id,\n                    Case: 1\n                }).save();\n                caseNumber = 1;\n            }\n            else {\n                data.Case += 1;\n                data.save();\n                caseNumber = data.Case;\n            }\n        });\n\n        Schema.findOne({ Guild: interaction.guild.id, User: member.id }, async (err, data) => {\n            if (data) {\n                data.Warnings.push({\n                    Moderator: interaction.user.id,\n                    Reason: submitted.fields.getTextInputValue(\"reason\"),\n                    Date: Date.now(),\n                    Case: caseNumber\n                });\n                data.save();\n            }\n            else {\n                new Schema({\n                    Guild: interaction.guild.id,\n                    User: member.id,\n                    Warnings: [{\n                        Moderator: interaction.user.id,\n                        Reason: submitted.fields.getTextInputValue(\"reason\"),\n                        Date: Date.now(),\n                        Case: caseNumber\n                    }]\n                }).save();\n            }\n        })\n\n        client.embed({\n            title: `🔨・Warn`,\n            desc: `You've been warned in **${interaction.guild.name}**`,\n            fields: [\n                {\n                    name: \"👤┆Moderator\",\n                    value: interaction.user.tag,\n                    inline: true\n                },\n                {\n                    name: \"📄┆Reason\",\n                    value: submitted.fields.getTextInputValue(\"reason\"),\n                    inline: true\n                }\n            ]\n        }, member).catch(() => { })\n\n        client.emit('warnAdd', member, interaction.user, submitted.fields.getTextInputValue(\"reason\"));\n        client.succNormal({\n            text: `User has received a warning!`,\n            fields: [\n                {\n                    name: \"👤┆User\",\n                    value: `${member}`,\n                    inline: true\n                },\n                {\n                    name: \"👤┆Moderator\",\n                    value: `${interaction.user}`,\n                    inline: true\n                },\n                {\n                    name: \"📄┆Reason\",\n                    value: submitted.fields.getTextInputValue(\"reason\"),\n                    inline: false\n                }\n            ],\n            type: 'ephemeral'\n        }, submitted);\n    },\n};\n\n","size_bytes":4649},"src/interactions/ContextMenu/warnings.js":{"content":"const { CommandInteraction, Client } = require('discord.js');\nconst { ContextMenuCommandBuilder } = require('discord.js');\nconst Discord = require('discord.js');\n\nconst Schema = require(\"../../database/models/warnings\");\n\nmodule.exports = {\n    data: new ContextMenuCommandBuilder()\n        .setName('Warnings')\n        .setType(2),\n\n    /** \n     * @param {Client} client\n     * @param {CommandInteraction} interaction\n     * @param {String[]} args\n     */\n    run: async (client, interaction, args) => {\n        const perms = await client.checkPerms({\n            flags: [Discord.PermissionsBitField.Flags.ManageMessages],\n            perms: [Discord.PermissionsBitField.Flags.ManageMessages]\n        }, interaction)\n\n        if (perms == false){\n            client.errNormal({\n                error: \"You don't have the required permissions to use this command!\",\n                type: 'ephemeral'\n            }, interaction);\n            return;\n        }\n        await interaction.deferReply({ ephemeral: false });\n\n        const member = interaction.guild.members.cache.get(interaction.targetId);\n\n        Schema.findOne({ Guild: interaction.guild.id, User: member.id }, async (err, data) => {\n            if (data) {\n                var fields = [];\n                data.Warnings.forEach(element => {\n                    fields.push({\n                        name: \"Warning **\" + element.Case + \"**\",\n                        value: \"Reason: \" + element.Reason + \"\\nModerator <@!\" + element.Moderator + \">\",\n                        inline: true\n                    })\n                });\n                client.embed({\n                    title: `${client.emotes.normal.error}・Warnings`,\n                    desc: `The warnings of **${member.user.tag}**`,\n                    fields: [\n                        {\n                            name: \"Total\",\n                            value: `${data.Warnings.length}`,\n                        },\n                        ...fields\n                    ],\n                    type: 'editreply'\n                }, interaction)\n            }\n            else {\n                client.embed({\n                    title: `${client.emotes.normal.error}・Warnings`,\n                    desc: `User ${member.user.tag} has no warnings!`,\n                    type: 'editreply'\n                }, interaction)\n            }\n        })\n    },\n};\n\n ","size_bytes":2391}},"version":1}